<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/radahn-medium.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/radahn-medium.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/radahn-small.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-2oysa9iikh">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sulley.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The camera system inside Unreal Engine provides very basic functions. It merely enables the camera to follow a target with limited adjustable paramters such as offset, camera distance, lag, etc. We">
<meta property="og:type" content="article">
<meta property="og:title" content="Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine)">
<meta property="og:url" content="http://sulley.cc/2022/12/11/09/16/index.html">
<meta property="og:site_name" content="Sulley">
<meta property="og:description" content="The camera system inside Unreal Engine provides very basic functions. It merely enables the camera to follow a target with limited adjustable paramters such as offset, camera distance, lag, etc. We">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/1.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/2.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/3.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/4.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/5.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/6.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/8.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/9.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/10.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/11.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/12.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/13.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/14.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/15.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/16.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/17.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/18.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/19.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/20.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/21.png">
<meta property="og:image" content="http://sulley.cc/images/1v1camera/22.png">
<meta property="article:published_time" content="2022-12-11T01:16:34.000Z">
<meta property="article:modified_time" content="2023-01-09T15:38:11.722Z">
<meta property="article:author" content="Sulley">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="UE">
<meta property="article:tag" content="随笔">
<meta property="article:tag" content="数学">
<meta property="article:tag" content="相机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sulley.cc/images/1v1camera/1.png">


<link rel="canonical" href="http://sulley.cc/2022/12/11/09/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://sulley.cc/2022/12/11/09/16/","path":"2022/12/11/09/16/","title":"Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine) | Sulley</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sulley</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Never Betray Yourself.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">25</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">30</span></a></li>
        
            
  <li class="menu-item menu-item-相册"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a></li>


      
        <li class="menu-item menu-item-资源"><a href="/resources/" rel="section"><i class="fa fa-book fa-fw"></i>资源</a></li>
        <li class="menu-item menu-item-留言"><a href="/comments/" rel="section"><i class="fa fa-comment fa-fw"></i>留言</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#start-with-a-simple-case-mathematical-derivation-for-camera-location-and-rotation"><span class="nav-number">1.</span> <span class="nav-text">Start
with A Simple Case: Mathematical Derivation for Camera Location and
Rotation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#constructing-the-equation"><span class="nav-number">1.1.</span> <span class="nav-text">Constructing the equation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#determining-mathbft_1"><span class="nav-number">1.2.</span> <span class="nav-text">Determining \(\mathbf{t}_1\)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#determining-varphi-and-theta"><span class="nav-number">1.3.</span> <span class="nav-text">Determining \(\varphi\) and \(\theta\)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-camera-location-and-rotation"><span class="nav-number">1.4.</span> <span class="nav-text">Final camera location and
rotation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#finer-control-over-the-screen-space"><span class="nav-number">2.</span> <span class="nav-text">Finer Control Over The
Screen Space</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#determining-mathbft_2"><span class="nav-number">2.1.</span> <span class="nav-text">Determining \(\mathbf{t}_2\)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#determining-new-varphi-and-theta"><span class="nav-number">2.2.</span> <span class="nav-text">Determining new \(\varphi\) and \(\theta\)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#but-what-about-the-look-at-position..."><span class="nav-number">2.3.</span> <span class="nav-text">But what about the
look-at position...?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#emulate-cinemachine-by-using-incremental-motion-and-adding-damping"><span class="nav-number">3.</span> <span class="nav-text">Emulate
Cinemachine by using Incremental Motion and Adding Damping</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#high-level-workflow-and-the-initialize-function"><span class="nav-number">3.1.</span> <span class="nav-text">High-level
workflow and the Initialize function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-camera-rotation"><span class="nav-number">3.2.</span> <span class="nav-text">Set camera rotation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-camera-position"><span class="nav-number">3.3.</span> <span class="nav-text">Set camera position</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#result"><span class="nav-number">3.4.</span> <span class="nav-text">Result</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#code"><span class="nav-number">4.</span> <span class="nav-text">Code</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#code-framework"><span class="nav-number">4.1.</span> <span class="nav-text">Code framework</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implementing-framingfollow"><span class="nav-number">4.2.</span> <span class="nav-text">Implementing
FramingFollow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implementing-targetingaim"><span class="nav-number">4.3.</span> <span class="nav-text">Implementing
TargetingAim</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#use-in-unreal-engine"><span class="nav-number">4.4.</span> <span class="nav-text">Use in Unreal Engine</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sulley"
      src="/images/radahn-avatar.png">
  <p class="site-author-name" itemprop="name">Sulley</p>
  <div class="site-description" itemprop="description">珍惜眼前人</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/littlesulley" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;littlesulley" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qinghonghan97@gmail.com" title="E-Mail → mailto:qinghonghan97@gmail.com" rel="noopener" target="_blank"><i class="fa-solid fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1631723" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1631723" rel="noopener" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/beingaway/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;beingaway&#x2F;" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/han-qing-hong-33" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;han-qing-hong-33" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kungtalon.github.io/" title="https:&#x2F;&#x2F;kungtalon.github.io&#x2F;" rel="noopener" target="_blank">Kungtalon</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kaesenudeln.github.io/" title="https:&#x2F;&#x2F;kaesenudeln.github.io&#x2F;" rel="noopener" target="_blank">Zecx</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sulley.cc/2022/12/11/09/16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/radahn-avatar.png">
      <meta itemprop="name" content="Sulley">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sulley">
      <meta itemprop="description" content="珍惜眼前人">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine) | Sulley">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-11 09:16:34" itemprop="dateCreated datePublished" datetime="2022-12-11T09:16:34+08:00">2022-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-09 23:38:11" itemprop="dateModified" datetime="2023-01-09T23:38:11+08:00">2023-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F-%E7%9B%B8%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">游戏 - 相机</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/12/11/09/16/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/12/11/09/16/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>35k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>The camera system inside Unreal Engine provides very basic functions.
It merely enables the camera to follow a target with limited adjustable
paramters such as offset, camera distance, lag, etc. We would like a
more powerful camera system, like the Cinemachine toolset in Unity, to
facilitate creating more interesting and compelling visual experience
for gameplay. In most 3D adventure games, a 1v1 camera is required when
you fight with a BOSS and you need to look at the BOSS however you move
and cast skills. Unfortunately, 1v1 camera is not a built-in function in
UE, so we have to implement our own version of 1v1 camera.</p>
<p>In this post, I will share with you how to implement a minimum 1v1
camera in UE using only blueprints, based on some simple mathematics. If
you are more familiar with coding, you can also implement this 1v1
camera with only few lines of code.</p>
<span id="more"></span>
<h1
id="start-with-a-simple-case-mathematical-derivation-for-camera-location-and-rotation">Start
with A Simple Case: Mathematical Derivation for Camera Location and
Rotation</h1>
<h2 id="constructing-the-equation">Constructing the equation</h2>
<p>The most crucial two parts of any camera behavior are the
<strong>location</strong> and <strong>rotation</strong>, the former
determines where the camera is and the latter controls where the camera
looks at.</p>
<p>Let us first begin with a simple case: assume the follow location is
<span class="math inline">\(\mathbf{a}\)</span>, the look-at location is
<span class="math inline">\(\mathbf{b}\)</span>, and the look-at point
is fixed at the center of the screen. We introduce a
<code>Follow Screen X</code> parameter (denoted by <span
class="math inline">\(a_x\)</span>) controlling the relative x-axis
offset of the follow point on the screen space. If <span
class="math inline">\(a_x=0\)</span>, the follow point will be on the
center of the screen; if <span class="math inline">\(a_x=0.5\)</span>,
the follow point will be on the rightmost position of the screen; if
<span class="math inline">\(a_x=-0.5\)</span>, it will be on the
leftmost position of the screen. At this stage, we do not take
<code>Follow Screen Y</code> into consideration for simplication.</p>
<p>To determine camera location and rotation, consider a sphere centered
at the origin. Assume camera distance (the distance of the camera to the
follow point) is <span class="math inline">\(r\)</span>, pitch angle
<span class="math inline">\(\varphi\in[-\pi/2,\pi/2]\)</span>, yaw angle
<span class="math inline">\(\theta\in[-\pi,\pi]\)</span>, we can write
down the camera location before applying the follow point offset:</p>
<p><span class="math display">\[
\begin{equation}
\mathbf{x}=\begin{pmatrix}
r\cos\varphi\cos\theta\\
r\cos\varphi\sin\theta\\
r\sin\varphi
\end{pmatrix}
\label{x}
\end{equation}
\]</span></p>
<p>Note that <span class="math inline">\(\eqref{x}\)</span> is the
<strong>raw camera location</strong> relative to the origin. The look-at
direction, however, is <span
class="math inline">\(-\mathbf{x}/r\)</span>, and the <strong>actual
camera location</strong> is <span
class="math inline">\(\mathbf{a}+\mathbf{x}\)</span>. For integrating
<span class="math inline">\(a_x\)</span>, we can assume the camera
offset is <span class="math inline">\(\mathbf{t}_1\)</span>, hence, the
<strong>final camera location</strong> is <span
class="math inline">\(\mathbf{a}+\mathbf{x}+\mathbf{t}_1\)</span>, and
the look-at direction from camera to <span
class="math inline">\(\mathbf{b}\)</span> is <span
class="math inline">\(\mathbf{b}-(\mathbf{a}+\mathbf{x}+\mathbf{t}_1)\)</span>.
Because <span class="math inline">\(\mathbf{t}_1\)</span> does not
change the orientation of camera, the camera's look-at direction, as we
have stated above, is still <span
class="math inline">\(-\mathbf{x}/r\)</span>. It is obvious that we have
the following equation:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{b}-\mathbf{a}-\mathbf{x}-\mathbf{t}_1=-k\mathbf{x}
\label{main}
\end{equation}
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is an unknown
coefficient satisfying <span class="math inline">\(k&gt;1\)</span> as we
want the look-at target is farther than the follow target to our camera.
Before wo go ahead solving this equation, we should determine <span
class="math inline">\(\mathbf{t}_1\)</span> at the first place.</p>
<h2 id="determining-mathbft_1">Determining <span
class="math inline">\(\mathbf{t}_1\)</span></h2>
<p>We can easily express <span
class="math inline">\(\mathbf{t}_1\)</span> in terms of <span
class="math inline">\(a_x, r\)</span> and the field of view of the
camera. As shown in the following figure, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \frac{N}{r}=\tan\left(\frac{\text{fov}}{2}\right)\Rightarrow
N=r\tan\left(\frac{\text{fov}}{2}\right)
\label{N}
\end{equation}
\]</span></p>
<p>where <span class="math inline">\(N\)</span> is the world-space
length of half screen. Then, the offset amount is <span
class="math inline">\(2a_xN\)</span> (note that when <span
class="math inline">\(a_x=0.5\)</span>, the offset amount will be <span
class="math inline">\(N\)</span>), and the offset direction will be the
opposite of the sign of <span class="math inline">\(a_x\)</span>. That
is, is <span class="math inline">\(a_x&gt;0\)</span>, camera will
translate left, otherwise it will translate right.</p>
<p><img data-src="/images/1v1camera/1.png" /></p>
<p>Plug <span class="math inline">\(\eqref{N}\)</span> into <span
class="math inline">\(-2x_aN\)</span>, the directional offset magnitude
will be <span
class="math inline">\(-2a_xr\tan\left(\frac{\text{fov}}{2}\right)\)</span>.</p>
<p>A remaining question is which unit vector this offset will be applied
along? The answer is the camera's local right direction. It can be
readily computed by taking the cross product between camera's local unit
forward vector <span class="math inline">\(-\mathbf{x}/r\)</span> and
world space up vector <span
class="math inline">\((0,0,1)^\top\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
    \begin{pmatrix}
    -\cos\varphi\cos\theta\\
    -\cos\varphi\sin\theta\\
    -\sin\varphi
    \end{pmatrix}\times
    \begin{pmatrix}
    0\\
    0\\
    1
    \end{pmatrix}=
    \begin{pmatrix}
    -\cos\varphi\sin\theta\\
    \cos\varphi\cos\theta\\
    0
    \end{pmatrix}
\end{equation}
\]</span></p>
<p>Normalizing the result, and considering that UE's coordiante system
is based on the left-hand rule, the local unit right vector will be
<span class="math inline">\((\sin\theta, -\cos\theta, 0)^\top\)</span>.
Thus, the consequent offset vector is:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{t}_1=t_1\begin{pmatrix}
    \sin\theta\\
    -\cos\theta\\
    0
    \end{pmatrix},~~t_1=-2a_xr\tan\left(\frac{\text{fov}}{2}\right)
\end{equation}
\]</span></p>
<h2 id="determining-varphi-and-theta">Determining <span
class="math inline">\(\varphi\)</span> and <span
class="math inline">\(\theta\)</span></h2>
<p>With <span class="math inline">\(\mathbf{t}_1\)</span>, we can now
determine <span class="math inline">\(\varphi\)</span> and <span
class="math inline">\(\theta\)</span>. Expanding <span
class="math inline">\(\eqref{main}\)</span>, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \begin{pmatrix}
    x_B\\
    y_B\\
    z_B
    \end{pmatrix}-
    \begin{pmatrix}
    x_A\\
    y_A\\
    z_A
    \end{pmatrix}-
    \begin{pmatrix}
    r\cos\varphi\cos\theta\\
    r\cos\varphi\sin\theta\\
    r\sin\varphi
    \end{pmatrix}-
    \begin{pmatrix}
    t_1\sin\theta\\
    -t_1\cos\theta\\
    0
    \end{pmatrix}=-k\begin{pmatrix}
    r\cos\varphi\cos\theta\\
    r\cos\varphi\sin\theta\\
    r\sin\varphi
    \end{pmatrix}
\label{eq6}
\end{equation}
\]</span></p>
<p>Simplifying <span class="math inline">\(\eqref{eq6}\)</span>, we
have:</p>
<p><span class="math display">\[
\begin{pmatrix}
\Delta x\\
\Delta y\\
\Delta z
\end{pmatrix}=
\begin{pmatrix}
    (1-k)r\cos\varphi\cos\theta+t_1\sin\theta\\
    (1-k)r\cos\varphi\sin\theta-t_1\cos\theta\\
    (1-k)r\sin\varphi
\end{pmatrix}
\]</span></p>
<p>which leads to three equations:</p>
<p><span class="math display">\[
\begin{align}
    (1-k)r\cos\varphi\cos\theta+t_1\sin\theta &amp;= \Delta x
\label{eq7}\\
    (1-k)r\cos\varphi\sin\theta-t_1\cos\theta &amp;= \Delta y
\label{eq8}\\
    (1-k)r\sin\varphi &amp;= \Delta z \label{eq9}
\end{align}
\]</span></p>
<p>Rewrite <span class="math inline">\(\eqref{eq9}\)</span>, we
have:</p>
<p><span class="math display">\[
\begin{equation}
    (1-k)r=\frac{\Delta z}{\sin\varphi}
    \label{eq10}
\end{equation}
\]</span></p>
<p>Plug <span class="math inline">\(\eqref{eq10}\)</span> into <span
class="math inline">\(\eqref{eq7}\)</span> and <span
class="math inline">\(\eqref{eq8}\)</span>:</p>
<p><span class="math display">\[
\begin{align}
    \frac{\Delta z}{\tan\varphi}\cos\theta+t_1\sin\theta &amp;= \Delta x
\label{eq11}\\
    \frac{\Delta z}{\tan\varphi}\sin\theta-t_1\cos\theta &amp;= \Delta y
\label{eq12}\\
\end{align}
\]</span></p>
<p>Combining <span class="math inline">\(\eqref{eq11}\)</span> and <span
class="math inline">\(\eqref{eq12}\)</span>, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \frac{\Delta x - t_1\sin\theta}{\cos\theta}=\frac{\Delta y
+t_1\cos\theta}{\sin\theta}\Rightarrow \Delta x\sin\theta-\Delta
y\cos\theta=t_1
\label{eq13}
\end{equation}
\]</span></p>
<p>To note, when <span class="math inline">\(\theta=0\)</span> or <span
class="math inline">\(\theta=\pi\)</span>, the above equation also
holds. Divided by <span class="math inline">\(\sqrt{(\Delta x)^2+(\Delta
y)^2}\)</span> on both sides, we have:</p>
<p><span class="math display">\[
\small
\begin{equation}
\begin{aligned}
    \frac{t_1}{\sqrt{(\Delta x)^2+(\Delta y)^2}} &amp;= \frac{\Delta
x}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\sin\theta-\frac{\Delta
y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\cos\theta\\
    \frac{t_1}{\sqrt{(\Delta x)^2+(\Delta y)^2}} &amp;=
\cos\alpha\sin\theta-\sin\alpha\cos\theta \\
    \frac{t_1}{\sqrt{(\Delta x)^2+(\Delta y)^2}} &amp;=
\sin(\theta-\alpha) \\
    \theta &amp;= {\color{cyan}\alpha} + {\color{pink}\beta}\\
    \theta &amp;= {\color{cyan}\arcsin\left(\frac{\Delta
y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\right)}+
{\color{pink}\arcsin\left(\frac{t_1}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\right)}
\end{aligned}
\label{eq14}
\end{equation}
\]</span></p>
<p>The tinted values <span
class="math inline">\({\color{cyan}\alpha=\arcsin\left(\frac{\Delta
y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\right)}\)</span> and <span
class="math inline">\({\color{pink}\beta=\arcsin\left(\frac{t_1}{\sqrt{(\Delta
x)^2+(\Delta y)^2}}\right)}\)</span> should be calibrated according to
the sign of <span class="math inline">\(\Delta x\)</span> and <span
class="math inline">\(\Delta y\)</span>. It's particularly noteworthy
that when <span class="math inline">\({\color{pink}\beta=0}\)</span>,
<span class="math inline">\({\color{cyan}\alpha}\)</span> should be:</p>
<ul>
<li><span class="math inline">\(\Delta x&gt;0\)</span> and <span
class="math inline">\(\Delta y&gt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[-\pi,-\pi/2]}\)</span></li>
<li><span class="math inline">\(\Delta x&gt;0\)</span> and <span
class="math inline">\(\Delta y&lt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[\pi/2,\pi]}\)</span></li>
<li><span class="math inline">\(\Delta x&lt;0\)</span> and <span
class="math inline">\(\Delta y&gt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[-\pi/2,0]}\)</span></li>
<li><span class="math inline">\(\Delta x&lt;0\)</span> and <span
class="math inline">\(\Delta y&gt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[0,\pi/2]}\)</span></li>
</ul>
<p>However, the value returned by <span
class="math inline">\(\arcsin(\cdot)\)</span> lies within <span
class="math inline">\([-\pi/2,\pi/2]\)</span> and should be further
altered according to the observation above. It can be easily concluded
that:</p>
<p><span class="math display">\[
\begin{equation}
    \hat{\alpha}=\begin{cases}
        {\color{cyan}\alpha}-\pi,~&amp;\Delta x&gt;0\\
        -{\color{cyan}\alpha},~&amp;\Delta x\le 0
    \end{cases}
\label{eq15}
\end{equation}
\]</span></p>
<p>For <span class="math inline">\(\beta\)</span>, we notice that when
<span class="math inline">\(t_1\)</span> is positive and gets larger,
the camera's yaw will decrease, so the real beta will be <span
class="math inline">\(\hat{\beta}=-{\color{pink}\beta}\)</span>. Summing
up the corrected values, we reach the true camera yaw <span
class="math inline">\(\hat{\theta}=\hat{\alpha}+\hat{\beta}\)</span>.</p>
<p>The second problem, which is very palpable, is that <span
class="math inline">\(\frac{t_1}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\)</span> can be smaller than <span
class="math inline">\(-1\)</span> or larger than <span
class="math inline">\(1\)</span>, when the denominator — the distance
between follow point and look-at point — is small. If this value exceeds
the bound and we clip it, the resulting yaw <span
class="math inline">\(\theta\)</span> and the subsequent pitch <span
class="math inline">\(\varphi\)</span> would be incorrect, making odd
camera artifacts.</p>
<p>Here are several potential workarounds to deal with this issue:</p>
<ul>
<li>Dynamically adapts <span class="math inline">\(a_x\)</span> to
ensure the absolute value of <span class="math inline">\(t_1\)</span> is
no larger than <span class="math inline">\(\sqrt{(\Delta x)^2+(\Delta
y)^2}\)</span>.</li>
<li>Introduce the concept of <strong>soft zone</strong> and apply
damping just as Cinemachine does.</li>
</ul>
<p>Method two might be a better way because it has smooth result. We
will get to this in later sections of this post, and now we focus on
implementing method one, which is much simpler to achieve using
blueprint. <span id="scale">All we need to do is to set a
<code>BeginAdaptDistanceX</code> and <code>EndAdaptDistanceX</code> that
adapts <span class="math inline">\(a_x\)</span> when <span
class="math inline">\(\sqrt{(\Delta x)^2+(\Delta y)^2}\)</span> is
within the range of <span
class="math inline">\([\text{EndAdaptDistanceX},\text{BeginAdaptDistanceX}]\)</span>.</span>
More concretely, when the distance is within the range, new <span
class="math inline">\(a_x\)</span> will be <span
class="math inline">\(a_x\frac{\text{CurrentDistance}-\text{EndAdaptDistanceX}}{\text{BeginAdaptDistanceX}-\text{EndAdaptDistanceX}}\)</span>.
When both values are set to zero, no scale is applied, when <span
class="math inline">\(\text{EndAdaptDistance}\)</span> is negative,
<span class="math inline">\(a_x\)</span> will have its minimum (the
absolute value) greater than zero. It is very effective and flexible to
use this value in order for avoiding zero-division as will be introduced
in <span class="math inline">\(\eqref{eq16}\)</span>. Directly clamping
<span class="math inline">\(t_1\)</span> between <span
class="math inline">\([-\sqrt{(\Delta x)^2+(\Delta y)^2},\sqrt{(\Delta
x)^2+(\Delta y)^2}]\)</span> will not bring about satisfactory
results.</p>
<p>Note that we leave out the case when <span
class="math inline">\(\Delta x=\Delta y =0\)</span> since for most of
the time the player character and the enemy will not be on the up axis
at the same time.</p>
<p>Once we have <span class="math inline">\(\hat{\theta}\)</span>, we
can easily find out <span class="math inline">\(\varphi\)</span>. By
<span class="math inline">\(\eqref{eq11}\)</span> (or <span
class="math inline">\(\eqref{eq12}\)</span> equivalently), we have:</p>
<p><span class="math display">\[
\begin{equation}
    \varphi=\arctan\left(\frac{\Delta z\cos\hat{\theta}}{\Delta
x-t_1\sin\hat{\theta}}\right)
\label{eq16}
\end{equation}
\]</span></p>
<p>You may ask what will happen if <span class="math inline">\(\Delta
x-t_1\sin\hat{\theta}\)</span> is close to zero? Well, this could not be
a problem as we have already dynamically adapted <span
class="math inline">\(t_1\)</span> with respect to the follow-lookat
distance, as long as the values of <code>BeginAdaptDistanceX</code> and
<code>EndAdaptDistanceX</code> are properly set.</p>
<p>What are <span class="math inline">\(\varphi,\hat{\theta}\)</span>
when <span class="math inline">\(t_1=0\)</span>? From <span
class="math inline">\(\eqref{eq14}\)</span>, we know <span
class="math inline">\(\hat{\theta}=\hat{\alpha}\)</span>; then from
<span class="math inline">\(\eqref{eq14}\eqref{eq16}\)</span> and using
the fact that <span
class="math inline">\(\cos(\arcsin(x))=\sqrt{1-x^2}\)</span>, we have
<span class="math inline">\(\varphi=-\arctan\left(\frac{\Delta
z}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\right)\)</span>.</p>
<h2 id="final-camera-location-and-rotation">Final camera location and
rotation</h2>
<p>To summarize, we first compute <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span> with <span
class="math inline">\(\eqref{eq14}\)</span>:</p>
<p><span class="math display">\[
\alpha=\arcsin\left(\frac{\Delta y}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\right),~\beta=\arcsin\left(\frac{t_1}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\right)
\]</span></p>
<p>Then we calibrate <span class="math inline">\(\alpha\)</span> and
<span class="math inline">\(\beta\)</span>:</p>
<p><span class="math display">\[
\hat{\alpha}=\begin{cases}
        \alpha-\pi,~&amp;\Delta x&gt;0\\
        -\alpha,~&amp;\Delta x\le 0
\end{cases},~~~\hat{\beta}=-\beta
\]</span></p>
<p>the addition is the yaw we want: <span
class="math inline">\(\hat{\theta}=\hat{\alpha}+\hat{\beta}\)</span>. To
remedy the issue of overflowing when <span
class="math inline">\(\sqrt{(\Delta x)^2+(\Delta y)^2}\)</span> is
small, we impose an range in which the raw screen offset <span
class="math inline">\(a_x\)</span> is dynamically adjusted and achieve
smooth camera motion.</p>
<p>The camera pitch can be readily computed:</p>
<p><span class="math display">\[\varphi=\arctan\left(\frac{\Delta
z\cos\hat{\theta}}{\Delta x-t_1\sin\hat{\theta}}\right)\]</span></p>
<p>Eventually, we can compute the camera location and rotation. Location
is <span
class="math inline">\(\mathbf{x}+\mathbf{a}+\mathbf{t}_1\)</span>, and
rotation can be set to look at <span
class="math inline">\(\mathbf{b}\)</span>.</p>
<p>Here is a video showcasing this camera with different parameter
values.</p>
<video src="/images/1v1camera/showcase1.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<p>Here is the blueprint I make to implement this camera. It is now a
little out of order and I will make it more readable and extensible in
next sections.</p>
<p>In the main graph, we get camera yaw and pitch, get camera / rotation
and set them in each frame.</p>
<p><img data-src="/images/1v1camera/2.png" /></p>
<p>The <code>GetCameraYawAndPitch</code> function starts with applying
the follow position and look-at position offset. Note that the follow
position offset is based on the follow target's local coordinate.</p>
<p><img data-src="/images/1v1camera/3.png" /></p>
<p>Then, we store temporary variables including <span
class="math inline">\(\Delta X,\Delta Y,\Delta Z\)</span> and <span
class="math inline">\(t_1\)</span>.</p>
<p><img data-src="/images/1v1camera/4.png" /></p>
<p>Last, we compute yaw and pitch, and return them.</p>
<p><img data-src="/images/1v1camera/5.png" /></p>
<p>The <code>GetT1</code> function computes and returns <span
class="math inline">\(t_1\)</span>. We dynamically scale <span
class="math inline">\(a_x\)</span> according to the current
follow-lookat distance (in the XY plane).</p>
<p><img data-src="/images/1v1camera/6.png" /> <img
src="/images/1v1camera/7.png" /></p>
<p>The <code>GetCameraLocation</code> sums up the three components.</p>
<p><img data-src="/images/1v1camera/8.png" /></p>
<p>The <code>GetCameraRotation</code> forces the camera to orient to the
look-at target.</p>
<p><img data-src="/images/1v1camera/9.png" /></p>
<h1 id="finer-control-over-the-screen-space">Finer Control Over The
Screen Space</h1>
<p>To get a finer control of the follow point and look-at point on the
screen space, we would like to introduce three more paramters
<code>Follow Screen Y</code>, <code>Lookat Screen X</code> and
<code>Lookat Screen Y</code> respectively denoting the Y axis screen
position of the follow point, the X axis screen position of the lookat
point and the Y axis screen position of the lookat point. We first talk
about <code>Follow Screen Y</code>.</p>
<h2 id="determining-mathbft_2">Determining <span
class="math inline">\(\mathbf{t}_2\)</span></h2>
<p>Assume <span class="math inline">\(\mathbf{t}_2\)</span> is the
Y-axis offset applied to the camera, <span
class="math inline">\(a_y\in[-0.5,0.5]\)</span> is the value of
<code>Follow Screen Y</code>. When <span
class="math inline">\(a_y=-0.5\)</span>, the follow point lies at the
bottom edge of the screen, and at the top edge when <span
class="math inline">\(a_y=0.5\)</span>. Following what we do for <span
class="math inline">\(\mathbf{t}_1\)</span>, we can easily express <span
class="math inline">\(\mathbf{t}_2\)</span> as:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{t}_2=t_2\begin{pmatrix}
    -\sin\varphi\cos\theta\\
    -\sin\varphi\sin\theta\\
    \cos\varphi
    \end{pmatrix},~~t_2=-\frac{2a_yr}{\text{AspectRatio}}\tan\left(\frac{\text{fov}}{2}\right)
\end{equation}
\]</span></p>
<p>where <span
class="math inline">\(\mathbf{u}=(\sin\varphi\cos\theta,\sin\varphi\sin\theta,-\cos\varphi)^\top\)</span>
is camera's local up vector from the cross product of camera's local
forward vector <span
class="math inline">\(\mathbf{f}=(-\cos\varphi\cos\theta,-\cos\varphi\sin\theta,-\sin\varphi)^\top\)</span>
and camera's local right vector <span
class="math inline">\(\mathbf{r}=(\sin\theta,-\cos\theta,0)^\top\)</span>
(note again UE uses the left-hand rule). <span
class="math inline">\(\text{AspectRatio}\)</span> is camera's aspect
ratio (usually 16:9).</p>
<h2 id="determining-new-varphi-and-theta">Determining new <span
class="math inline">\(\varphi\)</span> and <span
class="math inline">\(\theta\)</span></h2>
<p>Going back to <span class="math inline">\(\eqref{main}\)</span> and
adding <span class="math inline">\(\mathbf{t}_2\)</span>, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{b}-\mathbf{a}-\mathbf{x}-\mathbf{t}_1-\mathbf{t}_2=-k\mathbf{x}
\label{eq18}
\end{equation}
\]</span></p>
<p>Then we have:</p>
<p><span class="math display">\[
\begin{align}
    (1-k)r\cos\varphi\cos\theta+t_1\sin\theta-t_2\sin\varphi\cos\theta
&amp;= \Delta x \label{eq19}\\
    (1-k)r\cos\varphi\sin\theta-t_1\cos\theta-t_2\sin\varphi\sin\theta
&amp;= \Delta y \label{eq20}\\
    (1-k)r\sin\varphi+t_2\cos\varphi &amp;= \Delta z \label{eq21}
\end{align}
\]</span></p>
<p>Interestingly, the resulting <span
class="math inline">\(\hat{\theta}\)</span> by combining <span
class="math inline">\(\eqref{eq19}\)</span> and <span
class="math inline">\(\eqref{eq20}\)</span> remains the same as <span
class="math inline">\(\eqref{eq14}\)</span>. So we do not need to change
the way we compute <span
class="math inline">\(\hat{\theta}\)</span>.</p>
<p>For <span class="math inline">\(\varphi\)</span>, it's a little
tricky. First, we rewrite <span
class="math inline">\(\eqref{eq21}\)</span> as <span
class="math inline">\((1-k)r=\frac{\Delta
z+t_2\cos\varphi}{\sin\varphi}\)</span>, we plug it into <span
class="math inline">\(\eqref{eq19}\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
    \frac{\Delta x-t_1\sin\theta}{\cos\theta}=\frac{\Delta
z\cos\varphi+t_2}{\sin\varphi}
\end{equation}
\]</span></p>
<p>This leads to <span class="math inline">\(A\sin\varphi-\Delta
z\cos\varphi=t_2\)</span> (we let <span
class="math inline">\(A=\frac{\Delta
x-t_1\sin\theta}{\cos\theta}\)</span>). We can use the same technique
for computing <span class="math inline">\(\hat{\theta}\)</span> to solve
<span class="math inline">\(\hat{\varphi}\)</span>. That will be:</p>
<p><span class="math display">\[
\small
\begin{equation}
\begin{aligned}
    \varphi &amp;= {\color{cyan}\gamma} + {\color{pink}\tau}\\
    \varphi &amp;= {\color{cyan}\arcsin\left(\frac{\Delta
z}{\sqrt{A^2+(\Delta z)^2}}\right)}+
{\color{pink}\arcsin\left(\frac{t_2}{\sqrt{A^2+(\Delta z)^2}}\right)}
\end{aligned}
\label{eq23}
\end{equation}
\]</span></p>
<p>When <span class="math inline">\(t_2=0\)</span> and with the identity
<span class="math inline">\(\tan(\arcsin(x))=x/\sqrt{1-x^2}\)</span>, we
have <span class="math inline">\(\varphi_{t_2=0}=\pm\frac{\Delta
z\cos\hat{\theta}}{\Delta x-t_1\sin\hat{\theta}}\)</span>. The only
thing left is to determine the real value of <span
class="math inline">\({\color{cyan}\gamma}\)</span> and <span
class="math inline">\({\color{pink}\tau}\)</span>. Through experiment,
we know both signs are positive.</p>
<p>Besides, we also introduce <code>BeginAdaptDistanceY</code> and
<code>EndAdaptDistanceY</code>, in analogy to what we do for
<code>ScreenX</code>, to dynamically scale <span
class="math inline">\(a_y\)</span> when the follow point and the look-at
position is close. In this way, we achieve smooth camera move for both
<code>ScreenX</code> and <code>ScreenY</code>.</p>
<h2 id="but-what-about-the-look-at-position...">But what about the
look-at position...?</h2>
<p>We introduce four new parameters, <span
class="math inline">\(\Theta\)</span>, the yaw angle based on camera's
local space and <span class="math inline">\(b_x=\text{Lookat Screen
X}\)</span>, and <span class="math inline">\(\Phi\)</span>, the pitch
angle based on camera's local space and <span
class="math inline">\(b_y=\text{Lookat Screen Y}\)</span>. We adjust
<span class="math inline">\(\Theta\)</span> and <span
class="math inline">\(\Phi\)</span> (i.e., rotating camera at its own
local coordinate) to accommodate look-at position manupulation on screen
space.</p>
<p>Nonetheless, when biasing the look-at point on screen space, we will
encounter some problems. If we allow for camera rotation at its local
coordinate, the values of <span class="math inline">\(t_1\)</span> and
<span class="math inline">\(t_2\)</span> computed above would be wrong,
because the local orientation of camera can significantly influence the
follow position on screen space. Now that the determination of <span
class="math inline">\(t_1, t_2\)</span> and the determination of
camera's local orientation are entangled, establishing and solving the
equation can be very difficult, particularly for an explicit
solution.</p>
<p>(*: There might be a nice explicit solution, but for now I won't
manage to solve it out. Perhaps for someday in the future I will take a
shot.)</p>
<p>What we gonna do to mitigate this issue is to increment camera
position and orientation, rather than hard-set it at its "correct"
position and orientation. This is exactly what Cinemachine does for
camera motion.</p>
<h1
id="emulate-cinemachine-by-using-incremental-motion-and-adding-damping">Emulate
Cinemachine by using Incremental Motion and Adding Damping</h1>
<p>Our solution is to emulate Cinemachine in Unity through incrementally
changing camera position and rotation. This paradigm also enjoys the
benifit of adding damping easily. To increment camera motion, we only
need to calculate the desired position and rotation, and interpolate
between its current state and its desired state.</p>
<p>Let us go through the process by showing the blueprints.</p>
<h2 id="high-level-workflow-and-the-initialize-function">High-level
workflow and the <code>Initialize</code> function</h2>
<p>The high-level steps are pretty simple: we first determine and set
camera rotation, then set camera position. <code>FirstFrame</code> is a
boolean variable used to indicate whether the current tick is the first
frame during execution. If it is, no damping will be applied.</p>
<p><img data-src="/images/1v1camera/10.png" /></p>
<p>The <code>Initialize</code> function integrates the follow offset and
look-at offset to get the real follow position and lookat position.</p>
<p><img data-src="/images/1v1camera/11.png" /></p>
<h2 id="set-camera-rotation">Set camera rotation</h2>
<p>The <code>Set Camera Rotation</code> function gets the delta rotation
(after damping), and then rotates camera accordingly.</p>
<p><img data-src="/images/1v1camera/12.png" /></p>
<p>Similarly, the <code>Set Camera Position</code> function gets the
delta position (after damping), and then shifts camera in its local
reference frame, not changing camera orientation.</p>
<p><img data-src="/images/1v1camera/13.png" /></p>
<p>The first part of the <code>Get Delta Rotation</code> function
examines whether camera is too close to the look-at target. If it is the
case, the camera will not update its rotation.</p>
<p><img data-src="/images/1v1camera/14.png" /></p>
<p>Then, the second part of <code>Get Delta Rotation</code> computes the
difference between current rotation and the desired rotation, taking the
given look-at screen offset into account.</p>
<p><img data-src="/images/1v1camera/15.png" /></p>
<p>Last, the third part of <code>Get Delta Rotation</code> optionally
applies damping to the difference rotation and returns the damped
result.</p>
<p><img data-src="/images/1v1camera/16.png" /></p>
<p>Going inside the <code>Damp Rotation</code> function, we find it
separately damps each of the rotation component roll, pitch and yaw, all
using the <code>Damper</code> function.</p>
<p><img data-src="/images/1v1camera/17.png" /></p>
<p>The <code>Damper</code> function, however, is a simple exponential
decay operator that leaves a particular negligible residual after
<code>Damp Time</code>. It can be formulated as:</p>
<p><span
class="math display">\[\text{DampedInput}=\text{RawInput}\cdot\left(1-\mathrm{e}^{\ln(k)\frac{\Delta
T}{T}}\right)\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the negligible
residual, say <span class="math inline">\(0.01\)</span>, and <span
class="math inline">\(T\)</span> is the expected damp time.</p>
<p><img data-src="/images/1v1camera/18.png" /></p>
<h2 id="set-camera-position">Set camera position</h2>
<p>The <code>Get Delta Position</code> has a similar workflow. It first
computes the scaled follow screen offset. We have introduced it in the
first section (see <a href="#scale">here</a>).</p>
<p><img data-src="/images/1v1camera/19.png" /></p>
<p>Then, it converts the follow position from world space to camera's
local space. It is a little bit relating to mathematics. Put it simply,
assume the camera's local forward vector is <span
class="math inline">\(\mathbf{f}\)</span>, right vector is <span
class="math inline">\(\mathbf{r}\)</span> and up vector is <span
class="math inline">\(\mathbf{u}\)</span>, and the world space follow
position is <span
class="math inline">\(\mathbf{a}=(x,y,z)^\top\)</span>. The local
coordinate of <span class="math inline">\(\mathbf{a}\)</span> would
be:</p>
<p><span class="math display">\[\mathbf{a}&#39;=\begin{bmatrix}
    \mathbf{f}^\top\\
    \mathbf{r}^\top\\
    \mathbf{u}^\top
\end{bmatrix}\mathbf{a}=\begin{bmatrix}
    \mathbf{f}_x &amp; \mathbf{f}_y &amp; \mathbf{f}_z\\
    \mathbf{r}_x &amp; \mathbf{r}_y &amp; \mathbf{r}_z\\
    \mathbf{u}_x &amp; \mathbf{u}_y &amp; \mathbf{u}_z
\end{bmatrix}\begin{bmatrix}
    x\\
    y\\
    z
\end{bmatrix}\]</span></p>
<p><img data-src="/images/1v1camera/20.png" /></p>
<p>A local space coordiante facilitates computing the difference between
current camera position and desired position. Follow screen offset is
also incorporated.</p>
<p><img data-src="/images/1v1camera/21.png" /></p>
<p>Last, we damp the difference position and returns the result. The
<code>Damp Position</code> function manipulates three
<code>Raw Delta Position</code> components instead of two as we did in
<code>Damp Rotation</code>.</p>
<p><img data-src="/images/1v1camera/22.png" /></p>
<h2 id="result">Result</h2>
<p>OK, let us enjoy our achievements! We can freely play with various
parameters and see how the camera responses. You may notice that only
setting up the follow damping leads to camera jitter, not drastic but
still perceptible. A possible reason for this phenomenon is the unstable
tick rate on my PC. We can, of course, increase the frame rate, but a
more robust solution is to modify our damping algorithm. Rather than
directly use <code>DeltaTime</code> as the damping step size, we can
further split <code>DeltaTime</code> into several sub-delta time steps,
and simulate damping for each time step upon the last simulation,
finally having a much more smooth damping result. This is exactly what
Cinemachine does when <code>DeltaTime</code> is unstable.</p>
<video src="/images/1v1camera/showcase2.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<p>Another potential enhancement is to add the concept of <strong>Soft
Zone</strong>, which defines a rectangular area in screen space where
follow / look-at point is allowed to move around and the rest screen
space where follow / look-at point will never show up in. In other
words, the follow / look-at position is hard restricted in the soft
zone. It provides a more flexible screen space control over our point of
interest.</p>
<p>(*: I've already added soft zone and the improved damping algorithm
in both blueprints and code implementation. Feel free to use and modify
as whatever you like.)</p>
<p><strong>Complementary note</strong></p>
<p>The improved damping algorithm is not difficult to implement. Suppose
we want to split <code>DeltaTime</code> <span
class="math inline">\(\Delta T\)</span> into <span
class="math inline">\(n\)</span> equal sub-parts, each of which is <span
class="math inline">\(\Delta T/n\)</span>. Then the decay factor is
<span class="math inline">\(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\)</span>. The original delta amount is <span
class="math inline">\(I\)</span>, and the split segment will be <span
class="math inline">\(I/n\)</span>. The simulation progressively damps
each segment <span class="math inline">\(I/n\)</span> using the decay
factor <span class="math inline">\(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\)</span>.</p>
<p>In the first iteration, the residual is <span
class="math inline">\(\frac{I}{n}\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\)</span>, or the actor traverses <span
class="math inline">\(\frac{I}{n}(1-\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}})\)</span> in other words. In the second iteration, the residual
will be:</p>
<p><span
class="math display">\[\left(\frac{I}{n}\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}+\frac{I}{n}\right)\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}=\frac{I}{n}\left(\left(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)^2+\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)\]</span></p>
<p>This process terminates until the last <span
class="math inline">\(n\)</span>-th iteration, where the final residual
will be:</p>
<p><span
class="math display">\[\frac{I}{n}\left(\left(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)^n+\cdots+\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)=\frac{I}{n}\cdot\frac{\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}(1-\mathrm{e}^{\ln(k)\frac{\Delta
T}{T}})}{1-\mathrm{e}^{\ln(k)\frac{\Delta T}{nT}}}\]</span></p>
<p>Compared with the original residual without multi-step simulation
<span class="math inline">\(I\cdot \mathrm{e}^{\ln(k)\frac{\Delta
T}{T}}\)</span>, the simulated result will almost always be larger than
the non-simulated conterpart, implying that the actor moves less within
duration <span class="math inline">\(\Delta T\)</span>. This makes the
actor behave more smooth under deltatime variability.</p>
<h1 id="code">Code</h1>
<p>Our last step is to code-implement the Cinemachine-like 1v1 camera
system. It is not hard but as we want a more practical, robust and
extensible camera system, we would like to organize the code in a more
systematical way. Cinemachine makes a great example (thank you,
Cinemachine).</p>
<h2 id="code-framework">Code framework</h2>
<p>The overall code framework can be simply illustrated using the
following class diagram:</p>
<pre class="mermaid">
classDiagram
class AMECameraBase { 
    USceneComponent* SceneRootComponent
    UMECameraSettingsComponent* MainMECameraComponent
    UCameraComponent* MainCamera
    UMECameraSettingsComponent* GetSettingsComponent()
    UCameraComponent* GetCameraComponent()
}
AMECameraBase --&gt; AActor : Inherit
UMECameraLibrary --&gt; UBlueprintFunctionLibrary : Inherit
class UMECameraLibrary {
    static void DamperValue(EDampMethod DampMethod, const float&amp; DeltaSeconds, const float&amp; Input, float DampTime, double&amp; Output, float Residual &#x3D; 0.01)
    static void DamperVectorWithSameDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FVector&amp; Input, float DampTime, FVector&amp; Output, float Residual &#x3D; 0.01)
    static void DamperVectorWithDifferentDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FVector&amp; Input, FVector DampTime, FVector&amp; Output, float Residual &#x3D; 0.01)
    static void DamperRotatorWithSameDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FRotator&amp; Input, float DampTime, FRotator&amp; Output, float Residual &#x3D; 0.01)
    static void DamperRotatorWithDifferentDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FRotator&amp; Input, FVector DampTime, FRotator&amp; Output, float Residual &#x3D; 0.01)
    static AMECameraBase* CallCamera(TSubclassOf&lt;AMECameraBase&gt; CameraClass, AActor* FollowTarget, AActor* AimTarget, float BlendTime, enum EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
}
</pre>
<pre class="mermaid">
classDiagram
class UMECameraComponentBase {
    EStage Stage
    AActor* OwningActor
    UMECameraSettingsComponent* OwningSettingComponent
    UCameraComponent* OwningCamera
    virtual void UpdateComponent(float DeltaTime)
}
UMECameraComponentBase &lt;-- UMECameraComponentFollow : Inherit
UMECameraComponentBase &lt;-- UMECameraComponentAim : Inherit
class UMECameraComponentFollow {
    TObjectPtr~AActor~ FollowTarget
    virtual void UpdateComponent(float DeltaTime) override
}
class UMECameraComponentAim {
    TObjectPtr~AActor~ AimTarget
    virtual void UpdateComponent(float DeltaTime) override
}
UMECameraComponentFollow &lt;-- UFramingFollow : Inherit
class UFramingFollow {
    float CameraDistance
    FVector FollowOffset
    EDampMethod DampMethod
    float DampResidual
    FVector FollowDamping
    FVector2f ScreenOffset
    FVector2f AdaptiveScreenOffsetDistanceX
    FVector2f AdaptiveScreenOffsetDistanceY
    FVector2f ScreenOffsetWidth
    FVector2f ScreenOffsetHeight
    virtual void UpdateComponent(float DeltaTime) override
}
UMECameraComponentAim &lt;-- UTargetingAim : Inherit
class UTargetingAim {
    FVector AimOffset
    EDampMethod DampMethod
    float DampResidual
    FVector AimDamping
    FVector2f ScreenOffset
    FVector2f ScreenOffsetWidth
    FVector2f ScreenOffsetHeight
    virtual void UpdateComponent(float DeltaTime) override
}
UMECameraComponentFollow &lt;-- USimpleFollow : Inherit
UMECameraComponentFollow &lt;-- UOrbitFollow : Inherit
UMECameraComponentFollow &lt;-- UHardLockFollow : Inherit
UMECameraComponentAim &lt;-- UPlayerControlAim : Inherit
UMECameraComponentAim &lt;-- UGroupTargetingAim : Inherit
UMECameraComponentAim &lt;-- UHardLockAim : Inherit
</pre>
<pre class="mermaid">
classDiagram
USceneComponent &lt;-- UMECameraSettingsComponent : Inherit
class UMECameraSettingsComponent {
    TObjectPtr~UMECameraComponentFollow~ FollowComponent
    TObjectPtr ~UMECameraComponentAim~ AimComponent
    TArray~UMECameraExtensionBase*~ Extensions
    TArray~UMECameraComponentBase*~ ComponentContainer
	TObjectPtr~AActor~ FollowTarget
	TObjectPtr~AActor~ AimTarget
    AActor* SetFollowTarget(AActor* NewFollowTarget)
    void UpdateFollowTarget(AActor* NewFollowTarget)
    AActor* GetFollowTarget() const
    AActor* SetAimTarget(AActor* NewAimTarget)
    void UpdateAimTarget(AActor* NewAimTarget)
    AActor* GetAimTarget() const
    virtual void InitializeMECameraComponents()
    virtual void InitializeMECameraComponent(UMECameraComponentBase* Component)
    virtual void PostEditChangeProperty(FPropertyChangedEvent&amp; PropertyChangedEvent) override
}
</pre>
<h2 id="implementing-framingfollow">Implementing
<code>FramingFollow</code></h2>
<p><code>FramingFollow</code> is akin to <code>Framing Transposer</code>
in Cinemachine. Here is my simple-to-understand implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFramingFollow::UpdateComponent</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">UpdateComponent</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FollowTarget != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		FVector FollowPosition = <span class="built_in">GetRealFollowPosition</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Get real screen offset. */</span></span><br><span class="line">		FVector AimPosition = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		FVector2f RealScreenOffset = <span class="built_in">FVector2f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetOwningSettingComponent</span>()-&gt;<span class="built_in">GetAimComponent</span>() != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">GetOwningSettingComponent</span>()-&gt;<span class="built_in">GetAimComponent</span>()-&gt;<span class="built_in">GetAimTarget</span>() != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			AimPosition = <span class="built_in">GetOwningSettingComponent</span>()-&gt;<span class="built_in">GetAimComponent</span>()-&gt;<span class="built_in">GetRealAimPosition</span>();</span><br><span class="line">			RealScreenOffset = <span class="built_in">GetAdaptiveScreenOffset</span>(FollowPosition, AimPosition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> RealScreenOffset = ScreenOffset;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Transform from world space to local space. */</span></span><br><span class="line">		FVector LocalSpaceFollowPosition = <span class="built_in">GetLocalSpacePosition</span>(FollowPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Temporary (before damping) delta position. */</span></span><br><span class="line">		FVector TempDeltaPosition = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** First move the camera along the local space X axis. */</span></span><br><span class="line">		<span class="built_in">SetForwardDelta</span>(LocalSpaceFollowPosition, TempDeltaPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Then move the camera along the local space YZ plane. */</span></span><br><span class="line">		<span class="type">float</span> W = <span class="built_in">SetYZPlaneDelta</span>(LocalSpaceFollowPosition, TempDeltaPosition, RealScreenOffset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Get damped delta position. */</span></span><br><span class="line">		FVector DampedDeltaPosition = <span class="built_in">DampDeltaPosition</span>(LocalSpaceFollowPosition, TempDeltaPosition, DeltaTime, RealScreenOffset, W);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Apply damped delta position. */</span></span><br><span class="line">		<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">AddActorLocalOffset</span>(DampedDeltaPosition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector <span class="title">UFramingFollow::GetRealFollowPosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector ActorLocation = FollowTarget-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">	FRotator ActorRotation = FollowTarget-&gt;<span class="built_in">GetActorRotation</span>();</span><br><span class="line">	FVector LocalOffset = UKismetMathLibrary::<span class="built_in">GreaterGreater_VectorRotator</span>(FollowOffset, ActorRotation);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ActorLocation + LocalOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector2f <span class="title">UFramingFollow::GetAdaptiveScreenOffset</span><span class="params">(<span class="type">const</span> FVector&amp; FollowPosition, <span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector Diff = FollowPosition - AimPosition;</span><br><span class="line">	<span class="type">float</span> ProjectedDistance = FMath::<span class="built_in">Sqrt</span>(FMath::<span class="built_in">Square</span>(Diff.X) + FMath::<span class="built_in">Square</span>(Diff.Y));</span><br><span class="line"></span><br><span class="line">	FVector2f OutRange = <span class="built_in">FVector2f</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	FVector2f RealScreenOffset;</span><br><span class="line">	RealScreenOffset.X = ScreenOffset.X * FMath::<span class="built_in">GetMappedRangeValueClamped</span>(AdaptiveScreenOffsetDistanceX, OutRange, ProjectedDistance);</span><br><span class="line">	RealScreenOffset.Y = ScreenOffset.Y * FMath::<span class="built_in">GetMappedRangeValueClamped</span>(AdaptiveScreenOffsetDistanceY, OutRange, ProjectedDistance);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RealScreenOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector <span class="title">UFramingFollow::GetLocalSpacePosition</span><span class="params">(<span class="type">const</span> FVector&amp; FollowPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector Diff = FollowPosition - <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line"></span><br><span class="line">	FVector ForwardVector = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorForwardVector</span>();</span><br><span class="line">	FVector RightVector = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorRightVector</span>();</span><br><span class="line">	FVector UpVector = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorUpVector</span>();</span><br><span class="line"></span><br><span class="line">	FVector LocalSpaceFollowPosition =</span><br><span class="line">		UKismetMathLibrary::<span class="built_in">MakeVector</span>(ForwardVector.X, RightVector.X, UpVector.X) * Diff.X +</span><br><span class="line">		UKismetMathLibrary::<span class="built_in">MakeVector</span>(ForwardVector.Y, RightVector.Y, UpVector.Y) * Diff.Y +</span><br><span class="line">		UKismetMathLibrary::<span class="built_in">MakeVector</span>(ForwardVector.Z, RightVector.Z, UpVector.Z) * Diff.Z;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> LocalSpaceFollowPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFramingFollow::SetForwardDelta</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, FVector&amp; TempDeltaPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TempDeltaPosition.X = LocalSpaceFollowPosition.X - CameraDistance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">UFramingFollow::SetYZPlaneDelta</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, FVector&amp; TempDeltaPosition, <span class="type">const</span> FVector2f&amp; RealScreenOffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> W = UKismetMathLibrary::<span class="built_in">DegTan</span>(<span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView / <span class="number">2.0f</span>) * CameraDistance * <span class="number">2.0f</span>;</span><br><span class="line">	<span class="type">float</span> ExpectedPositionY = W * RealScreenOffset.X;</span><br><span class="line">	<span class="type">float</span> ExpectedPositionZ = W / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio * RealScreenOffset.Y;</span><br><span class="line"></span><br><span class="line">	TempDeltaPosition.Y = LocalSpaceFollowPosition.Y - ExpectedPositionY;</span><br><span class="line">	TempDeltaPosition.Z = LocalSpaceFollowPosition.Z - ExpectedPositionZ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector <span class="title">UFramingFollow::DampDeltaPosition</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, <span class="type">const</span> FVector&amp; TempDeltaPosition, <span class="type">float</span> DeltaTime, <span class="type">const</span> FVector2f&amp; RealScreenOffset, <span class="type">float</span>&amp; W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector DampedDeltaPosition = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	UMECameraLibrary::<span class="built_in">DamperVectorWithDifferentDampTime</span>(DampMethod, DeltaTime, TempDeltaPosition, FollowDamping, DampedDeltaPosition, DampResidual);</span><br><span class="line">	<span class="built_in">EnsureWithinBounds</span>(LocalSpaceFollowPosition, DampedDeltaPosition, RealScreenOffset, W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DampedDeltaPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFramingFollow::EnsureWithinBounds</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, FVector&amp; DampedDeltaPosition, <span class="type">const</span> FVector2f&amp; RealScreenOffset, <span class="type">float</span>&amp; W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> LeftBound = (RealScreenOffset.X + ScreenOffsetWidth.X) * W;</span><br><span class="line">	<span class="type">float</span> RightBound = (RealScreenOffset.X + ScreenOffsetWidth.Y) * W;</span><br><span class="line">	<span class="type">float</span> BottomBound = (RealScreenOffset.Y + ScreenOffsetHeight.X) * W / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio;</span><br><span class="line">	<span class="type">float</span> TopBound = (RealScreenOffset.Y + ScreenOffsetHeight.Y) * W / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio;</span><br><span class="line"></span><br><span class="line">	FVector ResultLocalSpacePosition = LocalSpaceFollowPosition - DampedDeltaPosition;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Y &lt; LeftBound)   DampedDeltaPosition.Y += ResultLocalSpacePosition.Y - LeftBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Y &gt; RightBound)  DampedDeltaPosition.Y += ResultLocalSpacePosition.Y - RightBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Z &lt; BottomBound) DampedDeltaPosition.Z += ResultLocalSpacePosition.Z - BottomBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Z &gt; TopBound)    DampedDeltaPosition.Z += ResultLocalSpacePosition.Z - TopBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="implementing-targetingaim">Implementing
<code>TargetingAim</code></h2>
<p><code>TargetingAim</code> serves the same function as
<code>Composer</code> in Cinemachine. It only sets the camera rotation
and keeps the aim target at a fixed position on screen. Here is the
implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetingAim::UpdateComponent</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">UpdateComponent</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AimTarget != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/** Get the *real* aim position, based on actor&#x27;s local space. */</span></span><br><span class="line">		FVector AimPosition = <span class="built_in">GetRealAimPosition</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** If camera is too close to aim target, return. */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">CheckIfTooClose</span>(AimPosition)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Temporary delta rotation before damping. */</span></span><br><span class="line">		FRotator TempDeltaRotation = <span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Set delta rotation. */</span></span><br><span class="line">		<span class="built_in">SetDeltaRotation</span>(AimPosition, TempDeltaRotation);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Get damped delta rotation. */</span></span><br><span class="line">		FRotator DampedDeltaRotation = <span class="built_in">DampDeltaRotation</span>(TempDeltaRotation, DeltaTime, AimPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Apply damped delta rotation. */</span></span><br><span class="line">        <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">AddActorLocalRotation</span>(<span class="built_in">FRotator</span>(DampedDeltaRotation.Pitch, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">AddActorWorldRotation</span>(<span class="built_in">FRotator</span>(<span class="number">0</span>, DampedDeltaRotation.Yaw, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UTargetingAim::CheckIfTooClose</span><span class="params">(<span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> Distance = UKismetMathLibrary::<span class="built_in">Vector_Distance</span>(<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>(), AimPosition);</span><br><span class="line">	<span class="keyword">return</span> UKismetMathLibrary::<span class="built_in">NearlyEqual_FloatFloat</span>(Distance, <span class="number">0</span>, <span class="number">0.001</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetingAim::SetDeltaRotation</span><span class="params">(<span class="type">const</span> FVector&amp; AimPosition, FRotator&amp; TempDeltaRotation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRotator CenteredDeltaRotation = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(UKismetMathLibrary::<span class="built_in">FindLookAtRotation</span>(<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>(), AimPosition), <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorRotation</span>());</span><br><span class="line">    TempDeltaRotation.Yaw = CenteredDeltaRotation.Yaw - ScreenOffset.X * <span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView;</span><br><span class="line">    TempDeltaRotation.Pitch = CenteredDeltaRotation.Pitch - ScreenOffset.Y * <span class="number">2.0f</span> * UKismetMathLibrary::<span class="built_in">DegAtan</span>(UKismetMathLibrary::<span class="built_in">DegTan</span>(<span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView / <span class="number">2</span>) / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio);</span><br><span class="line">    TempDeltaRotation.Roll = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FRotator <span class="title">UTargetingAim::DampDeltaRotation</span><span class="params">(<span class="type">const</span> FRotator&amp; TempDeltaRotation, <span class="type">float</span> DeltaTime, <span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FRotator DampedDeltaRotation = <span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	UMECameraLibrary::<span class="built_in">DamperRotatorWithDifferentDampTime</span>(DampMethod, DeltaTime, TempDeltaRotation, AimDamping, DampedDeltaRotation, DampResidual);</span><br><span class="line">	<span class="built_in">EnsureWithinBounds</span>(DampedDeltaRotation, AimPosition);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DampedDeltaRotation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetingAim::EnsureWithinBounds</span><span class="params">(FRotator&amp; DampedDeltaRotation, <span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> VFieldOfView = <span class="number">2.0f</span> * UKismetMathLibrary::<span class="built_in">DegAtan</span>(UKismetMathLibrary::<span class="built_in">DegTan</span>(<span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView / <span class="number">2</span>) / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio);</span><br><span class="line">	<span class="type">double</span> LeftBound = (ScreenOffset.X + ScreenOffsetWidth.X) * <span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView;</span><br><span class="line">	<span class="type">double</span> RightBound = (ScreenOffset.X + ScreenOffsetWidth.Y) * <span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView;</span><br><span class="line">	<span class="type">double</span> BottomBound = (ScreenOffset.Y + ScreenOffsetHeight.X) * VFieldOfView;</span><br><span class="line">	<span class="type">double</span> TopBound = (ScreenOffset.Y + ScreenOffsetHeight.Y) * VFieldOfView;</span><br><span class="line"></span><br><span class="line">	FQuat DesiredQuat = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorRotation</span>().<span class="built_in">Quaternion</span>();</span><br><span class="line">	DesiredQuat = <span class="built_in">FQuat</span>(<span class="built_in">FRotator</span>(<span class="number">0</span>, DampedDeltaRotation.Yaw, <span class="number">0</span>)) * DesiredQuat * <span class="built_in">FQuat</span>(<span class="built_in">FRotator</span>(DampedDeltaRotation.Pitch, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	FRotator DesiredRotation = DesiredQuat.<span class="built_in">Rotator</span>();</span><br><span class="line"></span><br><span class="line">	FRotator ResultRotationDiff = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(UKismetMathLibrary::<span class="built_in">FindLookAtRotation</span>(<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>(), AimPosition), DesiredRotation);</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Yaw &lt; LeftBound) DampedDeltaRotation.Yaw += ResultRotationDiff.Yaw - LeftBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Yaw &gt; RightBound) DampedDeltaRotation.Yaw += ResultRotationDiff.Yaw - RightBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Pitch &lt; BottomBound) DampedDeltaRotation.Pitch += ResultRotationDiff.Pitch - BottomBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Pitch &gt; TopBound) DampedDeltaRotation.Pitch += ResultRotationDiff.Pitch - TopBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="use-in-unreal-engine">Use in Unreal Engine</h2>
<p>Use in UE is really simple. What you need to do is:</p>
<ul>
<li>Create a new blueprint class inherited from MECameraBase;</li>
<li>Set up the parameters in the CameraSettingsComponent component,
e.g., set the <code>FollowComponent</code> as <code>FramingFollow</code>
and <code>AimComponent</code> as <code>TargetingAim</code>;</li>
<li>Use the <code>CallCamera</code> node in blueprint to instantiate an
actor of the blueprint class you just created.</li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
        <div class="popular-posts-date">2021-06-07</div>
      <div class="popular-posts-title"><a href="/2021/06/07/08/38/" rel="bookmark">向量绕任意轴旋转的简单推导</a></div>
        <div class="popular-posts-excerpt"><p><p>图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。</p></p></div>
    </li>
    <li class="popular-posts-item">
        <div class="popular-posts-date">2022-03-25</div>
      <div class="popular-posts-title"><a href="/2022/03/25/01/00/" rel="bookmark">四元数与旋转</a></div>
        <div class="popular-posts-excerpt"><p><p>图形学中的旋转（Rotation）非常重要，用欧拉角（Euler
Angle）旋转非常简单，但是却存在 <strong>万向锁（Gimbal Lock）</strong>
的问题；同时，用欧拉角插值也不尽方便。基于四元数（Quaternion）的旋转既解决了万向锁的问题，又能非常便利地插值。本文将从概念出发，对四元数的定义、推导、性质、应用，以及它与欧拉角之间的联系进行介绍。本文主要参考了Krasjet的《四元数与三维旋转》<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>，其他参考内容包括<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a><a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a><a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a><a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a><a href="#fn7" class="footnote-ref"
id="fnref7" role="doc-noteref"><sup>7</sup></a><a href="#fn8"
class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a>。</p></p></div>
    </li>
    <li class="popular-posts-item">
        <div class="popular-posts-date">2022-10-12</div>
      <div class="popular-posts-title"><a href="/2022/10/12/18/39/" rel="bookmark">Bump Mapping, Normal Mapping and Displacement Mapping</a></div>
        <div class="popular-posts-excerpt"><p><p>凹凸贴图（Bump
mapping）是图形学中一种常用的用于改变物体视觉凹凸性的方法，但是网上很多介绍对它的原理和变体都非常模糊，甚至包含一些关键概念的错误。本文将详细介绍凹凸贴图及其变体（Normal
Mapping和Displacement
Mapping）的原理，并在代码上加以实现，以便让读者更好地理解这项技术。</p></p></div>
    </li>
    <li class="popular-posts-item">
        <div class="popular-posts-date">2023-02-09</div>
      <div class="popular-posts-title"><a href="/2023/02/09/23/21/" rel="bookmark">EasyCamera - A Simplified Camera System for You to Create Plentiful Gameplay Camera Movements and Effects</a></div>
    </li>
    <li class="popular-posts-item">
        <div class="popular-posts-date">2022-10-08</div>
      <div class="popular-posts-title"><a href="/2022/10/08/11/01/" rel="bookmark">GAMES101疑难点及作业详解</a></div>
        <div class="popular-posts-excerpt"><p><p>很早之前就想跟着做完GAMES101，但是拖延症一直让我拖到了现在，我决定不再鸽下去！本篇Blog主要记录在GAMES101学习中遇到的疑难问题，整理Bonus
Material，以及详解每一课的作业（含提高题）。如有任何错误、遗漏，欢迎读者指出赐教！</p></p></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>Sulley
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://sulley.cc/2022/12/11/09/16/" title="Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine)">http://sulley.cc/2022/12/11/09/16/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag"># 计算机</a>
              <a href="/tags/UE/" rel="tag"># UE</a>
              <a href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag"># 随笔</a>
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
              <a href="/tags/%E7%9B%B8%E6%9C%BA/" rel="tag"># 相机</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/11/21/16/03/" rel="prev" title="A Brief Note on Version Control and Project Organization">
                  <i class="fa fa-chevron-left"></i> A Brief Note on Version Control and Project Organization
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/02/09/23/21/" rel="next" title="EasyCamera - A Simplified Camera System for You to Create Plentiful Gameplay Camera Movements and Effects">
                  EasyCamera - A Simplified Camera System for You to Create Plentiful Gameplay Camera Movements and Effects <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sulley</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">352k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:20</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":"enable","theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js","integrity":"sha256-7wT34TI0pEBeEFoi4z+vhuSddGh6vUTMWdqJ2SDe2jg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"littlesulley","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
