<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/radahn-medium.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/radahn-medium.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/radahn-small.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-2oysa9iikh">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sulley.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文是《Real-Time Cameras: A Guide for Game Designers and Developers》的阅读笔记，放在此备份供参阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Real-Time Cameras》笔记">
<meta property="og:url" content="http://sulley.cc/2022/05/05/21/40/index.html">
<meta property="og:site_name" content="Sulley">
<meta property="og:description" content="本文是《Real-Time Cameras: A Guide for Game Designers and Developers》的阅读笔记，放在此备份供参阅。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sulley.cc/images/realtime_cameras/1-1.png">
<meta property="og:image" content="http://sulley.cc/images/realtime_cameras/1-2.png">
<meta property="og:image" content="http://sulley.cc/images/realtime_cameras/2-1.png">
<meta property="og:image" content="http://sulley.cc/images/realtime_cameras/3-1.png">
<meta property="article:published_time" content="2022-05-05T13:40:19.000Z">
<meta property="article:modified_time" content="2022-06-25T17:35:17.531Z">
<meta property="article:author" content="Sulley">
<meta property="article:tag" content="随笔">
<meta property="article:tag" content="游戏">
<meta property="article:tag" content="相机">
<meta property="article:tag" content="设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sulley.cc/images/realtime_cameras/1-1.png">


<link rel="canonical" href="http://sulley.cc/2022/05/05/21/40/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://sulley.cc/2022/05/05/21/40/","path":"2022/05/05/21/40/","title":"《Real-Time Cameras》笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《Real-Time Cameras》笔记 | Sulley</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sulley</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Never Betray Yourself.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">19</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">25</span></a></li>
        
            
  <li class="menu-item menu-item-相册"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册</a></li>


      
        <li class="menu-item menu-item-资源"><a href="/resources/" rel="section"><i class="fa fa-book fa-fw"></i>资源</a></li>
        <li class="menu-item menu-item-留言"><a href="/comments/" rel="section"><i class="fa fa-comment fa-fw"></i>留言</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#part-1-core-concepts"><span class="nav-number">1.</span> <span class="nav-text">Part 1: Core Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-1-game-overview"><span class="nav-number">1.1.</span> <span class="nav-text">Chapter 1: Game Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-2-camera-fundamentals"><span class="nav-number">1.2.</span> <span class="nav-text">Chapter 2: Camera
Fundamentals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#real-world-cameras"><span class="nav-number">1.2.1.</span> <span class="nav-text">Real-World Cameras</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-presentation-styles"><span class="nav-number">1.2.2.</span> <span class="nav-text">Camera Presentation Styles</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-behaviors"><span class="nav-number">1.2.3.</span> <span class="nav-text">Camera Behaviors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#view-generation"><span class="nav-number">1.2.4.</span> <span class="nav-text">View Generation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#player-controls"><span class="nav-number">1.2.5.</span> <span class="nav-text">Player Controls</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-3-cinematography"><span class="nav-number">1.3.</span> <span class="nav-text">Chapter 3: Cinematography</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nomenclature"><span class="nav-number">1.3.1.</span> <span class="nav-text">Nomenclature</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamically-generated-moviesreplay-cameras"><span class="nav-number">1.3.2.</span> <span class="nav-text">Dynamically
Generated Movies&#x2F;Replay Cameras</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scripting"><span class="nav-number">1.3.3.</span> <span class="nav-text">Scripting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#editing"><span class="nav-number">1.3.4.</span> <span class="nav-text">Editing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tools"><span class="nav-number">1.3.5.</span> <span class="nav-text">Tools</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#part-2-design-principles"><span class="nav-number">2.</span> <span class="nav-text">Part 2: Design Principles</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-4-camera-design"><span class="nav-number">2.1.</span> <span class="nav-text">Chapter 4: Camera Design</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interactive-2d-camera-systems"><span class="nav-number">2.1.1.</span> <span class="nav-text">Interactive 2D Camera
Systems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cinematic-2d-camera-systems"><span class="nav-number">2.1.2.</span> <span class="nav-text">Cinematic 2D Camera Systems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interactive-3d-camera-systems"><span class="nav-number">2.1.3.</span> <span class="nav-text">Interactive 3D Camera
Systems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cinematic-3d-camera-systems"><span class="nav-number">2.1.4.</span> <span class="nav-text">Cinematic 3D Camera Systems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-camera-systems"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.5D Camera Systems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#display-devices"><span class="nav-number">2.1.6.</span> <span class="nav-text">Display Devices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-design-process"><span class="nav-number">2.1.7.</span> <span class="nav-text">Camera Design process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-design-guidelines"><span class="nav-number">2.1.8.</span> <span class="nav-text">Camera Design Guidelines</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-5-camera-solutions"><span class="nav-number">2.2.</span> <span class="nav-text">Chapter 5: Camera Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#game-genre-camera-solutions"><span class="nav-number">2.2.1.</span> <span class="nav-text">Game Genre Camera Solutions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multi-player-camera-solutions"><span class="nav-number">2.2.2.</span> <span class="nav-text">Multi-Player Camera
Solutions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gamera-scripting"><span class="nav-number">2.3.</span> <span class="nav-text">Gamera Scripting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#what-is-meant-by-scripting"><span class="nav-number">2.3.1.</span> <span class="nav-text">What is Meant by Scripting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#types-of-scripting"><span class="nav-number">2.3.2.</span> <span class="nav-text">Types of Scripting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scripting-languages"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">Scripting languages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#event-messaging"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">Event messaging</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#script-objects"><span class="nav-number">2.3.3.</span> <span class="nav-text">Script Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scriptable-game-hints"><span class="nav-number">2.3.4.</span> <span class="nav-text">Scriptable game hints</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-scripting"><span class="nav-number">2.3.5.</span> <span class="nav-text">Camera Scripting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-scripting-methods"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">Camera scripting methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dcamera-control"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">DCamera control</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scripting-tools"><span class="nav-number">2.3.6.</span> <span class="nav-text">Scripting Tools</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#world-editor-support"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">World editor support</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#communication-between-target-platform-and-development-pc"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">Communication
between target platform and development PC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#messagingevent-logging"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">Messaging&#x2F;event logging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object-properties-debugging"><span class="nav-number">2.3.6.4.</span> <span class="nav-text">Object properties debugging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#replay"><span class="nav-number">2.3.6.5.</span> <span class="nav-text">Replay</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#console-window"><span class="nav-number">2.3.6.6.</span> <span class="nav-text">Console window</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scripting-debugging"><span class="nav-number">2.3.7.</span> <span class="nav-text">Scripting Debugging</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#part-3-camera-engineering"><span class="nav-number">3.</span> <span class="nav-text">Part 3: Camera Engineering</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-7-position-and-orientation"><span class="nav-number">3.1.</span> <span class="nav-text">Chapter 7: Position and
Orientation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#coordinate-schemes"><span class="nav-number">3.1.1.</span> <span class="nav-text">Coordinate Schemes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#desired-position"><span class="nav-number">3.1.2.</span> <span class="nav-text">Desired Position</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#first-person-camera-positioning"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">First person camera
positioning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#third-person-camera-positioning"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">Third person camera
positioning</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#desired-position-determination-methods"><span class="nav-number">3.1.3.</span> <span class="nav-text">Desired Position
Determination Methods</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stationary"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">Stationary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slavedtracking"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">Slaved&#x2F;tracking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#path"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">Path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#surface-constrained"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">Surface constrained</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volume-constrained"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">Volume constrained</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#framing"><span class="nav-number">3.1.3.6.</span> <span class="nav-text">Framing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object-framing-relative"><span class="nav-number">3.1.3.7.</span> <span class="nav-text">Object-framing relative</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#axis-rotationalspindle"><span class="nav-number">3.1.3.8.</span> <span class="nav-text">Axis rotational&#x2F;spindle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#common-position-problems"><span class="nav-number">3.1.4.</span> <span class="nav-text">Common Position Problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orientation"><span class="nav-number">3.1.5.</span> <span class="nav-text">Orientation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#desired-orientation-determination-methods"><span class="nav-number">3.1.6.</span> <span class="nav-text">Desired Orientation
Determination Methods</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constant-orientation"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">Constant orientation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tracking-a-target-object-or-position"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">Tracking a target object
or position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#look-at-offset"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">Look-at offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#locked-look-at-position"><span class="nav-number">3.1.6.4.</span> <span class="nav-text">Locked look-at position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#target-object-position-prediction"><span class="nav-number">3.1.6.5.</span> <span class="nav-text">Target object position
prediction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object-framing"><span class="nav-number">3.1.6.6.</span> <span class="nav-text">Object framing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idle-wandering"><span class="nav-number">3.1.6.7.</span> <span class="nav-text">Idle wandering</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#automated-orientation-control"><span class="nav-number">3.1.6.8.</span> <span class="nav-text">Automated orientation
control</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reorientation-methods"><span class="nav-number">3.1.7.</span> <span class="nav-text">Reorientation Methods</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#applying-rotations"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">Applying rotations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reorientation-lag"><span class="nav-number">3.1.7.2.</span> <span class="nav-text">Reorientation lag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offsets"><span class="nav-number">3.1.7.3.</span> <span class="nav-text">Offsets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smoothing-and-damping"><span class="nav-number">3.1.7.4.</span> <span class="nav-text">Smoothing and damping</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#springs-and-pid-controllers"><span class="nav-number">3.1.7.5.</span> <span class="nav-text">Springs and PID controllers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-look"><span class="nav-number">3.1.8.</span> <span class="nav-text">Free-Look</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#first-person-free-look"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">First person free-look</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#third-person-free-look"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">Third person free-look</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free-look-orientation-determination"><span class="nav-number">3.1.8.3.</span> <span class="nav-text">Free-look orientation
determination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#common-orientation-problems"><span class="nav-number">3.1.8.4.</span> <span class="nav-text">Common orientation problems</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-8-navigation-and-occulusion"><span class="nav-number">3.2.</span> <span class="nav-text">Chapter 8: Navigation and
Occulusion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#the-cemera-as-an-ai-game-object"><span class="nav-number">3.2.1.</span> <span class="nav-text">The Cemera as an AI Game
Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#navigation-techniques"><span class="nav-number">3.2.2.</span> <span class="nav-text">Navigation Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-navigation-techniques"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">Dynamic navigation
techniques</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pre-defined-navigation-techniques"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">Pre-defined navigation
techniques</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#occulision"><span class="nav-number">3.2.3.</span> <span class="nav-text">Occulision</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#occulusion-determination"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">Occulusion determination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#occulusion-prediction-methodologies"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">Occulusion prediction
methodologies</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#line-of-sight"><span class="nav-number">3.2.4.</span> <span class="nav-text">Line of Sight</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#resolving-line-of-sight-problems"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">Resolving line of sight
problems</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#path-generation"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">Path generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avoiding-loss-of-los"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">Avoiding loss of LOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-safes"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">Fail-safes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-9-motion-and-collision"><span class="nav-number">3.3.</span> <span class="nav-text">Chapter 9: Motion and
Collision</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-movement-sequence"><span class="nav-number">3.3.1.</span> <span class="nav-text">Camera Movement Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#character-motion"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">Character motion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#movement-methods"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">Movement methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smoothing-and-damping-techniques"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">Smoothing and damping
techniques</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#motion-constraints"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">Motion constraints</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#player-camera-control"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">Player camera control</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-position-control-schemes"><span class="nav-number">3.3.1.6.</span> <span class="nav-text">Camera position control
schemes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#manipulation-of-camera-orientation"><span class="nav-number">3.3.1.7.</span> <span class="nav-text">Manipulation of camera
orientation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#automated-camera-positioning-and-orientation"><span class="nav-number">3.3.1.8.</span> <span class="nav-text">Automated camera
positioning and orientation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#debug-camera-control"><span class="nav-number">3.3.1.9.</span> <span class="nav-text">Debug camera control</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-collisions"><span class="nav-number">3.3.2.</span> <span class="nav-text">Camera Collisions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#the-importance-of-camera-collisions"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">The importance of camera
collisions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collision-determination"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">Collision determination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collision-geometry-design"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">Collision geometry design</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collision-resolution"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">Collision resolution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#disabling-collision-detection"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">Disabling collision
detection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#avoiding-camera-collisions"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">Avoiding camera collisions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-10-camera-mathematics"><span class="nav-number">3.4.</span> <span class="nav-text">Chapter 10: Camera
Mathematics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#common-mathematical-techniques"><span class="nav-number">3.4.1.</span> <span class="nav-text">Common Mathematical
Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#look-at"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">Look-at</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#roll-removal"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">Roll removal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#twist-reduction"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">Twist reduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#world-space-to-screen-space-conversion"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">World space to screen
space conversion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#screen-space-to-cameraworld-space-conversion"><span class="nav-number">3.4.1.5.</span> <span class="nav-text">Screen space to
camera&#x2F;world space conversion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fov-conversion"><span class="nav-number">3.4.1.6.</span> <span class="nav-text">FOV conversion</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quaternions"><span class="nav-number">3.4.2.</span> <span class="nav-text">Quaternions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bump-and-ease-functions"><span class="nav-number">3.4.3.</span> <span class="nav-text">Bump and Ease Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exponentials"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">Exponentials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proportional"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">Proportional</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spherical-linear-interpolation"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">Spherical linear
interpolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transcendentals"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">Transcendentals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springs"><span class="nav-number">3.4.4.</span> <span class="nav-text">Springs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#digital-filters"><span class="nav-number">3.4.5.</span> <span class="nav-text">Digital Filters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#low-pass"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">Low pass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#high-pass"><span class="nav-number">3.4.5.2.</span> <span class="nav-text">High pass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#band"><span class="nav-number">3.4.5.3.</span> <span class="nav-text">Band</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finite-impulse-response"><span class="nav-number">3.4.5.4.</span> <span class="nav-text">Finite impulse response</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#infinite-impulse-response"><span class="nav-number">3.4.5.5.</span> <span class="nav-text">Infinite impulse response</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spline-curves"><span class="nav-number">3.4.6.</span> <span class="nav-text">Spline Curves</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-spline-usage"><span class="nav-number">3.4.6.1.</span> <span class="nav-text">Camera spline usage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cubic-polynomials"><span class="nav-number">3.4.6.2.</span> <span class="nav-text">Cubic polynomials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spline-types"><span class="nav-number">3.4.6.3.</span> <span class="nav-text">Spline types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#continuity"><span class="nav-number">3.4.6.4.</span> <span class="nav-text">Continuity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spline-definitions"><span class="nav-number">3.4.6.5.</span> <span class="nav-text">Spline definitions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spline-evaluation"><span class="nav-number">3.4.6.6.</span> <span class="nav-text">Spline evaluation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#control-point-generation"><span class="nav-number">3.4.6.7.</span> <span class="nav-text">Control point generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parameterized-arc-length"><span class="nav-number">3.4.6.8.</span> <span class="nav-text">Parameterized arc length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#total-spline-length"><span class="nav-number">3.4.6.9.</span> <span class="nav-text">Total spline length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#closest-position"><span class="nav-number">3.4.6.10.</span> <span class="nav-text">Closest position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spline-editing"><span class="nav-number">3.4.6.11.</span> <span class="nav-text">Spline editing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interpolation"><span class="nav-number">3.4.7.</span> <span class="nav-text">Interpolation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-property-interpolation"><span class="nav-number">3.4.8.</span> <span class="nav-text">Camera Property
Interpolation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#position-interpolation"><span class="nav-number">3.4.8.1.</span> <span class="nav-text">Position interpolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#orientation-interpolation"><span class="nav-number">3.4.8.2.</span> <span class="nav-text">Orientation interpolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fov-interpolation"><span class="nav-number">3.4.8.3.</span> <span class="nav-text">FOV interpolation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#viewport-interpolation"><span class="nav-number">3.4.9.</span> <span class="nav-text">Viewport Interpolation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#player-control-interpolation"><span class="nav-number">3.4.10.</span> <span class="nav-text">Player Control Interpolation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#first-person-cameras"><span class="nav-number">3.4.10.1.</span> <span class="nav-text">First person cameras</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#third-person-cameras"><span class="nav-number">3.4.10.2.</span> <span class="nav-text">Third person cameras</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interpolation-choices"><span class="nav-number">3.4.11.</span> <span class="nav-text">Interpolation Choices</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linear-interpolation"><span class="nav-number">3.4.11.1.</span> <span class="nav-text">Linear interpolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#piecewise-interpolation"><span class="nav-number">3.4.11.2.</span> <span class="nav-text">Piecewise interpolation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#methods-of-interpolation"><span class="nav-number">3.4.12.</span> <span class="nav-text">Methods of Interpolation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linear-time-interpolation"><span class="nav-number">3.4.12.1.</span> <span class="nav-text">Linear time interpolation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parametric-functions"><span class="nav-number">3.4.12.2.</span> <span class="nav-text">Parametric functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spherical-linear-interpolation-1"><span class="nav-number">3.4.12.3.</span> <span class="nav-text">Spherical linear
interpolation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#potential-interpolation-problems"><span class="nav-number">3.4.13.</span> <span class="nav-text">Potential Interpolation
Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aesthetic-problems"><span class="nav-number">3.4.13.1.</span> <span class="nav-text">Aesthetic problems</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mathematical-problems"><span class="nav-number">3.4.13.2.</span> <span class="nav-text">Mathematical problems</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interruption-of-interpolation"><span class="nav-number">3.4.14.</span> <span class="nav-text">Interruption of
Interpolation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transitions"><span class="nav-number">3.4.15.</span> <span class="nav-text">Transitions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#position-during-transitions"><span class="nav-number">3.4.15.1.</span> <span class="nav-text">Position during transitions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#orientation-during-transitions"><span class="nav-number">3.4.15.2.</span> <span class="nav-text">Orientation during
transitions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-math-problems"><span class="nav-number">3.4.16.</span> <span class="nav-text">Camera Math Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#floating-point-precision"><span class="nav-number">3.4.16.1.</span> <span class="nav-text">Floating-point precision</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epsilon-usage"><span class="nav-number">3.4.16.2.</span> <span class="nav-text">Epsilon usage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compiler-differences"><span class="nav-number">3.4.16.3.</span> <span class="nav-text">Compiler differences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hardware-fpu-differences"><span class="nav-number">3.4.16.4.</span> <span class="nav-text">Hardware FPU differences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector-normalization"><span class="nav-number">3.4.16.5.</span> <span class="nav-text">Vector normalization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#matrix-concatenation-floating-point-drift"><span class="nav-number">3.4.16.6.</span> <span class="nav-text">Matrix concatenation
floating-point drift</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#periodic-camera-mathematical-fixes"><span class="nav-number">3.4.17.</span> <span class="nav-text">Periodic Camera Mathematical
Fixes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-11-implementation"><span class="nav-number">3.5.</span> <span class="nav-text">Chapter 11: Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#game-engine-architecture"><span class="nav-number">3.5.1.</span> <span class="nav-text">Game Engine Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#game-update-loop"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">Game update loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#game-system-managers"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">Game system managers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delta-time"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">Delta time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-processing"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">Input processing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-system-architecture"><span class="nav-number">3.5.2.</span> <span class="nav-text">Camera System Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#viewport-manager"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">Viewport manager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#render-manager"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">Render manager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-manager"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">Camera manager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-update-loop"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">Camera update loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hint-manager"><span class="nav-number">3.5.2.5.</span> <span class="nav-text">Hint manager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shake-manager"><span class="nav-number">3.5.2.6.</span> <span class="nav-text">Shake manager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#game-cameras"><span class="nav-number">3.5.3.</span> <span class="nav-text">Game Cameras</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#inherited-camera-behaviors"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">Inherited camera behaviors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#component-based-camera-behaviors"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">Component-based camera
behaviors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cinematic-cameras"><span class="nav-number">3.5.3.3.</span> <span class="nav-text">Cinematic cameras</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#debug-camera"><span class="nav-number">3.5.3.4.</span> <span class="nav-text">Debug camera</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scripting-system-implementation"><span class="nav-number">3.5.4.</span> <span class="nav-text">Scripting System
Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-script-objects"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">Camera script objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ordering-of-scripting-logic"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">Ordering of scripting logic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#messaging"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">Messaging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prioritization"><span class="nav-number">3.5.4.4.</span> <span class="nav-text">Prioritization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interpolation-1"><span class="nav-number">3.5.4.5.</span> <span class="nav-text">Interpolation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#performance-considerations"><span class="nav-number">3.5.5.</span> <span class="nav-text">Performance Considerations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#amortization"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">Amortization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preprocessing"><span class="nav-number">3.5.5.2.</span> <span class="nav-text">Preprocessing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tools-support"><span class="nav-number">3.5.6.</span> <span class="nav-text">Tools Support</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#world-editor"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">World editor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#camera-collision-mesh"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">Camera collision mesh</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#camera-debugging-techniques"><span class="nav-number">3.5.7.</span> <span class="nav-text">Camera Debugging Techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interactive-debugging"><span class="nav-number">3.5.7.1.</span> <span class="nav-text">Interactive debugging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data-logging"><span class="nav-number">3.5.7.2.</span> <span class="nav-text">Data logging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#game-replaying"><span class="nav-number">3.5.7.3.</span> <span class="nav-text">Game replaying</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sulley"
      src="/images/radahn-avatar.png">
  <p class="site-author-name" itemprop="name">Sulley</p>
  <div class="site-description" itemprop="description">珍惜眼前人</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/littlesulley" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;littlesulley" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qinghonghan97@gmail.com" title="E-Mail → mailto:qinghonghan97@gmail.com" rel="noopener" target="_blank"><i class="fa-solid fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/1631723" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;1631723" rel="noopener" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/beingaway/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;beingaway&#x2F;" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/han-qing-hong-33" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;han-qing-hong-33" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kungtalon.github.io/" title="https:&#x2F;&#x2F;kungtalon.github.io&#x2F;" rel="noopener" target="_blank">Kungtalon</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kaesenudeln.github.io/" title="https:&#x2F;&#x2F;kaesenudeln.github.io&#x2F;" rel="noopener" target="_blank">Zecx</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sulley.cc/2022/05/05/21/40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/radahn-avatar.png">
      <meta itemprop="name" content="Sulley">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sulley">
      <meta itemprop="description" content="珍惜眼前人">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《Real-Time Cameras》笔记 | Sulley">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Real-Time Cameras》笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-05 21:40:19" itemprop="dateCreated datePublished" datetime="2022-05-05T21:40:19+08:00">2022-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-26 01:35:17" itemprop="dateModified" datetime="2022-06-26T01:35:17+08:00">2022-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F-%E6%B8%B8%E6%88%8F%E7%90%86%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">游戏 - 游戏理论</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/05/05/21/40/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/05/05/21/40/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>56k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>51 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本文是《Real-Time Cameras: A Guide for Game Designers and
Developers》的阅读笔记，放在此备份供参阅。</p>
<span id="more"></span>
<h1 id="part-1-core-concepts">Part 1: Core Concepts</h1>
<ul>
<li>第一章：介绍了游戏应用与其中的相机系统。</li>
<li>第二章：讲述游戏相机的基础概念与发展。</li>
<li>第三章：介绍电影摄影的基础知识与应用。</li>
</ul>
<h2 id="chapter-1-game-overview">Chapter 1: Game Overview</h2>
<p>一个典型的游戏引擎（Game Engine）应当包括：</p>
<ul>
<li>资源管理系统（Resource Management）</li>
<li>玩家控制（Player Control）</li>
<li>物理模拟（Physics Simulation）</li>
<li>游戏对象逻辑（Game Object Logic）</li>
<li>图形用户界面（Graphical User Interface）</li>
<li>相机与视口管理（Camera and Viewport Management）</li>
<li>网络交流（Network Communication）</li>
<li>人工智能（AI）</li>
<li>游戏事件管理（Game Event Management）</li>
<li>渲染（Rendering）</li>
<li>对象间交流（Inter-Object Communication）<br />
</li>
<li>音频（Audio）</li>
<li>任务管理（Task Management）</li>
<li>……</li>
</ul>
<figure>
<img data-src="/images/realtime_cameras/1-1.png"
alt="游戏各系统之间的联系。" />
<figcaption aria-hidden="true">游戏各系统之间的联系。</figcaption>
</figure>
<p>游戏的每个系统都有相对固定的更新顺序，如下图所示：</p>
<figure>
<img data-src="/images/realtime_cameras/1-2.png"
alt="游戏各系统的更新顺序。" />
<figcaption aria-hidden="true">游戏各系统的更新顺序。</figcaption>
</figure>
<p>对于每个步骤的介绍如下：</p>
<ul>
<li><strong>Input</strong>：通常是每帧更新一次，但一些游戏也会每帧更新若干次，从而精准反应玩家输入。</li>
<li><strong>Think</strong>：大部分游戏逻辑得到更新，包括玩家输入、AI、游戏事件生成等。</li>
<li><strong>Move</strong>：更新物理模拟、碰撞检测等内容。</li>
<li><strong>Messaging</strong>：用于在游戏对象、游戏系统之间传递信息，比如新游戏对象的激活、开门、敌人死亡、资源加载完成、动画事件、碰撞等等。Messaging并不是一定会在Update
Loop中出现，可能会在消息发出的瞬间被处理，或者延迟处理。Messaging系统有利于不同系统之间的解耦，简化游戏录像逻辑。Messaging本质上是一种保证不同时间点游戏事件同步的技术。</li>
<li><strong>Camera</strong>：主要包含以下步骤：
<ul>
<li>移除无用的camera</li>
<li>激活需要的camera</li>
<li>决定哪个camera用于渲染</li>
<li>更新当前激活的相机</li>
<li>更新主相机</li>
<li>基于主相机更新玩家control reference frame</li>
<li>构建transformation matrices用于渲染，包括特效如shaking, FOV等</li>
</ul></li>
<li><strong>Post-Camera</strong>：更新依赖于相机的物体</li>
<li><strong>Render</strong>：有时候一个camera view也会被用于另一个camera
view的生成过程中</li>
</ul>
<p><strong>对于相机而言，Occam's
Razor法则适用：最简单的相机解决方案通常是最好的。</strong></p>
<p>相机系统的作用包括：</p>
<ul>
<li>管理活跃相机，保证其逻辑正常</li>
<li>控制相机增删</li>
<li>支持相机参数动态调整</li>
<li>为玩家操控提供参考帧（reference frames）</li>
<li>处理所有非交互式电影片段</li>
<li>管理并更新视口</li>
<li>获取frustum信息以展示view</li>
<li>提供可选的debug能力</li>
</ul>
<p>角色控制与角色移动之间的关系被称为<strong>控制参考帧（control
reference frame）</strong>。</p>
<h2 id="chapter-2-camera-fundamentals">Chapter 2: Camera
Fundamentals</h2>
<h3 id="real-world-cameras">Real-World Cameras</h3>
<p>真实世界的相机大概包含以下关键要素：</p>
<ul>
<li>Lens type</li>
<li>Capture method</li>
<li>Film stock</li>
<li>Capture rate</li>
<li>Exposure of film</li>
<li>Projection method</li>
<li>Aspect ratio</li>
</ul>
<p>真实世界相机的一些特点：</p>
<ul>
<li>缺乏交互性</li>
<li>预先决定的机位</li>
<li>相机镜头</li>
<li>场景切换</li>
<li>胶片曝光</li>
<li>后处理特效</li>
</ul>
<p>游戏相机的一些特点：</p>
<ul>
<li>模拟真实世界相机的功能</li>
<li>不需要相机实体</li>
<li>动态变化</li>
<li>允许游戏世界的不同投影</li>
<li>可变的光照与渲染</li>
<li>更多样的转场</li>
<li>允许特殊效果</li>
</ul>
<p>一些专有名词：</p>
<ul>
<li>Game system:
管理相机、应用相机、控制相机行为、生成用于渲染的信息、控制参考帧</li>
<li>Game camera: 抽象的游戏实体</li>
<li>Presentation style: 指将游戏世界投影到屏幕空间的方法</li>
<li>Camera behavior: 一人称/三人称相机，影院式/交互式相机</li>
<li>Look-at position: 相机朝向的位置</li>
<li>Desired position: 相机移动的位置</li>
<li>Orientation: 相机朝向</li>
<li>Desired orientation: 相机的目标朝向</li>
<li>Rotation: 朝向的变化量</li>
<li>View frustum: 游戏世界的可视空间</li>
<li>Viewport: 呈现在显示设备上的一种数据结构</li>
<li>Field of view: View frustum的上下/左右边界的夹角</li>
<li>Aspect ratio: 长宽比，对于standard definition television
(SDTV)来说，是4:3，对high-definition television
(HDTV)是16:9。对电影投影中使用最多的是1.85 (CinemaScope)和2.35
(anamorphic)</li>
<li>Refresh or frame rate: 刷新率</li>
<li>Refresh and motion blur:
刷新模糊指显示设备刷新率不能与计算机的输出同步，运动模糊是因为物体运动快于曝光时间</li>
<li>Display tearing: 显示撕裂</li>
<li>Player character： 玩家在游戏中控制的物体</li>
<li>Target object: 被看向的物体</li>
<li>Interpolation: 插值</li>
<li>Projection: 投影</li>
<li>Parallax: 视差</li>
<li>Transitions:
转场，包括过程化转换、插值、瞬时切换、清除、过渡等等</li>
<li>Camera constraints: 相机约束</li>
<li>Motion constraints:
运动约束，如距离、相对位置、路径、速度、加速度等等</li>
<li>Orientation constraints: 通常用于第一人称相机</li>
</ul>
<h3 id="camera-presentation-styles">Camera Presentation Styles</h3>
<p>Presentation style
通常被划分为正交（2D）或者透视（3D）渲染，有时也会使用2.5D</p>
<h3 id="camera-behaviors">Camera Behaviors</h3>
<p>主要有三种相机行为：</p>
<ul>
<li>Cinematic cameras:
非交互的、玩家不可控的相机，包括cutscene和real-time cinematic
sequences</li>
<li>First person cameras:
视野比TP游戏小，使玩家难以全面捕捉空间与环境信息，跳跃也更加困难。在实现FP相机时，建议把相机与任务的头部分开，同时使相机的朝向独立于玩家的朝向</li>
<li>Third person cameras:
允许更大的视野，适用于环境导向型游戏，但存在world navigation与collision
avoidance两个问题</li>
</ul>
<p>此外，相机也可以分为predictive和reactive两类： - Reactive:
根据游戏对象的变化而变化 - Predictive:
根据当前游戏物体预测最佳的相机位置和朝向</p>
<p>Path finding solutions: -
全局路径搜索：搜索环境中的一条路径，能够保持美学质量 -
局部路径搜索：以某种具体的物体类型为核心进行搜索 -
基于目标的搜索：在各种约束下搜索路径</p>
<h3 id="view-generation">View Generation</h3>
<p>视图生成步骤：</p>
<ul>
<li>游戏中每个活跃的物体更新内部状态</li>
<li>相机更新位置、朝向等信息</li>
<li>对游戏中待生成的每个view:
<ul>
<li>决定相机的位置和朝向</li>
<li>决定显示设备上的viewport</li>
<li>决定游戏世界中的frustum</li>
<li>给定frustum，决定哪些物体被剔除</li>
<li>对每个待渲染的物体：
<ul>
<li>变换物体</li>
<li>应用光照着色</li>
<li>2D投影</li>
<li>光栅化</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img data-src="/images/realtime_cameras/2-1.png" alt="简化的渲染流程。" />
<figcaption aria-hidden="true">简化的渲染流程。</figcaption>
</figure>
<p>在上述步骤中，与相机系统直接相关的有：view frustum, view
transform和projection transform</p>
<h3 id="player-controls">Player Controls</h3>
<p>A control reference frame refers to a relationship between changes to
the controller input and how it affects movement or other aspects of
player control.</p>
<p>在FP游戏中，control reference
frame直接对应了玩家角色面朝的方向，且通常只能绕up
axis旋转。在TP游戏中，control reference
frame基于相机与玩家的相对位置。</p>
<p>Control reference frame需要始终反应<strong>玩家的意图</strong>！</p>
<h2 id="chapter-3-cinematography">Chapter 3: Cinematography</h2>
<h3 id="nomenclature">Nomenclature</h3>
<p>电影学中的一些专有名词：</p>
<ul>
<li>Dolly: 指平行于地面的移动，dollying in是向前推进，dollying
out是向后推进，crab left是向左移动，crab right是向右移动</li>
<li>Pan/Yaw: 绕着camera up轴的旋转</li>
<li>Tilt/Pitch: 绕着camera right轴的旋转</li>
<li>Tracking: 跟着物体移动</li>
<li>Depth of field: 景深</li>
<li>Color fade: 颜色渐变</li>
<li>Lens flare: 镜头眩光</li>
<li>Cut-away shot: 切换到另一个镜头用于强调原场景中的某个元素</li>
<li>Insert shot: 切换到场景中的细节部分，比如人物特写</li>
<li>Jump cut: 瞬间切换</li>
<li>180 degree rule/line of action: 二人镜头应该让相机保持在同一侧</li>
<li>Point of view shot: 第一视角镜头</li>
<li>Crane shot: 第三人称视角</li>
<li>Reaction shot: 拍摄人物反应的镜头</li>
<li>Reverse shot: 与前一个镜头角度相反，但仍遵循180度法则</li>
<li>30 degree rule: 当使用jump
cut时，新镜头与上个镜头的角度差应该大于30度，否则会让观众认为是场景的物体发生了移动而非相机</li>
<li>Forced perspective:
强制透视指一系列技术让观众产生错误的视觉效果，如大小、位置关系</li>
</ul>
<h3 id="dynamically-generated-moviesreplay-cameras">Dynamically
Generated Movies/Replay Cameras</h3>
<p>为了实现回放，可以记录初始游戏状态和玩家操作，然后模拟行为。一些回放系统还支持观测者视角。</p>
<p>有三种形式的回放相机：reproduction, scripted, dynamically
generated:</p>
<ul>
<li>Reproduction cameras/keyframed cameras:
在固定的时间间隔记录位置和朝向信息，实现简单但可能依赖于其他非keyframed游戏事件</li>
<li>Scripted cameras:
是可交互与预定义的结合。Replay相机的位置可以采用下述的形式：
<ul>
<li>Discrete camera behaviors: 此类相机perform jump
cuts或者预定义相机位置之间的插值</li>
<li>Path-based motion: 使用设计师预定义的相机路径</li>
<li>Slaved motion: 根据特定物体设置相机位置
类似地，相机的朝向（甚至FOV）可以采用如下的形式：</li>
<li>Fixed orientations: 固定朝向</li>
<li>Pre-defined orientations: 预定义朝向</li>
<li>Object tracking: 跟踪游戏物体调整朝向</li>
<li>Object framing:
保证游戏物体保持与显示设备一致的相对距离，此时物体的显示大小可以通过改变FOV调整</li>
</ul></li>
<li>Dynamically generated cameras:
在回放的时候动态生成相机，如死亡视角、高亮操作等等
<ul>
<li>死亡视角相机：可以通过一个围绕角色的stationary相机实现，或者使用一些预定义的相机位置/朝向</li>
<li>重生相机：当玩家进入/重进游戏时播放的相机</li>
</ul></li>
</ul>
<p>一些常用的相机特效：</p>
<ul>
<li>Reorientation changes:
引入朝向误差，模拟人类持相机的行为，但要注意摇晃的幅度</li>
<li>Camera shake:
相机抖动通常在渲染过程中实现而非游戏世界中，因为这不会改变相机的实际位置，注意在第三人称游戏中应当控制相机抖动的幅度和频率</li>
<li>Roll: 用于营造失控的感觉，比如用在赛车游戏中</li>
<li>FOV/DOF: 注意DOF不要频繁使用</li>
</ul>
<h3 id="scripting">Scripting</h3>
<p>Scripting通常指设计师手动指定相机的位置和朝向，要么在编辑器中进行编辑，要么使用Maya等工具编辑后直接导入</p>
<p>一个典型的scripting system应当包括：</p>
<ul>
<li>调整相机位置和朝向</li>
<li>转场</li>
<li>相机插值</li>
<li>FOV变化</li>
</ul>
<p>Scripting system最好还支持编辑时预览，尽管非常困难</p>
<h3 id="editing">Editing</h3>
<p>编辑就是把所有的shot重新组织、拼接的过程，主要包含以下内容：</p>
<ul>
<li>Shot selection: 镜头选择</li>
<li>Framing/composition:
电影业通常对镜头的摆放有非常具体的标准以达到特定的情感效果，即使镜头离物体的距离固定，物体在屏幕中的位置也会极大影响呈现的效果，通常遵循三分法则（rule
of thirds）</li>
<li>Transitions: 有几种常见的转场方式：
<ul>
<li>Jump cut: 遵循30度法则</li>
<li>Cross fade or dissolve: 此类转场可以降低渲染性能要求</li>
<li>Iris transition: 以屏幕一点为圆心向四周展开</li>
<li>Wipe(s): 擦拭转场</li>
<li>Viewport transitions: 视口转场</li>
</ul></li>
</ul>
<figure>
<img data-src="/images/realtime_cameras/3-1.png"
alt="Rule of thirds示意。" />
<figcaption aria-hidden="true">Rule of thirds示意。</figcaption>
</figure>
<h3 id="tools">Tools</h3>
<p>如果电影镜头使用游戏引擎进行渲染，即用常规游戏环境制作镜头，则最好让编辑器支持直接控制cinematic
sequences，包括：</p>
<ul>
<li>直接对相机位置和朝向的控制</li>
<li>通过另一个物体控制相机</li>
<li>控制相机之间变化</li>
<li>通过相机触发游戏事件</li>
<li>镜头的转场</li>
<li>控制FOV</li>
<li>即时预览</li>
<li>额外的编辑和debug工具</li>
</ul>
<p>上述属性都可以通过一条曲线完成（类似Unity），横坐标是elapsed
time，纵坐标是具体值</p>
<h1 id="part-2-design-principles">Part 2: Design Principles</h1>
<h2 id="chapter-4-camera-design">Chapter 4: Camera Design</h2>
<h3 id="interactive-2d-camera-systems">Interactive 2D Camera
Systems</h3>
<p>2D游戏通常使用tile
map，每个tile都是一个小图片，且使用hash存储，因此极大节省内存</p>
<p>2D相机的主要功能之一是让角色一直位于屏幕可视范围，比如可以使用scrolling，即让背景做相对运动。下面是一些常见的scrolling类型：</p>
<ul>
<li>Continuous: 背景的scrolling随着游戏连续进行</li>
<li>Character-relative: 相机的运动与角色的运动同步</li>
<li>Directional lag: 期望的相机位置基于角色运动的方向</li>
<li>Burst: 期望的相机位置只有当角色到达某个位置或距离时才变化</li>
<li>Screen-relative: 只有在角色超出预定义的边界时相机才开始移动</li>
<li>Region-based: 当角色超过相对于世界的边界时相机才开始移动</li>
</ul>
<p>有时候相机的位置要独立于角色位置。对共用一个viewport的多人游戏来说，所有角色的位置共同决定了相机的位置。解决方案：</p>
<ul>
<li>允许相机zoom out</li>
<li>限制玩家移动</li>
<li>分屏</li>
<li>允许玩家在屏幕外移动</li>
<li>传送玩家</li>
</ul>
<h3 id="cinematic-2d-camera-systems">Cinematic 2D Camera Systems</h3>
<p>2D cinamatic camera system的一些典型特征包括：</p>
<ul>
<li>Viewport panning control: 控制运动路径</li>
<li>Zoom in/out: 放大缩小</li>
<li>Object tracking: 目标跟踪</li>
<li>Keep an object within screen bounds or other arbitrary
viewport-based constraint: 带有限制的移动</li>
</ul>
<h3 id="interactive-3d-camera-systems">Interactive 3D Camera
Systems</h3>
<p>交互式3D相机系统的难点在于提供一个上下文合适的视角，包括艺术性与游戏性，特征包括：</p>
<ul>
<li>渲染投影类型（透视、正交）</li>
<li>决定相机期望位置（navigation）</li>
<li>相机移动的方式</li>
<li>决定相机期望朝向</li>
<li>相机旋转的方式</li>
<li>相机其他属性的动态改变（FOV, etc）</li>
<li>相机插值</li>
<li>Fail-safe handling</li>
<li>多视口/分屏</li>
</ul>
<h3 id="cinematic-3d-camera-systems">Cinematic 3D Camera Systems</h3>
<p>当设计3D cinematic camera system的时候有几个有用的建议：</p>
<ul>
<li>Duplicate controls and functionality from modeling packages:
复用现有建模包中的功能，让艺术家能够用得舒服、更有效率</li>
<li>Develop a common terminology: 尽可能用标准的专业术语</li>
<li>Consider pre-rendering cinematic sequences:
用游戏引擎渲染sequence</li>
<li>Distinguish non-interactive sequences from regular game play:
要让玩家意识到在播放cinematic
sequences时不能再操纵角色了，比如调整aspect ratio</li>
<li>Allow an early out after viewing scene once:
让观众有机会跳过cinematic sequence</li>
</ul>
<h3 id="d-camera-systems">2.5D Camera Systems</h3>
<p>2.5D相机系统有自身的优势，比如让游戏玩家更容易理解和接受游戏</p>
<h3 id="display-devices">Display Devices</h3>
<p>让游戏分辨率适应显示分辨率的方法：</p>
<ul>
<li>Resize: 通过render buffer和viewport匹配显示设备的分辨率</li>
<li>Pan and scan: 裁剪</li>
<li>Stretch: 伸缩</li>
</ul>
<h3 id="camera-design-process">Camera Design process</h3>
<p>首先，游戏的整体体验/玩法需要制定下来，然后再制定相机的宏观设计框架。相机设计的总体流程是：</p>
<ul>
<li>Examine high-level design goals:
明确在游戏的不同部分相机有何相同之处，是否需要单个representation
style，玩家有怎样的体验</li>
<li>Evaluate player character abilities:
玩家怎么移动、怎么与环境交互</li>
<li>Determine scope of environments:
游戏场景是怎样的，要提前根据场景做camera prototyping</li>
<li>Define base camera behaviors: 尽快确定相机的基础功能</li>
<li>Determine area-specific requirements: 明确特殊区域</li>
<li>Technical evaluation of cameras:
关注处理器开销、内存开销、脚本能力、Debug能力</li>
</ul>
<p>在相机设计的时候可以问一些问题，这有助于我们更好地设计：</p>
<ul>
<li>Player abilities and controls
<ul>
<li>角色怎么移动的？加速度是什么？是否能跳/飞？</li>
<li>角色的移动能力是否最终确定了？</li>
<li>相机与玩家的关系是怎样的？</li>
<li>是否应该保持与玩家朝向相对固定的朝向？</li>
<li>玩家想要看到什么？</li>
<li>相机应该关注角色还是角色前的某个点？</li>
<li>是否有必须可视的部分？</li>
<li>除了角色之外是否还有其他物体必须可视？</li>
<li>相机的朝向是否需要改变？</li>
<li>玩家角色怎样被控制？</li>
</ul></li>
<li>Environmental concerns: 场景设计应该围绕玩法和相机限制
<ul>
<li>角色在怎样的场景中移动？开放还是封闭，宽敞还是狭窄？</li>
<li>场景是否影响相机的位置和朝向？</li>
<li>相机是否应该被放在场景外？如是，如果在常规玩法中切换？</li>
<li>相机是否会在动态变化的场景中跟随玩家？受到阻挡怎么办？</li>
<li>相机是否应当避免复杂物体？</li>
<li>相机是否应当限制在具体的路径或表面？</li>
<li>哪种presentation style更好？</li>
<li>在场景中相机插值是否还生效？</li>
<li>是否有必要给相机加上特定的碰撞体？</li>
</ul></li>
<li>Technical concerns
<ul>
<li>是否有技术限制？包括渲染性能问题等</li>
<li>如果相机会穿透物体，是否支持透明化？</li>
<li>是否需要fail-safes以处理未预料的意外情况，比如关门？</li>
<li>是否允许操纵相机？</li>
<li>场景是否可能遮挡玩家而无法解决？此时场景是否需要进行改变？</li>
<li>是否支持相机插值？如何避免插值间的遮挡？</li>
</ul></li>
</ul>
<p>对于相机的要求、限制应该在项目早期就明确，除非是个别例外，并且要避免在项目开展后大改相机系统。因此，要在项目商讨环节把需求都明确清楚</p>
<p>团队中的camera
designer不仅需要负责相机表现，而且也需要负责大部分情况下的相机解决方案。Lead
camera
designer需要具备美学sense，包括游戏内容的呈现和玩家操作、感知的表现，此外，他还需要推动团队提高认知</p>
<h3 id="camera-design-guidelines">Camera Design Guidelines</h3>
<p>一些相机设计的建议：</p>
<ul>
<li>Attempt to keep the player character in view (3rd person
cameras)</li>
<li>Prevent the camera passing through (or close to) game objects or
physical environmental features</li>
<li>Do not require the player to manipulate the camera simply to play
the game -- unless it is a design requirement</li>
<li>Allow camera manupulation when possible or dictated by game design
requirements</li>
<li>Minimize unintentional camera motion whenever possible</li>
<li>Ensure camera motion is smooth</li>
<li>Limit the reorientation speed of the camera</li>
<li>Limited roll should be allowed in most regular game cameras</li>
<li>Do not allow the camera to pass outside the game world</li>
<li>Retain the camera position with respect to the player when instantly
moving th camera to a new position (3rd person cameras)</li>
<li>Do not focus directly on the player character when it is moving</li>
<li>Retain control reference frame after rapid or instantaneous camera
motion</li>
<li>Avoid enclosed spaces with complex geometry (3rd person
cameras)</li>
</ul>
<h2 id="chapter-5-camera-solutions">Chapter 5: Camera Solutions</h2>
<h3 id="game-genre-camera-solutions">Game Genre Camera Solutions</h3>
<ul>
<li>FPS游戏：目标是提供沉浸式的体验
<ul>
<li>位置：一般与玩家视角同步，但并不是玩家眼睛的位置，因为武器、手臂等必要元素通常不能从眼睛位置可视</li>
<li>朝向：通常与人眼可视方式一样，即free-look，有时候可帮助玩家自动调整垂直方向的朝向</li>
<li>武器或手臂位置：武器与手臂通常可见</li>
<li>与外部观测的不同：多人游戏中其他玩家看到的角色可能不同</li>
<li>与三人称之间的切换：常用jump cut实现切换</li>
<li>Zoom effects</li>
<li>Lack of peripheral vision</li>
<li>Aiming position</li>
<li>Motion sickness</li>
<li>Camera shaking</li>
<li>Cmaera bob: 角色运动时相机的轻微移动</li>
<li>Idle wandering</li>
<li>Scale: 人物在高速移动时往往会scale
尽管相机和人物之间保持相对距离，但是相机也对影响人物移动的因素相当敏感，比如在复杂的地形上，角色可能被垂直提高一段距离，这通常不到一秒钟的时间，但是仍然会对相机产生影响，导致glitch现象，这可以通过增加垂直方向的damping解决，这只有在角色穿越崎岖地表时才生效。注意一人称的damping值要比三人称小</li>
</ul></li>
<li>Character/action
adventure游戏：可以根据角色的技能决定相机的行为，比如大致分为两类：地面与飞行</li>
<li>Stealth: 相机会随着使用物品或武器而变化</li>
<li>3D platform: 主要分为两种形式：free form与pre-determined
<ul>
<li>free-form: 相机的位置与距离可以由玩家操控</li>
<li>pre-determined: 严重依赖于特定的Game
play，同时也要兼顾相机的效果</li>
</ul></li>
<li>RPG: 常用三人称相机</li>
<li>Scrolling</li>
<li>Sports: TV-style presentation may be very desired
<ul>
<li>Single-participants sports: 相机只需要focus on玩家或者单个物体</li>
<li>Two or four-participant sports: 联机or分屏</li>
<li>Team sports: 预留一个control
command标识当前正在控制哪个角色以及哪些角色可以被控制</li>
<li>Court and indoor sports:
对球类运动而言，难点在于追踪及可视球；对桌类运动而言，要提供整个桌面的视野并简化玩家操作</li>
<li>Outdoor sports:
对于场地运动，可以提供能够自主操作的相机；自由运动；轨道运动</li>
<li>Abstract sports</li>
</ul></li>
<li>Racing games:
可提供额外的视角以观测其他人的位置，增大FOV可以制造物体快速通过玩家的感觉</li>
<li>Ground vehicles</li>
<li>RTS</li>
<li>Flight simulation: 一个重要的方面是是否允许相机随着飞机一起roll
<ul>
<li>Realistic flight models: 此类游戏通常从驾驶舱或飞机后侧观察</li>
<li>Non-realistic flight models</li>
<li>Artificial horizon: 可以用仪器监控飞机的pitch或banking</li>
<li>Sensation of motion:
可以用云层或航迹云增强飞机的速度感；航天器可以用小的残骸增强速度感；也可以通过音效、FOV等方式</li>
</ul></li>
<li>Adventure: present a very cinematic experience to the player</li>
<li>Puzzle/party games/board games</li>
<li>Fighting/close combat:
场景一般很简单以便于相机摆放，需要一些相机移动突出角色的操作</li>
</ul>
<h3 id="multi-player-camera-solutions">Multi-Player Camera
Solutions</h3>
<p>多人共享屏幕时，相机设计会有很大难度，有时候可以通过alternate
players解决，但多数情况下并不适用。一般来说可以有两种解决方法：</p>
<ul>
<li>分屏</li>
<li>单屏包含所有玩家</li>
</ul>
<p>下面是对相关技术的介绍：</p>
<ul>
<li>Single-screen techniques: 格斗游戏、合作游戏中常见
<ul>
<li>相机的位置很难确定</li>
<li>通常相机位置固定在一个离游戏世界表面相对的高度，而与玩家移动无关</li>
<li>相机位置可能导致朝向的迅速变化</li>
</ul></li>
<li>Split-screen techniques
<ul>
<li>每个玩家的分屏区域一样大</li>
<li>根据活跃玩家动态分屏</li>
<li>为了提升性能，尽量让所有玩家都处于同一个环境中</li>
<li>尽量减少玩家获取的信息</li>
<li>避免把重要的物体放在设备屏幕边缘</li>
</ul></li>
<li>Transitioning from full-screen to split-screen
<ul>
<li>保持相机相对距离相同</li>
<li>UI元素要重新排布</li>
<li>FOV要根据aspect ratio重新调整</li>
</ul></li>
<li>Transitioning from split-screen to full-screen
<ul>
<li>玩家移动地足够近的时候</li>
<li>UI元素要等transition完成时再移动</li>
<li>相机相对位置保持不变</li>
<li>FOV调整</li>
</ul></li>
</ul>
<h2 id="gamera-scripting">Gamera Scripting</h2>
<h3 id="what-is-meant-by-scripting">What is Meant by Scripting</h3>
<p>定义与控制物体加偶和的过程被称为scripting，在游戏中，指控制游戏事件发生的事件与物体之间的交互。Scripting允许设计师在没有程序员介入的情况下完成迭代</p>
<h3 id="types-of-scripting">Types of Scripting</h3>
<p>我们希望构建一个与游戏类型无关的scripting系统，主要由两个方面组成：scripting
language和event messaging</p>
<h4 id="scripting-languages">Scripting languages</h4>
<ul>
<li>Text-based scripting languages:
包括pre-compiled和interpreted两类</li>
<li>General-purpose programming languages: 编程语言</li>
<li>Custom scripting languages</li>
<li>Finite state machines</li>
<li>Visual scripting languages</li>
</ul>
<h4 id="event-messaging">Event messaging</h4>
<p>Event
messaging要求定义不同物体之间的关系。典型的能够发送消息的事件包括：</p>
<ul>
<li>关卡开始</li>
<li>物体加载</li>
<li>游戏暂停</li>
<li>进入或退出volume</li>
<li>玩家受到伤害</li>
<li>物体到达路径终点</li>
<li>玩家状态改变</li>
</ul>
<p>能够被事件发送的典型消息包括：</p>
<ul>
<li>Start</li>
<li>Stop</li>
<li>Activate object</li>
<li>Delete object</li>
<li>Query state</li>
</ul>
<h3 id="script-objects">Script Objects</h3>
<p>用于定义物体的属性和行为</p>
<h3 id="scriptable-game-hints">Scriptable game hints</h3>
<p>Game hints are script objects that provide one possible type of
runtime mechanism by which designers can override player properties,
game controls or camera properties according to events</p>
<ul>
<li>Camera hints: 改变相机的属性或移动，可以被重载的相机属性包括：
<ul>
<li>相机行为</li>
<li>位置朝向</li>
<li>相对距离</li>
<li>看向点</li>
<li>移动速度</li>
<li>FOV</li>
</ul></li>
<li>Player hints
<ul>
<li>Prevent motion of the player</li>
<li>Relocate player position</li>
<li>Change player movement characteristics</li>
<li>Flags to indicate special kinds of game play</li>
</ul></li>
<li>Control hints
<ul>
<li>Disable specific controls or sets of player controls</li>
<li>Specify the control reference time and the time to interpolate to
that new reference time</li>
</ul></li>
</ul>
<p>很多时候事件需要有先后顺序，一个sequenced event
manager可以用来定义事件的先后顺序。</p>
<h3 id="camera-scripting">Camera Scripting</h3>
<h4 id="camera-scripting-methods">Camera scripting methods</h4>
<ul>
<li>Pre-defined camera scripting</li>
<li>Dynamic camera scripting: 只调整需要的相机属性</li>
</ul>
<h4 id="dcamera-control">DCamera control</h4>
<ul>
<li>Third person scripting: 用专门的script objects去调整FOV、Focal
Length，filter or rendering effects, fog distance等</li>
<li>First person scripting: 有一些情况也需要对FP相机进行动态控制，比如
<ul>
<li>Traversing up or down ramps or other significantly sloped surfaces:
在上下坡的时候线相机要和坡度一致 <img
src="/images/realtime_cameras/6-6.png"
alt="根据玩家位置自动pitch。" /></li>
<li>Jumping: 在高距离跳跃时，能够对准落脚点的方向，但幅度不宜过大 <img
src="/images/realtime_cameras/6-7.png"
alt="玩家跳跃时自动pitch。" /></li>
<li>View locking: 锁定目标时相机要朝向目标点 <img
src="/images/realtime_cameras/6-8.png" alt="玩家锁定目标。" /></li>
</ul></li>
<li>Non-interactive movie scripting:
最常用的就是位置和朝向的scripting</li>
</ul>
<p>一些经验法则：</p>
<ul>
<li>Apply Occam's Razor: 使用最简单scripting方案，这便于随时修改</li>
<li>Allow for different ways that the camera event may be triggered:
比如有时候只用trigger volume可能不够</li>
<li>Allow previewing of camera motion and orientation: 支持预览</li>
<li>Assess camera scripting requirements early in the design
process</li>
<li>Make the scripting development cycle as efficient as possible:
提高预览和扩展能力</li>
<li>Mimic the behaviors of the tools used by artists where possible:
降低艺术家（设计师）的学习成本</li>
<li>Allow for game play changes: camera scripting system:
游戏玩法改变时能够轻松地修改camera</li>
</ul>
<h3 id="scripting-tools">Scripting Tools</h3>
<h4 id="world-editor-support">World editor support</h4>
<p>必须支持script objects的放置与操作，而且还要支持message passing,
state transition, event trigger和其他物体间的关系</p>
<h4
id="communication-between-target-platform-and-development-pc">Communication
between target platform and development PC</h4>
<p>要获得运行物体的状态</p>
<h4 id="messagingevent-logging">Messaging/event logging</h4>
<p>对消息和事件进行记录</p>
<h4 id="object-properties-debugging">Object properties debugging</h4>
<p>当游戏运行时要动态检查物体的属性</p>
<h4 id="replay">Replay</h4>
<p>最简单的方法是内置video recording</p>
<h4 id="console-window">Console window</h4>
<p>支持打印文本消息，通过GM指令查看想要的文本消息</p>
<h3 id="scripting-debugging">Scripting Debugging</h3>
<p>常见的debugging方法：</p>
<ul>
<li>Script statement execution/filter:
对任意给定的script，展示每个状态执行的历史记录</li>
<li>Debug message logging: 单独展示日志</li>
<li>Message filtering: 增加过滤功能以更好地debug</li>
<li>Object state: 展示物体的状态</li>
<li>FSM state changes: 展示当前的state和历史state</li>
<li>Animation state and event management:
记录当前的动画状态和插值状态，记录事件</li>
</ul>
<h1 id="part-3-camera-engineering">Part 3: Camera Engineering</h1>
<h2 id="chapter-7-position-and-orientation">Chapter 7: Position and
Orientation</h2>
<h3 id="coordinate-schemes">Coordinate Schemes</h3>
<p>有几种不同的坐标空间：</p>
<ul>
<li>World Space: 从世界空间到相机空间再到屏幕空间</li>
<li>Camera Space: 以相机为原点</li>
<li>Screen Space: Camera Space通过正交变换而来</li>
<li>Local Space: 以角色为原点</li>
<li>Object Relative: 相机为原点，三个轴根据某个物体到相机的位置而定</li>
</ul>
<h3 id="desired-position">Desired Position</h3>
<p>在相机移动的过程中需要关注与目标点的距离</p>
<h4 id="first-person-camera-positioning">First person camera
positioning</h4>
<p>大多数情况下，相机的desired
position就是角色眼睛的位置，此时增加一点dvertical
amping会有用。在玩家遇到崎岖地形或与物体碰撞时，需要smooth
out轻微的相机运动</p>
<h4 id="third-person-camera-positioning">Third person camera
positioning</h4>
<p>有三种策略决定相机位置：</p>
<ul>
<li>Automated: 相机完全自动化</li>
<li>Player control: 交由玩家操作相机，但要让环境始终保持在视野中</li>
<li>Hybrid: 交给玩家部分自主权</li>
</ul>
<h3 id="desired-position-determination-methods">Desired Position
Determination Methods</h3>
<p>相机位置应该独立于朝向，尽管后者常常依赖于前者。下面是一些决定desired
position的方法</p>
<h4 id="stationary">Stationary</h4>
<p>主要有两种stationary cameras: fixed position 和 dynamic fixed
position:</p>
<ul>
<li>Fixed position:
相机位置固定但可以自由调整朝向，通常限制了朝向的范围。但此类相机会使目标离相机太远或者丢失视野</li>
<li>Dynamic fixed position: 通常由其他活跃的相机决定，中间由jump
cut或interpolation决定</li>
</ul>
<h4 id="slavedtracking">Slaved/tracking</h4>
<p>相机的offset可以采取以下的几种形式：</p>
<ul>
<li>World-relative offset: 在世界坐标内保持相对距离 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>World-relative angular offset: 在世界坐标中通过角度定义相对距离
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="title">offset</span>(<span class="params"><span class="number">0.0f</span>, cosf(pitch</span>) * distance, <span class="title">sinf</span>(<span class="params">pitch</span>) * distance)</span>;</span><br><span class="line"><span class="comment">// construct a rotation matrix around the world up-axis</span></span><br><span class="line">Mat3 rotation = Mat3::ZRotation(yaw);</span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>World object relative:
根据主物体和另一个物体之间的距离决定相机位置，这种方法可以帮助处理人物在相机和另一物体中间的情况
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mat3 rotation = Mat3::LookAt(GetTargetObject()-&gt;GetPosition().DropZ(), mWorldPosition.DropZ());</span><br><span class="line"><span class="comment">// note that the reference frame is often 2D, but is not required to be</span></span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>Local offset: 与world relative
offset类似，只不过offset被转换到了局部空间 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat3 rotation = mScriptObject-&gt;GetMatrix(); <span class="comment">// based on the orientation of the script object</span></span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>Local angualar offset: 类似world-relative angular
offset，不过offset被转换到了局部空间 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="title">offset</span>(<span class="params"><span class="number">0.0f</span>, cosf(pitch</span>) * distance, <span class="title">sinf</span>(<span class="params">pitch</span>) * distance)</span>;</span><br><span class="line">Mat3 rotation = mScriptObject-&gt;GetMatrix();</span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>Character-relative offset:
在局部坐标内根据角色的朝向决定相机的位置，在三人称相机中最为常用，被称为“追背相机
(chase camera)”, 一般不会变化Roll</li>
<li>Character-relative angular offset:
在局部坐标内根据角色朝向和三个旋转角度、距离决定相机位置，通常会限制相机旋转速度的变化率</li>
<li>Object-relative offset:
不考虑目前物体的朝向，而仅考虑elevation和distance，the vector from the
target object toward the current camera position defines the coordinate
space used to calculate the desired position，相机的朝向通常由玩家操纵
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mat3 rotation = Mat3::LookAt(GetPosition().DropZ(), GetTargetObject()-&gt;GetPosition().DropZ(), mWorldPosition);</span><br><span class="line"><span class="comment">// only elevation (here pitch) and distance are required</span></span><br><span class="line"><span class="function">Vec3 <span class="title">offset</span>(<span class="params"><span class="number">0.0f</span>, cosf(pitch</span>) * distance, <span class="title">sinf</span>(<span class="params">pitch</span>) * distance)</span>;</span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="path">Path</h4>
<p>有几种不同类型的路径：</p>
<ul>
<li>Linear: 直线路径</li>
<li>Circular/elliptical/spiral: 环状路径 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = a * cos(theta);</span><br><span class="line">Y = b * sin(theta);</span><br></pre></td></tr></table></figure></li>
<li>Spline: 通常一系列control points定义</li>
</ul>
<p>下面是决定路径位置的方法：</p>
<ul>
<li>Non-interactive situations: 在movie
sequences中通常由一个时间到位置的映射决定</li>
<li>The position of the player character relative to another object</li>
<li>Player position relative to a defined path</li>
<li>A specified distance away from the closest position on the path to
the player: 改方法需要注意相机移动的平滑性</li>
</ul>
<p><strong>Splines.</strong> 可以用brute
force的方法去计算spline的长度，代码如下 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">length</span>(<span class="params"><span class="number">0.0f</span></span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; controlPoints.Size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  Vec3 pathPosition = EvaluateSegment(i, <span class="number">0.0f</span>);</span><br><span class="line">  <span class="comment">// start of i&#x27;th segment</span></span><br><span class="line">  controlPoints[i].mLength = length;</span><br><span class="line">  <span class="comment">// save length at the control point</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; i &lt; kMaxSegmentSlices; ++j)</span><br><span class="line">  <span class="comment">// includes next control point</span></span><br><span class="line">  &#123;</span><br><span class="line">    Vec3 newPosition = EvaluateSegment(i, j/kMaxSegmentSlices);</span><br><span class="line">    Vec3 delta = newPosition - pathPosition;</span><br><span class="line">    length += delta.Magnitude();</span><br><span class="line">    <span class="comment">// add the &quot;length&quot; of this slice</span></span><br><span class="line">    pathPosition = newPosition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   <span class="comment">// length now holds the approximate total length</span></span><br></pre></td></tr></table></figure></p>
<p>一种更快且准确的方法是用多项式逼近</p>
<p><strong>Mapping functions.</strong>
最简单的是从时间到长度的线性映射，此时相机的速度不变，导致abrupt开始或结束。一种常见的方法是使用一个二维spline曲线（Hermite
curves)，用户可以定义控制点和切线控制曲线的形状</p>
<h4 id="surface-constrained">Surface constrained</h4>
<p>在一些情况下，相机可能限制在一个隐式的平面上，比如一个flat平面，一个椭球、圆柱等等，该平面的大小和朝向可能是动态的</p>
<p>下面是一些常见的surface类型：</p>
<ul>
<li>Sphere: 容易受gimbal lock影响</li>
<li>Plane</li>
<li>Cylinder</li>
<li>Cone</li>
<li>Extruded spline plane</li>
<li>Spline cylinder</li>
</ul>
<h4 id="volume-constrained">Volume constrained</h4>
<p>相机与圆柱体的碰撞检测：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vec3 direction = currentPosition - cylinder.GetPosition();</span><br><span class="line">direction.SetZ(<span class="number">0.0f</span>);</span><br><span class="line"><span class="built_in">float</span> radius = direction.Magnitude();</span><br><span class="line"><span class="keyword">if</span> (radius &gt; kMaxRadius)</span><br><span class="line">  radius = kMaxRadius;</span><br><span class="line">direction = direction.AsNormalized() * radius;</span><br><span class="line">Vec3 newPosition = cylinder.GetPosition() + direction;</span><br><span class="line">newPosition.SetZ(currentPosition.GetZ());</span><br></pre></td></tr></table></figure>
<h4 id="framing">Framing</h4>
<p>该方法在屏幕空间上保持目标角色的位置，这可以通过移动相机、修改FOV、伸缩viewport等方法实现</p>
<h4 id="object-framing-relative">Object-framing relative</h4>
<p>该方法不仅考虑物体在屏幕空间中的小，而且也考虑它和另一个物体之间的相对距离，一些因素包括：</p>
<ul>
<li>Object screen size</li>
<li>Multiple objects must be kept on screen</li>
<li>Distance between objects</li>
<li>Relative position to other objects</li>
<li>Relative position to the screen (not rendered size)</li>
<li>Orientation with respect to the camera</li>
<li>Distance aiming/ranged weapons</li>
</ul>
<h4 id="axis-rotationalspindle">Axis rotational/spindle</h4>
<p>相机围绕游戏世界中的一个轴旋转、平移，适用于玩家需要围着一个物体导航的情况，或限制在一个圆柱物体的情况</p>
<p>一些影响相机位置的因素：</p>
<ul>
<li>Angular offset relative to the reference vector or the axis
origin</li>
<li>Axial offset relative to the current player positionn or the axis
origin</li>
<li>Radial offset relative to the spindle axis or current player
radius</li>
</ul>
<p>此外，我们也可以改变相机的朝向：</p>
<ul>
<li>Look at the spindle axis along a projected vector from the current
camera position</li>
<li>Look away from the spindle along a projected vector that passes
through the camera position as above</li>
<li>Apply an angular offset either toward or away from the spindle
relative to the target object</li>
</ul>
<p>玩家位置相对于spindle axis的半径可以作为mapping
function的输入，当玩家移动半径更小时，相机移动得更高</p>
<h3 id="common-position-problems">Common Position Problems</h3>
<ul>
<li>期望位置和一个物体碰撞，或者太近以至于物体穿透相机的近平面</li>
<li>期望位置离环境中的边界物体太近以至于有环境外的视野</li>
<li>期望位置离目标对象太远，玩家没有好的视野</li>
<li>环境复杂相机不能提供好的视野</li>
</ul>
<h3 id="orientation">Orientation</h3>
<p>旋转有四种表示方法：欧拉角、变换矩阵、轴角和四元数</p>
<h3 id="desired-orientation-determination-methods">Desired Orientation
Determination Methods</h3>
<h4 id="constant-orientation">Constant orientation</h4>
<p>朝向不变，但是位置可以移动。可以变式为constant elevation
cameras，即只有pitch可以改变</p>
<p>这种相机可以用在：</p>
<ul>
<li>Player controlled remote cameras</li>
<li>Dynamic positioning of replay cameras</li>
<li>Dynamic positioning of caemras for non-interactive game play
sequences</li>
</ul>
<h4 id="tracking-a-target-object-or-position">Tracking a target object
or position</h4>
<p>相机达到期望朝向的方法取决于目标物体的移动和相机的重朝向速度，此类相机一般保持固定的pitch</p>
<h4 id="look-at-offset">Look-at offset</h4>
<p>许多三人称游戏使用一个固定的look-at offset</p>
<h4 id="locked-look-at-position">Locked look-at position</h4>
<p>玩家的朝向也会随便改变</p>
<h4 id="target-object-position-prediction">Target object position
prediction</h4>
<h4 id="object-framing">Object framing</h4>
<p>一个很好的例子是格斗游戏，双方玩家都希望自己和对方都能呈现在屏幕上，当玩家距离增加的时候，相机要么拉远，要么增大FOV，但是频繁切换FOV通常不可取</p>
<p>回放相机通常会从不同的视角呈现玩家行为</p>
<h4 id="idle-wandering">Idle wandering</h4>
<p>A semi-random camera reorientation while the player character is
idle</p>
<h4 id="automated-orientation-control">Automated orientation
control</h4>
<p>在没有玩家操作的情况下自动帮助相机转向：</p>
<ul>
<li>Automated control over camera pitch when the player is jumping:
从玩家起跳时开始相机可以向下看</li>
<li>Automated pitch control when traversing environmental features: This
is applied to present a view facing up or down a ramp, staircase or
other incline as appropriate so that players have a better view of what
they are moving toward,
在有洞穴或悬崖的地方，相机应该自动看向以给予提示</li>
<li>Automated pitch control during combat or interactions:
自动调整pitch以提示可交互的物体</li>
<li>Automated reorientation of the player or a camera toward a target
position: 锁定到目标物体</li>
<li>Repositioning and reorientation of the camera to face the same
direction as the player character</li>
<li>Transitions from first to third person cameras:
要保证当相机移动地充分远的时候才渲染物体，避免穿帮，此时可通过fade角色解决此问题</li>
<li>Transitions from third to first person cameras: 可通过cut
transition实现</li>
</ul>
<h3 id="reorientation-methods">Reorientation Methods</h3>
<h4 id="applying-rotations">Applying rotations</h4>
<p>有几种方法去应用旋转：</p>
<ul>
<li>Constant angular velocity:
匀速变动旋转角，但是开始和结束会有突变</li>
<li>Acceleration and deceleration: 应用加速度与减速度</li>
<li>Angular velocity damping: 用damp使开始结尾更皮规划</li>
<li>Free-look damping: 用bump和其他的ease
functions防止因noise导致的相机朝向变动</li>
<li>Twist reduction</li>
</ul>
<h4 id="reorientation-lag">Reorientation lag</h4>
<p>通常我们希望相机朝向的变化能有一些延迟（lag），同时保持平滑</p>
<p>很多游戏没有任何延迟，这有两个影响：第一，相机直接看向角色会导致玩家不能提前看见角色的移动，第二，相机非常依赖角色的移动，任何小的扰动就会影响相机表现</p>
<p>因此需要使小的移动没有影响，并且使用damp。当插值的时候，可以限制每帧允许的旋转角度。此外，lag还可以通过用springs或feedback
controller实现</p>
<h4 id="offsets">Offsets</h4>
<p>一个常被忽略的点是look-at position和target
object之间的关系。如果直接看向角色，那么就容易丢失玩家想要看的东西。可以用一些视觉提示帮助玩家瞄准目标对象，比如highlight敌人，或者lock-on
to the target object</p>
<h4 id="smoothing-and-damping">Smoothing and damping</h4>
<p>常用的平滑方法是limit the angular velocity of the camera
proportionally to the angle between the current and desired
orientations，这可以表示为一个简单的三角函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Real32 <span class="keyword">const</span> <span class="title">kDampingAngle</span>(<span class="params"><span class="number">30.0f</span> * gkRadiansPerDegree</span>)</span>;</span><br><span class="line">Real32 angle = acosf(CVector3f::Dot(currentOrientation, desiredOrientation));</span><br><span class="line">Real32 <span class="keyword">const</span> kDampingFactor = Cmath::Limit(angle / kDampingAngle, <span class="number">1.0f</span>); <span class="comment">// linearly proportional</span></span><br><span class="line">Real32 angularLimit = angularSpeed * deltaTime * kDampingFactor;</span><br><span class="line">CQuaternion newOrientation = CQuaternion::LookAt(currentOrientation, desiredOrientation, angularLimit);</span><br></pre></td></tr></table></figure>
<p>始终记住我们有两个矛盾的要求：平滑移动和保持角色合理视角</p>
<h4 id="springs-and-pid-controllers">Springs and PID controllers</h4>
<p>In practice, tuning the characteristics of the controller to achieve
this behavior can be time-consuming but very worthwhile</p>
<h3 id="free-look">Free-Look</h3>
<h4 id="first-person-free-look">First person free-look</h4>
<p>很多一人称游戏采用circle
strafing技术允许玩家free-look，有些游戏也只允许垂直方向的朝向变化，当然也要限制最大角度</p>
<h4 id="third-person-free-look">Third person free-look</h4>
<p>用一个圆锥体围绕look-at点，并使用一个弹簧在没有输入指令的时候令相机能够回到初始位置</p>
<h4 id="free-look-orientation-determination">Free-look orientation
determination</h4>
<p>决定free-look朝向通常有两种方法：self-centering和non-centering</p>
<ul>
<li>Self-centering free-look:
玩家输入会让相机朝向改变，通常把遥感值映射为相机朝向的速度</li>
<li>Non-centering free-look: 在没有玩家输入时相机会保持现在的朝向</li>
</ul>
<h4 id="common-orientation-problems">Common orientation problems</h4>
<p>一些常见的相机朝向的问题：</p>
<ul>
<li>Gimbal lock: 当相机forward与世界up
axis平行时发生，要么不让相机平行于up axis，要么用四元数构造变换矩阵</li>
<li>Vertical twist: 当使用三人称相机时，如果相机朝向接近平行于up
axis则会出现这个问题，表现为相机快速围绕up
axis旋转，常发生于相机在墙角的情况，此时可以限制相机围绕up
axis的旋转速度，或者禁止相机朝向改变直到相机离玩家足够远</li>
<li>Roll: 飞行模拟游戏会经常使用roll</li>
<li>Orientation noise: 使用high-pass filter移除不想要的朝向变化</li>
<li>Rapid orientation changes:
当允许玩家快速移动/改变朝向，或玩家在相机下方或上方移动时，相机的朝向就会快速改变，带给玩家糟糕的体验</li>
<li>Frustum culling of the player character:
三人称游戏必须首先考虑frame玩家，切通常相机直接看向玩家前进的方向，但也要让玩家保持在view
frustum中</li>
</ul>
<h2 id="chapter-8-navigation-and-occulusion">Chapter 8: Navigation and
Occulusion</h2>
<p>Dynamic determination of how the camera should reach its desired
position is referred to here as <strong>navigation</strong></p>
<h3 id="the-cemera-as-an-ai-game-object">The Cemera as an AI Game
Object</h3>
<p>需要假定环境是封闭的，即有碰撞表面</p>
<h3 id="navigation-techniques">Navigation Techniques</h3>
<p>相机的寻路需要考虑环境限制</p>
<h4 id="dynamic-navigation-techniques">Dynamic navigation
techniques</h4>
<p>主要包括以下方法：</p>
<ul>
<li>Ray casting:
用射线决定是否存在遮挡物体，但是可能会有效率问题，此外，可以增加射线覆盖更大区域。另一种方法是使用ray-casting
hysteresis，即在多个update中累积ray
cast信息，并生成一个可能碰撞的概率图，从而减少每次更新的ray
cast数量。Ray
cast可以用于帮助相机移动。要对物体进行分类以区别哪些需要ray casting
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For all ray casts</span><br><span class="line">  if ray cast successful</span><br><span class="line">    No influence applied</span><br><span class="line">  if ray cast fails</span><br><span class="line">    Scale influence factor by distance of ray cast collision from target</span><br><span class="line">    Add influence to desired camera position</span><br><span class="line">End</span><br></pre></td></tr></table></figure></li>
<li>Volume projection:
该方法把一个volume从相机位置投影到目标位置，用来确定相机的移动是否合法</li>
<li>Sphere/cylinder collisions:
碰撞体的半径应该比近平面距离略大，理论上，碰撞体应该完全包含近平面frustum的四个顶点。在第一人称游戏中，可以不用给相机加碰撞体，因为一般有角色碰撞体即可，但是也要保证近平面被角色碰撞体包围</li>
<li>Dynamic path finding: High-level
solution负责volume之间的整体移动，low-level
solution负责避免碰撞。相机AI不同之处在于移动往往很短，因此更要关注low-level的需求</li>
<li>Dynamic path generation: 不同于path finding，path
generation使用的是游戏中动态生成的信息，所以生成的path可能会动态改变</li>
<li>Visibility and rendering solutions:
这种技术首先决定相机据目标物体的位置，基于一些其他限制，得到可能的相机位置点，对于每个可能的位置，令相机朝向角色，就可以看当前视角是否存在遮挡。决定好位置吼，就可以计算一条移动路径，但是也要注意路径中的遮挡和碰撞</li>
<li>Colliders:
在相机周围添加collider，每个collider都会发射射线，如果有遮挡出现，则移动相机位置
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stl::vector&lt;Vec3&gt; influence; </span><br><span class="line"><span class="comment">// might be useful as a class</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; colliders.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  influence.<span class="built_in">push_back</span>(colliders[i].offset * colliders[i].<span class="built_in">GetWeighting</span>());</span><br><span class="line">  <span class="comment">// the weighting depends on line of sight and/or</span></span><br><span class="line">  <span class="comment">// other factors such as the relative collider position</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// will need to get an average or similar</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetCentriod</span>(influence);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="pre-defined-navigation-techniques">Pre-defined navigation
techniques</h4>
<p>一些常见的pre-defined navigation技术：</p>
<ul>
<li>Pre-defined paths: 预先做好路径，根据玩家操作在路径上移动和朝向</li>
<li>Path motion behaviors: 有几种方法去限制相机的移动
<ul>
<li>Constrained path camera: 相机被固定在path上以避免碰撞</li>
<li>Follow path camera: 相机固定在path上，但移动方式可以有多种方式</li>
</ul></li>
<li>Pre-defined volumes</li>
<li>Attractors/repulsors:
相机会被其他pre-defined的位置、区域、物体所吸引/排斥，吸引力/排斥力的大小取决于相机离该物体的距离和朝向。在合适的时候用attractors/repulsors可以帮助相机避免穿模和在狭窄地区顺利通过，而不需要hand-scripted</li>
<li>Flow fields: Flow
fields是向量的稀疏数列，通常稀疏地分布在2D平面或者3D
Volume内。当相机穿过flow
field时，离相机近的向量会对相机朝向的方向施加一个力。Flow
field常用于一个额外的因子而不是单个因素</li>
<li>Influence maps: 类似flow field，但是通过目标对象离influence
map的相对距离决定而非camera本身，influence
map中的每个点都是相机的可选位置</li>
<li>Potential fields: 基于electrostatic
forces，即对一个物体施加的力的效果取决于发力点和目标物体之间的距离，类似attractors/repulsors</li>
</ul>
<h3 id="occulision">Occulision</h3>
<h4 id="occulusion-determination">Occulusion determination</h4>
<ul>
<li>Ray casting: 通常使用三个部分进行遮挡检测——头部、躯体和脚部</li>
<li>Volume casting</li>
<li>Rendering techniques:
<ul>
<li>Flat-shading using identifiers as color values:
待进行遮挡检测的物体使用flat
shading和一个标识颜色，环境物体使用不同的颜色渲染，然后可以通过display
buffer检测物体的遮挡部分</li>
<li>Z-buffer analysis: 直接用depth buffer进行检测</li>
<li>Rendering hardware occulusion queries</li>
</ul></li>
</ul>
<h4 id="occulusion-prediction-methodologies">Occulusion prediction
methodologies</h4>
<p>可以用一个predictive相机预测遮挡</p>
<h3 id="line-of-sight">Line of Sight</h3>
<h4 id="resolving-line-of-sight-problems">Resolving line of sight
problems</h4>
<p>可能有时候相机不能快速移动保持对目标物体的LOS，下面是一些可能的解决方案：</p>
<ul>
<li>Prevention: 手动调整相机位置让它避免出现loss of LOS</li>
<li>Graphical changes:
可以把遮挡物体透明掉或去掉，也可以着重突出角色（如描边、改变颜色、增加indicator）</li>
<li>Finding a desirable position:
可以以角色为中心旋转，或者使用visibility
octree信息，一旦一个位置被发现，则直接把相机relocate到该位置</li>
<li>Teleportation/jump cut:
可以把相机沿着LOS的方向移动，直到没有遮挡（注意要考虑相机的近平面位置与collision
volume）</li>
<li>Retaining control orientation: 相机移动后注意保持相同的retaining
control orientation</li>
</ul>
<h4 id="path-generation">Path generation</h4>
<p>该方法生成一条路径，相机沿着路径移动直到遮挡消失，生成的路径不仅要避免碰撞，并且也要符合美学要求：</p>
<ul>
<li>Follow character movement:
记录玩家移动的路径并让相机沿着路径移动</li>
<li>Ledge avoidance:
玩家从悬崖边缘下落时相机可能因为无法穿透物体而出现问题，解决方案可能有：
<ul>
<li>Pre-defined scripting solutions for all ledge situations</li>
<li>Use pre-defined solutions for difficult to resolve cases, especially
in confined spaces: 可以用stationary cameras或者spline paths</li>
<li>Teleport the camera to a new position if LOS fails due to the ground
being between the camera and its target: 这可能需要检测剪玩家的高度</li>
<li>Use player movement hysteresis to provide an approximate path taken
by the player character or target object</li>
<li>Interrogate the surrounding geometry to dynamically choose a path
based on the last position at which the player was visible to the
camera: 该位置给出了关于ledge的位置信息用于camera
path，但要保证相机不能离物体太近，也不能让相机垂直朝向</li>
</ul></li>
<li>Vertical column avoidance: Predictive cameras一般能解决该问题</li>
<li>Pre-computed solutions</li>
</ul>
<h4 id="avoiding-loss-of-los">Avoiding loss of LOS</h4>
<p>如果不能避免loss of LOS，我们可以采取一些方法进行弥补：</p>
<ul>
<li>Instant movement: 有时候很实用</li>
<li>Fade out the obscuring geometry or objects: 会降低玩家沉浸感</li>
<li>Do not render obscuring gheometry or objects at all:
可以用一个timer，只有时间到了才取消渲染</li>
<li>Render a graphical representation regardless of occlusion</li>
<li>Visibility pre-computation</li>
</ul>
<h4 id="fail-safes">Fail-safes</h4>
<p>Fail-safe检测可以分为三类：</p>
<ul>
<li>Per-update: 在一些情况下必须在每个update进行fail-safe检测
<ul>
<li>Geometry interpenetration of the camera near plane:
可以用一个足够大的collision volume避免</li>
<li>An invalid (non-normalized) camera transformation matrix:
此时可以orthonormalize或者reconstruct矩阵，或者可以回到上次正确的旋转矩阵</li>
<li>The camera is external to the game world</li>
<li>Excessive rotation required aounrd the world up-axis in one update:
限制旋转角度</li>
</ul></li>
<li>Frequent: 有时候每隔几次update进行一次fail-safe检测
<ul>
<li>LOS to garte object extremities</li>
<li>Distance from desired position</li>
</ul></li>
<li>Infrequent: 每隔几秒检测一次
<ul>
<li>Significant occlusion of player character (3rd person view
only)</li>
<li>Camera distance from target is too far: 会让目标看起来太小</li>
</ul></li>
</ul>
<p>一旦触发fail-safe condition，最好是立刻将相机移动到新的safe
position，通常是jump
cut。另一个方法是把相机移动回过去的已知点直到满足条件</p>
<h2 id="chapter-9-motion-and-collision">Chapter 9: Motion and
Collision</h2>
<h3 id="camera-movement-sequence">Camera Movement Sequence</h3>
<p>我们可以按照下述过程移动相机：</p>
<ul>
<li>Determine the desired position</li>
<li>Constrain the desired position accordingly</li>
<li>Generate a prospective movement toward the desired position</li>
<li>Test to see if the prosepctive movement will cause collision
(optional)</li>
<li>Resolve the collision (optional)</li>
<li>Generate and validate an alternative movement (optional if first
move fails)</li>
<li>Move the camera to the new position</li>
</ul>
<h4 id="character-motion">Character motion</h4>
<p>首先看看人物移动会怎样影响第一人称和第三人称相机</p>
<ul>
<li>First person cameras:
注意相机位置通常不是眼睛位置，因此要注意fov和aspect
ratio。有时候玩家跨越世界物体时可能造成traversal
jitter，因此可以增加vertical damping <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A typical damping scheme for aviuding unwanted noise in the verticasl </span></span><br><span class="line"><span class="comment">// motion of the camera is to simply limit the amount allowed per update.</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">kMaxZMotionPerSecond</span> <span class="params">(<span class="number">0.25f</span>)</span></span>;</span><br><span class="line">  <span class="comment">// desired maximum motion</span></span><br><span class="line"><span class="type">float</span> zMotion = newPosition.<span class="built_in">GetZ</span> () - oldPosition.<span class="built_in">GetZ</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> maxZMotion = kMaxZMotionPerSecond * deltaTime;</span><br><span class="line">zMotion = Math::<span class="built_in">Limit</span> (zMotion, maxZMotion);</span><br><span class="line">newPosition.<span class="built_in">SetZ</span> (oldPosition.<span class="built_in">GetZ</span> () + zMotion);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The smoothing is relatively harsh: the amount of vertical motion applied</span></span><br><span class="line"><span class="comment">// is constant and thus will possibly have discontinuities.</span></span><br><span class="line"><span class="comment">// An alternative is to use a critically damped using spring or PID controller.</span></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> zMotion = newPosition.<span class="built_in">GetZ</span> () - oldPosition.<span class="built_in">GetZ</span> ();</span><br><span class="line">verticalSpring.<span class="built_in">SetLength</span> (<span class="built_in">AbsF</span>(zMotion));</span><br><span class="line"><span class="comment">// update the spring length</span></span><br><span class="line"><span class="comment">// Here the target spring length is zero, and need not</span></span><br><span class="line"><span class="comment">// be set each time. Typically the spring length is unsigned,</span></span><br><span class="line"><span class="comment">// so that must be dealt with.</span></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> newZMotion = verticalSpring.<span class="built_in">Update</span> (deltaTime);</span><br><span class="line"><span class="keyword">if</span> (zMotion &gt; <span class="number">0.0f</span>)</span><br><span class="line">  newPosition.<span class="built_in">SetZ</span> (newPosition.<span class="built_in">GetZ</span>() - newZMotion);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  newPosition.<span class="built_in">SetZ</span> (newPosition.<span class="built_in">GetZ</span>() + newZMotion);</span><br></pre></td></tr></table></figure></li>
<li>Third person cameras: 必须解决相机加速小于角色的问题（motion
lag），和相机减速小于角色的问题（overshooting）</li>
</ul>
<h4 id="movement-methods">Movement methods</h4>
<p>一些移动相机的方法包括：</p>
<ul>
<li>Instantaneous motion: 直接把相机移动到期望的位置，但要注意：
<ul>
<li>可能也要改变朝向</li>
<li>可能需要检测新的位置是否离环境物体太近、没有在物体内</li>
<li>尽可能保持control reference frame</li>
<li>尽可能把所有该类型的变换定义为一个函数</li>
<li>如果出现多普勒效应，则应限制相机移动的最大速度</li>
</ul></li>
<li>Locked</li>
<li>Proportional controller: 该方法在目标也移动的时候表现不好
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> deltaPosition = desiredPosition - currentPosition;</span><br><span class="line"><span class="comment">// the distance at which velocity damping is applied</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">kDampDistance</span> <span class="params">(<span class="number">5.0f</span>)</span></span>;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> K = Math::<span class="built_in">Limit</span> (deltaPosition.<span class="built_in">Magnitude</span>() / kDampDistance, <span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// Limit constant to 0..1 based on distance</span></span><br><span class="line">Vec3 <span class="type">const</span> cameraVelocity = deltaPosition.<span class="built_in">AsNormalized</span> () * K;</span><br><span class="line">Vec3 <span class="type">const</span> newPosition = currentPosition + cameraVelocity * deltaTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can help solve the problem of the camera being left behind by adding a </span></span><br><span class="line"><span class="comment">// portion of the target object&#x27;s velocity into the original equation.</span></span><br><span class="line">Vec3 targetVelocity = (desiredPosition - previousDesiredPosition) / deltaTime;</span><br><span class="line">Vec3 = cameraVelocity = (deltaPosition.<span class="built_in">AsNormalized</span> () * K * deltaTime) + (targetVeclocity * T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// To have smooth motion we need to accelerate the camera over time </span></span><br><span class="line"><span class="comment">// with a limiter to provide some degree of lag in the motion.</span></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> acceleration = Math::<span class="built_in">Limit</span> ( (desiredVelocity - currentVelocity), kMaxAcceleration);</span><br><span class="line">Vec3 <span class="type">const</span> currentVelocity += acceleration * deltaTime;</span><br><span class="line">Vec3 <span class="type">const</span> desiredPosition = currentPosition + (currentVelocity * deltaTime);</span><br></pre></td></tr></table></figure></li>
<li>Physical simulations</li>
<li>Springs:
当目标物体朝相机移动或突然停止时，相机可能出现overshooting问题，我们希望critical
damping，即无论目标物体怎么动，都不会出现overshooting</li>
<li>PID controllers: proportional integral derivative (PID)
controllers，把feedback应用到控制器中减少当前值和期望值的错误量
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The usage of PID controller</span></span><br><span class="line">Vec3 <span class="type">const</span> currentDelta = currentPosition - desiredPosition;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> currentDistance = currentDelta.<span class="built_in">Magnitude</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> newDistance = PIDController.<span class="built_in">Update</span> (desiredDistance, currentDistance, deltaTime);</span><br><span class="line">Vec3 <span class="type">const</span> currentPosition = desiredPosition + (currentDelta.<span class="built_in">AsNormalized</span> () * newDistance);</span><br></pre></td></tr></table></figure></li>
<li>Circular movement: 相机的运动由reference
point到当前位置和期望位置之间的夹角决定，因此需要计算其角速度，有两个方法计算：
<ul>
<li>Constant angular velocity: 不管半径多大，以固定的角速度旋转</li>
<li>Constant linear velocity: 保持固定线性速度 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A typical implementation of moving a camera by constant angular velocity might be:</span></span><br><span class="line">Vec3 cameraBearing = <span class="built_in">Vec3</span> (currentPosition - referencePoint);</span><br><span class="line">Vec3 desiredBearing = <span class="built_in">Vec3</span> (desiredPosition - referencePoint);</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> radius = cameraBearing.<span class="built_in">Magnitude</span> ();</span><br><span class="line">cameraBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line">desiredBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> angularMotion = angularVelocity * deltaTime; </span><br><span class="line">  <span class="comment">// rads/update</span></span><br><span class="line">Quat <span class="type">const</span> q = Quat::<span class="built_in">ShortestRotationArcClamped</span> (cameraBearing, desiredBearing, angularMotion);</span><br><span class="line">Vec3 <span class="type">const</span> newBearing = q * cameraBearing; </span><br><span class="line">  <span class="comment">// rotate the original bearing</span></span><br><span class="line">Vec3 <span class="type">const</span> newPosition = referencePoint + (newBearing * radius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of constant linear velocity might be:</span></span><br><span class="line">Vec3 cameraBearing = <span class="built_in">Vec3</span> (currentPosition - referencePoint);</span><br><span class="line">Vec3 desiredBearing = <span class="built_in">Vec3</span> (desiredPosition - referencePoint);</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> radius = cameraBearing.<span class="built_in">Magnitude</span> ();</span><br><span class="line">cameraBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line">desiredBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> arcLength = linearVelocity * deltaTime;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> angularMotion = <span class="built_in">acosf</span> (arcLength / radius); </span><br><span class="line">  <span class="comment">// units/update</span></span><br><span class="line">Quat <span class="type">const</span> q = Quat::<span class="built_in">ShortestRotationArcClamped</span> (cameraBearing, desiredBearing, angularMotion);</span><br><span class="line">Vec3 <span class="type">const</span> newBearing = q * cameraBearing; </span><br><span class="line">  <span class="comment">// rotate the original bearing</span></span><br><span class="line">Vec3 <span class="type">const</span> newPosition = referencePoint + (newBearing * radius);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Interpolation:
考虑在两个相机的速度之间插值，为了避免discontinuity，要让加速度匹配而不仅仅是速度</li>
</ul>
<h4 id="smoothing-and-damping-techniques">Smoothing and damping
techniques</h4>
<p>Damping方法通常要用ease
functions，把一个输入值（0到1之间）映射到相同区间，只不过是非线性映射且开始和结尾的导数为零</p>
<ul>
<li>Motion damping: 可以通过添加vertical damping减少颠簸感</li>
<li>Motion filters: 用一个低通滤波过滤噪音 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> movementDelta = newPosition - currentPosition;</span><br><span class="line"><span class="keyword">if</span> (movementDelta.<span class="built_in">Magnitude</span> () &gt; kMovementThreshold) &#123;</span><br><span class="line">  currentPosition = newPosition;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ignoring small changes may cause the camera never to move at all!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面是一种改进的方法（使用finite impulese response and infinite impulse
response filters）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> movementDelta = newPosition - currentPosition;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">close_enough</span> (movementDelta, Vec3::<span class="built_in">Zero</span> ())) &#123;</span><br><span class="line">  <span class="type">float</span> distance = movementDelta.<span class="built_in">Magnitude</span> ();</span><br><span class="line">  distance = mMovementFilter.<span class="built_in">Update</span> (distance);</span><br><span class="line">  currentPosition += movementDelta.<span class="built_in">AsNormazlied</span> () * distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="motion-constraints">Motion constraints</h4>
<p>一般有下述几种相机约束：</p>
<ul>
<li><p>Vertical motion constraint:
用于避免不想要的图形效果如穿模，比如避免水面穿帮可以用下面的代码：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">kMinimumZDistance</span> <span class="params">(<span class="number">0.1f</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">zDistance</span> <span class="params">(currentPosition.GetZ () - waterPlane.GetZ ())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span> (zDistance) &lt; kMinimumZDistance)</span><br><span class="line">&#123;</span><br><span class="line">  currentPosition.<span class="built_in">SetZ</span> (waterPlane.<span class="built_in">GetZ</span> () + Math::<span class="built_in">Sign</span> (zDistance) * kMinimumZDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
显然，上述代码的问题在于相机在进入水面后会出现不连续移动，但这无法避免，但可以用特效过渡</p></li>
<li><p>Render geometry proximity: 用collision volume解决</p></li>
<li><p>Distance constraints:
可以让相机和玩家保持固定的距离或最小/最大距离，但是可能会有问题
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> unconstrainedOffset = currentPosition - desiredPosition;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> currentDistance = inverseDirection.<span class="built_in">Magnitude</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> newDistance = Math::<span class="built_in">Clamp</span> (kMinDistance, currentDistance, kMaxDistance);</span><br><span class="line">Vec3 <span class="type">const</span> newOffset = unconstrainedOffset.<span class="built_in">AsNormalized</span> () * newDistance;</span><br><span class="line">currentPosition = desiredPosition + newOffset;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Planaer constraints <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CPlane <span class="type">const</span> <span class="title">plane</span> <span class="params">(normal, constant)</span></span>;</span><br><span class="line"><span class="function">Vec3 <span class="title">cameraPosition</span> <span class="params">(GetCurrentPosition ())</span></span>;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> planeDistance = Vec3::<span class="built_in">Dot</span> (plane.<span class="built_in">GetNormal</span> (), cameraPosition) - plane.<span class="built_in">GetConstant</span> ();</span><br><span class="line"><span class="keyword">if</span> (planeDistance &lt; kMinDistance)</span><br><span class="line">&#123;</span><br><span class="line">  cameraPosition += plane.<span class="built_in">GetNormal</span> () * (planeDistance - kMinDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Surface constraints</p></li>
<li><p>Volume constraints</p></li>
</ul>
<h4 id="player-camera-control">Player camera control</h4>
<p>一个原则： &gt; The player should be not REQUIRED to manipulate the
camera simply to play the game, unless explicitly dictated by the game
design.</p>
<p>If camera-relative, the sheer act of moving the camera changes the
control reference frame and "pulls the rug out from under the player's
feet". Sadly, some games seem to treat this behavior as acceptable. It
is not. Changing the control reference frame without player knowledge is
counter to good game play practice.</p>
<ul>
<li>Maunipulation of the camera position:
有时候允许玩家直接操纵相机，分为2D和3D相机
<ul>
<li>2D相机: 2D游戏通常会限制相机的移动以防看到游戏外的场景</li>
<li>3D相机: 在不同相机之间切换可以使用插值或jump cut</li>
</ul></li>
<li>Observer cameras: 提供观察者相机，即可以随意自由移动的相机</li>
<li>Camera motion validation: 一些游戏不允许操纵相机位置</li>
<li>Positional control constraints:
Character-relative相机通常保持在玩家身后的一定区域内，一般不会让相机面朝角色。相机移动要尽可能平滑和慢以避免player
disorientation</li>
</ul>
<h4 id="camera-position-control-schemes">Camera position control
schemes</h4>
<p>主要有两种方法决定相机位置：</p>
<ul>
<li>Character-relative:
类似unity的free-look相机，但需要加一些限制，比如相机的移动范围是一个cylindrical而不是整个球面、相机在人物朝向的身后一定范围内。一些相机允许半自动的移动，比如移动向一个危险区域时</li>
<li>World-relative:
此时相机的朝向和玩家朝向没关系，比如RTS、运动、3D平台游戏中的相机</li>
</ul>
<h4 id="manipulation-of-camera-orientation">Manipulation of camera
orientation</h4>
<ul>
<li>First person cameras</li>
<li>Third person cameras:</li>
</ul>
<h4 id="automated-camera-positioning-and-orientation">Automated camera
positioning and orientation</h4>
<p>除了cinematic
sequences之外，也有一些情况会需要相机自动改变位置和朝向：</p>
<ul>
<li>In response to player controller usage: 玩家自由选择视角</li>
<li>In response to game play requirements:
在三人称游戏中，有时候我们想保证某个物体一直在视野内，有时候，会通过相机给玩家辅助（比如在跳跃时增加pitch）</li>
</ul>
<h4 id="debug-camera-control">Debug camera control</h4>
<p>该相机需要在不影响游戏的情况完全由用户操作，同时，如果能在降低游戏运行速度的情况能以正常速度操作debugging
camera，则会非常有利于debug</p>
<h3 id="camera-collisions">Camera Collisions</h3>
<h4 id="the-importance-of-camera-collisions">The importance of camera
collisions</h4>
<p>Camera collision可能引起的问题：</p>
<ul>
<li>The collision prevents the camera from moving to its desired
position</li>
<li>Discontinuous motion may be caused by collisions</li>
<li>Occulusion of the target object</li>
<li>Camera near plane intersects with geometry</li>
</ul>
<h4 id="collision-determination">Collision determination</h4>
<ul>
<li>Object collisions</li>
<li>Environmental collisions: 有两种数据——render mesh和collision
mesh</li>
<li>Collision primitives: 通常来说，相机会被表示为球体用于碰撞检测</li>
</ul>
<h4 id="collision-geometry-design">Collision geometry design</h4>
<p>下面是一些设计场景的tips:</p>
<ul>
<li>Avoid tightly confined spaces</li>
<li>Allow sufficient space for the camera</li>
<li>Steep steps</li>
<li>Ledges/overhangs</li>
<li>Low ceilings</li>
<li>Doorways:
第一，玩家可能移动太快以至于门在玩家和相机之间关闭，此时可以让门保持开启直到相机穿过；第二，玩家可能沿着门缝移动并导致相机无法跟随玩家，此时可以让相机沿着门缝的轴移动；第三，玩家可能站在门缝里，此时要避免相机因玩家旋转而与物体相交</li>
<li>Use the simplest collision mesh possible</li>
<li>Separate collision mesh for the camera</li>
<li>Chamfer all corners: 为此可以让相机沿着collision表面滑动</li>
</ul>
<h4 id="collision-resolution">Collision resolution</h4>
<p>当我们检测到发生碰撞时，就需要决定相机怎么办，可以有以下几种策略：</p>
<ul>
<li>Do not move: 此时如果人物移动就可能会有问题</li>
<li>Partial move: 尝试向期望方向移动，如果还是有碰撞则不动</li>
<li>Alternative movement: 改变相机的移动方向</li>
<li>Jump cut: 重新计算desired position并立即切换过去</li>
</ul>
<h4 id="disabling-collision-detection">Disabling collision
detection</h4>
<p>有时候我们不需要相机的碰撞检测。比如第一人称和第三人称视角的切换、path-based
cameras。总之取决于期望的相机效果</p>
<h4 id="avoiding-camera-collisions">Avoiding camera collisions</h4>
<p>可以动态生成一条相机跟随的路径，或者统一采用半透明的方式。在三人称游戏中，当玩家在墙角或无法移动的地区时，相机可能和角色碰撞，此时可以切换到第一人称中，或者旋转相机调整相机位置</p>
<ul>
<li>Future position of player</li>
<li>Predicting potential collisions</li>
<li>Collision prediction</li>
<li>Object repulsion</li>
<li>Movement toward the camera</li>
</ul>
<h2 id="chapter-10-camera-mathematics">Chapter 10: Camera
Mathematics</h2>
<p>摄像机的一些数学：</p>
<ul>
<li>Camera position
<ul>
<li>Offset within the local space of an object</li>
<li>Angular offsets relative to game objects</li>
<li>Valid position determination</li>
<li>Spline curves</li>
</ul></li>
<li>Camera orientation
<ul>
<li>Representation</li>
<li>Look-at</li>
<li>Shortest rotation arc</li>
<li>Roll removal</li>
<li>Twist reduction</li>
<li>Determining angles between desired orientations</li>
</ul></li>
<li>Camera motion
<ul>
<li>Proximity</li>
<li>Damping functions</li>
<li>Springs</li>
<li>Interpolation</li>
</ul></li>
<li>Rendering
<ul>
<li>Camera space/world space/screen space conversions</li>
<li>FOV conversion</li>
<li>Frustum construction</li>
<li>Perspective projection</li>
<li>Orthographic projection</li>
<li>Isometric projection</li>
<li>Axonometric projection</li>
</ul></li>
<li>General camera math
<ul>
<li>Digital filters</li>
<li>Spline curves</li>
<li>Interpolation</li>
</ul></li>
<li>Camera math problems and fixes
<ul>
<li>Floating-point accuracy and precision</li>
<li>Epsilon usage</li>
<li>Base conversion</li>
</ul></li>
</ul>
<h3 id="common-mathematical-techniques">Common Mathematical
Techniques</h3>
<h4 id="look-at">Look-at</h4>
<p>此时通过一个旋转矩阵或四元数把当前的相机朝向变换到新的朝向</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat4 <span class="type">const</span> <span class="title">Mat4::LookAt</span> <span class="params">(Vec3 <span class="type">const</span>&amp; source, Vec3 <span class="type">const</span>&amp; dest, Vec3 <span class="type">const</span>&amp; worldUpVector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Vec3 viewDirection = <span class="built_in">Vece</span> (dest - source).<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  <span class="type">float</span> dot = Vec3::<span class="built_in">Dot</span> (viewDirection, worldUpVector); </span><br><span class="line">  Vec3 unnormalizedUp = worldUpVector - (dot * vewDirection); <span class="comment">// 相机的unnormalized Up axis</span></span><br><span class="line">  Vec3 up = unnormalizedUp.<span class="built_in">AsNormalized</span> ();  <span class="comment">// 相机的up axis</span></span><br><span class="line">  Vec3 right = Vec3::<span class="built_in">Cross</span> (up, viewDirection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// matrix ordering depends on row/column major</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Mat4</span> (</span><br><span class="line">    right[X], viewDirection[X], up[X], source[X],</span><br><span class="line">    right[Y], viewDirection[Y], up[Y], source[Y],</span><br><span class="line">    right[Z], viewDirection[Z], up[Z], source[Z]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上面的变换矩阵是把世界空间中的点变换到相机在（0,0）点的位置</p>
<h4 id="roll-removal">Roll removal</h4>
<p>为了移除roll，我们需要重新计算view transform的right
axis同时保持当前的forward vector，然后可以通过叉乘决定up vector</p>
<h4 id="twist-reduction">Twist reduction</h4>
<p>在三人称相机中，当物体在相机上方或者下方的时候，可能导致相机快速旋转。一个方法是检测相机绕着forward
vector旋转的速度，但是只有在forward vector几乎在和world up
axis平行的时候</p>
<h4 id="world-space-to-screen-space-conversion">World space to screen
space conversion</h4>
<p>取决于projection算法</p>
<ul>
<li>Orthographic projection <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 <span class="type">const</span> ScreenX = ObjectX - ViewportX; <span class="comment">// assumes top left corner is (0,0)</span></span><br><span class="line">uint32 <span class="type">const</span> ScreenY = ViewPortY - ObjectY; <span class="comment">// depends on the direction of +Y</span></span><br></pre></td></tr></table></figure>
如果viewport是显示设备的子集，或者viewport涉及缩放，则必须考虑这些因素：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 <span class="type">const</span> ScreenX = Viewport.ScreenX + (ObjectX - Viewport.WorldX);</span><br><span class="line">uint32 <span class="type">const</span> ScreenY = Viewport.ScreenY + (Viewport.WorldY - ObjectY);</span><br></pre></td></tr></table></figure></li>
<li>Isometric projection <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 <span class="type">const</span> ScreenX = (ObjectX - Viewport.WorldX) * <span class="number">2</span>;</span><br><span class="line">uint32 <span class="type">const</span> ScreenY = Viewport.WorldY - ObjectY;</span><br></pre></td></tr></table></figure></li>
<li>Perspective projection</li>
</ul>
<h4 id="screen-space-to-cameraworld-space-conversion">Screen space to
camera/world space conversion</h4>
<p>通常来说，神都会被设置为相机的近平面，或者一个特定的距离相机的距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">ConvertToWorldSpace</span> <span class="params">(Mat4 <span class="type">const</span>&amp; cameraTransform, Vec3 <span class="type">const</span>&amp; screenPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Vec3 <span class="type">const</span> viewSpace = <span class="built_in">GetProjectionMatrix</span> ().<span class="built_in">Inverted</span> ().<span class="built_in">MultiplyOneOverW</span> (screenSpacePosition);</span><br><span class="line">  Vec3 <span class="type">const</span> worldSpace = cameraTransform * viewSpace;</span><br><span class="line">  <span class="keyword">return</span> worldSpace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fov-conversion">FOV conversion</h4>
<p>考虑把HFOV转化为VFOV，假设我们知道了近平面距离和aspect
ratio，与HFOV</p>
<p>我们定义变量<code>alpha</code>和<code>beta</code>：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha = HFOV / <span class="number">2</span></span><br><span class="line">beta = VFOV / <span class="number">2</span></span><br><span class="line"><span class="built_in">tan</span> (alpha) = (viewport width / <span class="number">2</span>) / near plane distance</span><br><span class="line"><span class="built_in">tan</span> (beta) = (viewport height  / <span class="number">2</span>) / near plane distance</span><br></pre></td></tr></table></figure></p>
<p>从而有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tan</span> (alpha) * near plane distance = viewport width / <span class="number">2</span></span><br><span class="line">Near plane distance = (viewport width / <span class="number">2</span>) / <span class="built_in">tan</span> (alpha)</span><br><span class="line"><span class="built_in">tan</span> (beta) * near plane distance = viewport height / <span class="number">2</span></span><br><span class="line">Near plane distance = (viewport height / <span class="number">2</span>) / <span class="built_in">tan</span> (beta)</span><br></pre></td></tr></table></figure>
<p>进而有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(viewport width / <span class="number">2</span>) * <span class="built_in">tan</span> (beta) = (viewport height / <span class="number">2</span>) * <span class="built_in">tan</span> (alpha)</span><br><span class="line"><span class="built_in">tan</span> (beta) = [(viewport height / <span class="number">2</span>) / (viewport width / <span class="number">2</span>)] * <span class="built_in">tan</span> (alpha)</span><br><span class="line"><span class="built_in">tan</span> (beta) = aspect ratio * <span class="built_in">tan</span> (alpha)</span><br><span class="line">VFOV = <span class="number">2</span> * <span class="built_in">arctan</span> (<span class="built_in">tan</span> (HFOV / <span class="number">2</span>) * aspect ratio)</span><br></pre></td></tr></table></figure>
<p>所以，只要知道了aspect ratio和其中一个FOV，就可以求出另一个FOV</p>
<h3 id="quaternions">Quaternions</h3>
<p>四元数的好处在于可以很方便地插值，且没有Gimbal Lock问题。</p>
<h3 id="bump-and-ease-functions">Bump and Ease Functions</h3>
<p>Bump和ease
functions都用来保证开始和结束的平滑，ease函数分为ease-in和ease-out函数，ease-in函数也叫damping函数。下面讨论几个简单的函数来生成S型曲线</p>
<h4 id="exponentials">Exponentials</h4>
<p>使用简单的三次函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> exp = <span class="number">3</span>t^<span class="number">2</span> - <span class="number">2</span>t^<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="proportional">Proportional</h4>
<p>Proportional ease
function使用当前值和期望值之间的差值作为输入，常用一个damping range：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> deltaValue = desiredValue - currentValue;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(deltaValue) &lt; kRange&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> factor = Math::<span class="built_in">Limit</span> (deltaValue / kRange, <span class="number">1.f</span>);</span><br><span class="line">  currentValue += kSpeed * factor * deltaTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proportional damping
function实现简单且高效，但是可能不如其他方法平滑。另一种方法是根据经过的时间计算factor：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">dampingFactor</span> <span class="params">(<span class="number">1.0f</span> - elapsedTime / totalTime)</span></span>;</span><br><span class="line">interpolant += (destinationValue - interpolant) * dampingFactor * deltaTime;</span><br><span class="line"><span class="keyword">return</span> interpolant;</span><br></pre></td></tr></table></figure></p>
<h4 id="spherical-linear-interpolation">Spherical linear
interpolation</h4>
<p>球面线性插值</p>
<h4 id="transcendentals">Transcendentals</h4>
<p>用三角函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">angle = (pi * time factor) - (pi / 2);  // in radians, -pi/2 ... pi/2</span><br><span class="line">time factor = (sinf(angle) + 1) / 2</span><br></pre></td></tr></table></figure>
<h3 id="springs">Springs</h3>
<p>当实现相机移动的时候我们常常碰到相机overshoot的问题，这是因为目标在不断移动，阻止相机足够快地改变方向、速度以避免被目标对象自身抢占位置，但同时我们也不想相机过快移动，这就导致了矛盾</p>
<p>此时我们可以使用弹簧方案，基于下述的方程：</p>
<p><span class="math display">\[F=-K*X\]</span></p>
<p><span
class="math inline">\(K\)</span>是弹性常量，一个正数表示弹簧的弹性，<span
class="math inline">\(X\)</span>是弹簧伸缩度，这样我们可以写出下面的伪代码：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec3 deltaPosition = desiredPosition - currentPosition;</span><br><span class="line">Vec3 movementDirection = deltaPosition.<span class="built_in">AsNormalized</span> ();</span><br><span class="line"><span class="type">float</span> extension = deltaPosition.<span class="built_in">Magnitude</span> ();</span><br><span class="line"><span class="type">float</span> force = -kSpringConstant * extension; <span class="comment">// for a unit mass, this is acceleration, F = ma</span></span><br><span class="line">Vec3 newVelocity = currentVelocity + (movementDirection * force);</span><br><span class="line"><span class="keyword">new</span> Position = currentPosition + (currentVelocity * deltaTime);</span><br></pre></td></tr></table></figure></p>
<p>弹簧方案的一个问题是设置弹簧的弹性常量，并且会出现震荡现象，这可以用两种思路解决：</p>
<ul>
<li>使用damped spring，控制施加的力使得弹簧接近但永远不会超过目标</li>
<li>使用feedback controller</li>
</ul>
<h3 id="digital-filters">Digital Filters</h3>
<p>在控制器输入或相机移动中，我们想要移除小的震荡，此时可用滤波器</p>
<h4 id="low-pass">Low pass</h4>
<p>低通滤波让低频信号通过，而过滤高频信号</p>
<h4 id="high-pass">High pass</h4>
<p>与低通滤波相反</p>
<h4 id="band">Band</h4>
<p>移除某个频率范围之外的信号</p>
<h4 id="finite-impulse-response">Finite impulse response</h4>
<p>有限脉冲响应滤波在计算当前值的时候结合之前的输入值，因为易于实现，所以与IIR滤波相比更倾向于FIR滤波</p>
<p>History
buffer中的每一项都有一个对应的滤波系数，对应了该项目的影响有多大，即改变对输入值的响应度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">float</span> <span class="type">const</span> firCoefficients[] = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// these values greatly influence the filter</span></span><br><span class="line">  <span class="comment">// response and may be adjusted accordingly</span></span><br><span class="line">  <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span>, <span class="number">4.f</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CFIRFilter::Initialize</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// setup the coefficients for desired response</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mHistoryBuffer.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    mCoefficients[i] = firCoefficients[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CFIRFilter::Update</span> <span class="params">(<span class="type">float</span> <span class="type">const</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// copy the entries in the history buffer up by one</span></span><br><span class="line">  <span class="comment">// position (i.e. lower entries are more recent)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mHistoryBuffer.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// not efficient! Can use circular buffer</span></span><br><span class="line">    mHistoryBuffer[i + <span class="number">1</span>] = mHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  mHistoryBuffer[<span class="number">0</span>] = input;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">fir</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// now accumulate the values from the history</span></span><br><span class="line">  <span class="comment">// buffer multiplied by the coefficients</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &gt; mHistoryBuffer.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    fir += mCoefficients[i] * mHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="infinite-impulse-response">Infinite impulse response</h4>
<p>不同于FIR，IIR也加入了之前的输出值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">CIIRFilter::Initialize</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mInputCoefficients[<span class="number">0</span>] = <span class="number">0.5f</span>;</span><br><span class="line">  mInputCoefficients[<span class="number">1</span>] = <span class="number">0.3f</span>;</span><br><span class="line">  mOutputCoefficients[<span class="number">0</span>] = <span class="number">0.5f</span>;</span><br><span class="line">  mOutputCoefficients[<span class="number">1</span>] = <span class="number">0.3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CIIRFilter::Update</span> <span class="params">(<span class="type">float</span> <span class="type">const</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mInputHistoryBuffer.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// not efficient! Can use circular buffer</span></span><br><span class="line">    mInputHistoryBuffer[i + <span class="number">1</span>] = mInputHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  mInputHistoryBuffer[<span class="number">0</span>] = input;</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> result = </span><br><span class="line">    mInputCoefficients[<span class="number">0</span>] * mInputHistoryBuffer[<span class="number">0</span>] +</span><br><span class="line">    mInputCoefficients[<span class="number">1</span>] * mInputHistoryBuffer[<span class="number">1</span>] +</span><br><span class="line">    mOutputCoefficients[<span class="number">0</span>] * mOutputHistoryBuffer[<span class="number">0</span>] +</span><br><span class="line">    mOutputCoefficients[<span class="number">1</span>] * mOutputHistoryBuffer[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mOutputHistoryBuffer.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// not efficient! Can use circular buffer</span></span><br><span class="line">    mOutputHistoryBuffer[i + <span class="number">1</span>] = mOutputHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  mOutputHistoryBuffer[<span class="number">0</span>] = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spline-curves">Spline Curves</h3>
<p>Spline由一系列控制点和对应的tangent
vector控制，每个segment通常由两个控制点组成，每个控制点有1~2个切线向量。相邻两个segment之间共享的控制点叫做joint</p>
<h4 id="camera-spline-usage">Camera spline usage</h4>
<p>相机Spline的通常用法是定义一条路径，再用一个evaluation函数将时间映射到路径上的位置。二维spline通常用来表示物体的属性，三维spline通常用来表示空间位置</p>
<h4 id="cubic-polynomials">Cubic polynomials</h4>
<p>三次多项式可以表示为：</p>
<p><span class="math display">\[Y=Ax^3+Bx^2+Cx+D\]</span></p>
<p>有时候需要给定<span class="math inline">\(Y\)</span>解出<span
class="math inline">\(x\)</span></p>
<h4 id="spline-types">Spline types</h4>
<p>下面介绍几种不同的spline types:</p>
<ul>
<li>Linear: 一系列直线，用下面的代码计算位置 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">Linear</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + ((<span class="number">1.f</span> - time) * <span class="built_in">Vec3</span> (b - a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Piecewise Hermite:
Hermite曲线要求两个控制前和两个切线，每个控制点一条切线。我们也可以为每个控制点引入两条切线——in-tangent和out-tangent，很多动画系统用这种方法
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Vec3 <span class="title">Hermit</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; startTangent, Vec3 <span class="type">const</span> &amp; endTangent, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (u &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t2</span> <span class="params">(time * time)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t3</span> <span class="params">(t2 * time)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate basis functions</span></span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> a0 = (t3 * <span class="number">2.0f</span>) - (<span class="number">3</span> * t2) + <span class="number">1.0f</span>;</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> a1 = (<span class="number">-2.0f</span> * t3) + (<span class="number">3.0f</span> * t2);</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> b0 = t3 - (<span class="number">2.0f</span> * t2) + u;</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> b1 = t3 - t2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use cubic basis functions with points and tangents</span></span><br><span class="line">  <span class="function">Vec3 <span class="type">const</span> <span class="title">result</span> <span class="params">((a0 * a) + (a1 * b) + (b0 * startTangent) + (b1 * endTangent))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Catmull-Rom: Catmull-Rom spline
C1连续、局部控制，但是并不位于控制点形成的convex hull中
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">CatmullRom</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">if</span> (time &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="type">const</span> t2 = time * time;</span><br><span class="line">    <span class="type">float</span> <span class="type">const</span> t3 = t2 * time;</span><br><span class="line"></span><br><span class="line">    Vec3 <span class="type">const</span> result = (a * (<span class="number">-0.5f</span> * t3 + t2 - <span class="number">0.5f</span> * time) +</span><br><span class="line">                         b * (<span class="number">1.5f</span> * t3 - <span class="number">2.5f</span> * t2 + <span class="number">1.0f</span>) +</span><br><span class="line">                         c * (<span class="number">1.5f</span> * t3 + <span class="number">2.0f</span> * t2 + <span class="number">0.5f</span> * time) +</span><br><span class="line">                         d * (<span class="number">0.5f</span> * t3 - <span class="number">0.5f</span> * t2));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Rounded Catmull-Rom: 能够决定两个控制点中间曲线的速度
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">RoundedCatmullRom</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">if</span> (time &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find velocities at b and c</span></span><br><span class="line">  Vec3 <span class="type">const</span> cb = c - b;</span><br><span class="line">  <span class="keyword">if</span> (!cb.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  Vec3 ab = a - b;</span><br><span class="line">  <span class="keyword">if</span> (!ab.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    ab = <span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  Vec3 bVelocity = cb.<span class="built_in">AsNormalized</span> () - ab.<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  <span class="keyword">if</span> (bVelocity.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    bVelocity.<span class="built_in">Normalize</span> ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bVelocity.<span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  Vec3 dc = d - c;</span><br><span class="line">  <span class="keyword">if</span> (!dc.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    dc = <span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  Vec3 bc = -cb;</span><br><span class="line">  Vec3 cVelocity = dc.<span class="built_in">AsNormalized</span> () - bc.<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  <span class="keyword">if</span> (cVelocity.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    cVelocity.<span class="built_in">Normalize</span> ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bVelocity = <span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> cbDistance = cb.<span class="built_in">Magnitude</span> ();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CatmullRom</span> (b, c, bVelocity * cbDistance, cVelocity * cbDistance, time);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Kochanek-Bartels splines: KB spline是CR
spline的扩展，因为引入了其他的参数来控制spline的曲率。有三个参数：
<ul>
<li>Bias:
控制每个tangent的方向，-1使曲线提早buckle，+1使曲线buckle到末尾</li>
<li>Tension: 控制每个tangent vector的长度，
+1导致更紧的曲线，-1导致更圆的曲线，如果大于+1则产生环</li>
<li>Continuity:
控制tangents之间的角度，-1使曲线向里buckel，+1使边角朝向相反方向
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">KBSpline</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">float</span> <span class="type">const</span> tension, <span class="type">float</span> <span class="type">const</span> continuity, <span class="type">float</span> <span class="type">const</span> bias)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// tension, continuity ans bias defined per segment</span></span><br><span class="line">  Vec3 <span class="type">const</span> ab = <span class="built_in">Vec3</span> (b - a).<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  Vec3 <span class="type">const</span> cd = <span class="built_in">Vec3</span> (d - c).<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  Vec3 <span class="type">const</span> inTangent = ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> - continuity) * (<span class="number">1.f</span> + bias)) * <span class="number">0.5f</span> * ab +</span><br><span class="line">  ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> + continuity) * (<span class="number">1.f</span> - bias)) * <span class="number">0.5f</span> * cd;</span><br><span class="line">  Vec3 <span class="type">const</span> outTangent = ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> + continuity) * (<span class="number">1.f</span> + bias)) * <span class="number">0.5f</span> * ab +</span><br><span class="line">  ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> - continuity) * (<span class="number">1.f</span> - bias)) * <span class="number">0.5f</span> * cd;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">PiecewiseHermite</span> (b, c, inTangent, outTangent, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果所有参数都为零，则退化为CR spline</li>
</ul></li>
<li>Bézier: 二次贝塞尔曲线方程为</li>
</ul>
<p><span class="math display">\[a(1-t)^2+b(2t)(1-t)+ct^2\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">QuadraticBezier</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">oneMinusTime</span> <span class="params">(<span class="number">1.f</span> - time)</span></span>;</span><br><span class="line">  Vec3 <span class="type">const</span> bezier = (a * oneMinusTime * oneMinusTime) + (b * <span class="number">2.f</span> * time * oneMinusTime) + (c * time * time);</span><br><span class="line">  <span class="keyword">return</span> bezier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三次贝塞尔曲线方程为：</p>
<p><span
class="math display">\[a(1-t)^3+b(3t)(1-t)^2+c(3t^2)(1-t)+dt^3\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">CubicBezier</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">oneMinusTime</span> <span class="params">(<span class="number">1.f</span> - time)</span></span>;</span><br><span class="line">  Vec3 <span class="type">const</span> bezier = (a * oneMinusTime * oneMinusTime * oneMinusTime) + (b * <span class="number">3.f</span> * time * oneMinusTime * oneMinusTime) + (c * <span class="number">3.f</span> * time * time * oneMinusTime) + (d * time * time * time);</span><br><span class="line">  <span class="keyword">return</span> bezier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Uniform cubic B-spline: B spline是一种泛化的Bezier
spline，一个好处是它有local
control，即：每个控制点只会影响整个曲线的一小部分，它使用下述的blending
function</li>
</ul>
<p><span class="math display">\[S_i(t)=\frac{1}{6}\begin{bmatrix}
  t^3 &amp; t^2 &amp; t &amp; 1
\end{bmatrix}
\begin{bmatrix}
  -1 &amp; 3 &amp; -3 &amp; 1\\
  3 &amp; -6 &amp; 3 &amp; 0\\
  -3 &amp; 0 &amp; 3 &amp; 0\\
  1 &amp; 4 &amp; 1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
  P_{i-3}\\
  P_{i-2}\\
  P_{i-1}\\
  P_i
\end{bmatrix}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">BSpline</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t2</span> <span class="params">(time * time)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t3</span> <span class="params">(t2 * time)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Vec3 <span class="type">const</span> <span class="title">result</span> <span class="params">((a * (-t3 + (<span class="number">3</span> * t2) + (<span class="number">-3</span> * time) + <span class="number">1</span>)) +</span></span></span><br><span class="line"><span class="params"><span class="function">                   (b * ((<span class="number">3</span> * t3) + (<span class="number">-6</span> * t2) + <span class="number">4</span>)) +</span></span></span><br><span class="line"><span class="params"><span class="function">                   (c * ((<span class="number">-3</span> * t3) + (<span class="number">3</span> * t2) + (<span class="number">3</span> * time) + <span class="number">1</span>)) +</span></span></span><br><span class="line"><span class="params"><span class="function">                   (d * t3))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> (result / <span class="number">6.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Non-uniform rational B-spline</li>
</ul>
<h4 id="continuity">Continuity</h4>
<p>C0是位置连续，C1是速度连续，C2是加速度连续。所以C1或更高的连续会在视觉上效果更好，C2或更高的连续会有更平滑的移动</p>
<h4 id="spline-definitions">Spline definitions</h4>
<p>为了充分地定义spline curve，我们需要几个机制：</p>
<ul>
<li>一个能够在游戏世界放置控制点的编辑器，甚至可以在游戏运行的时候生成</li>
<li>Spline evaluation type</li>
<li>跨国spline的总的时间或一个映射函数</li>
<li>一个可视化展示spline curve的界面，随参数改变动态变化</li>
</ul>
<h4 id="spline-evaluation">Spline evaluation</h4>
<p>可以预先计算整个spline的长度，然后用一个线性长度作为spline上的位置。如果再搭配速度damping则会产生比较平滑的效果</p>
<h4 id="control-point-generation">Control point generation</h4>
<ul>
<li>单个控制点：总是返回这个点</li>
<li>两个控制点：要提供额外的tangent信息，否则无法确定曲线</li>
<li>三个控制点：可以外推第四个控制点</li>
</ul>
<h4 id="parameterized-arc-length">Parameterized arc length</h4>
<p>积分法</p>
<h4 id="total-spline-length">Total spline length</h4>
<p>总长度是各个spline弧长度的和，往往采用数值方法近似曲线长度</p>
<h4 id="closest-position">Closest position</h4>
<p>计算spline上离某个位置最近的点往往很有用，但问题是可能有多个解，这时候就需要对这些解做个排序，比如考虑相机的前一个位置或者LOS，或者相机的角速度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Determine the nornal at each end of the segment and by using similar triangles</span><br><span class="line">Determine the length on the segment</span><br><span class="line">If length within 0..1 then</span><br><span class="line">  Convert linear 0..1 into a parametric value</span><br><span class="line">  With parametric value 0..1 find the position within the arc using the usual spline evaluation</span><br><span class="line">  Check position against source position for LOS and other factors</span><br><span class="line">  If OK, determine the physical distance between two points and compare to current &quot;best&quot;</span><br><span class="line">Else</span><br><span class="line">  Not within segment, so proceed to next segment</span><br></pre></td></tr></table></figure>
<h4 id="spline-editing">Spline editing</h4>
<p>开发能够编辑spline的工具</p>
<h3 id="interpolation">Interpolation</h3>
<p>线性插值在一对数据点中生成新数据，piecewise插值则是由几个连续的数据点去生成。相机朝向往往用非线性插值</p>
<h3 id="camera-property-interpolation">Camera Property
Interpolation</h3>
<h4 id="position-interpolation">Position interpolation</h4>
<p>位置插值应该是基于当前的位置和目标位置，用这个距离相比于原来的距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec3 interpFactor = CMath::<span class="built_in">Clamp</span> (<span class="number">0.0f</span>, interpTimer/maxInterpTime, <span class="number">1.0f</span>);</span><br><span class="line">Vec3 currentDeltaPosition = desiredPosition - <span class="built_in">GetTranslation</span> ();</span><br><span class="line">Vec3 newPosition = <span class="built_in">GetTranslation</span> () + (currentDeltaPostion * interpFactor);</span><br><span class="line"><span class="comment">// when interpTimer reaches maxInterpTime, the camera reaches the destination</span></span><br></pre></td></tr></table></figure>
<h4 id="orientation-interpolation">Orientation interpolation</h4>
<p>朝向插值通常不涉及roll，即使需要考虑roll，也会单独处理</p>
<p>由于小的朝向改变会引起巨大的视觉变化，所以一定要确保朝向插值的平滑。线性插值并不保证对象一定在视野里。如果朝向改变很大，要限制角速度，或者使用jump
cut。朝向插值也要保证路径最短</p>
<ul>
<li>Orientation interpolation by angle: NLerp, Slerp,
Squad。基于角度的插值的一个缺点是：相机可能会看得远离目标物体，取决于变化的速度。这可能发生在原相机和目标相机都看向同一点，此时在插值的过程中相机会偏离目标点</li>
<li>Orientation interpolation by target position:
可以用基于目标位置的插值保证目标始终在视野内，但此时朝向速度的变化非常重要</li>
<li>Orientation interpolation characteristics:
当前朝向和期望朝向之间的角度要随着插值越来越小，可以通过两个方法实现：（1）反向计算从目标朝向到当前朝向；（2）保证当前插值角小于等于前一步插值角，如果因为目标朝向改变导致角度增大，则使用前一个插值相机的朝向，一旦插值相机朝向接近目标朝向，则把朝向锁定</li>
<li>Roll interpolation:
用最短方向插值roll，但一般来说roll只用于短时间的相机效果</li>
</ul>
<h4 id="fov-interpolation">FOV interpolation</h4>
<p>如果没有其他渲染效果，那么只改变FOV就显得很突兀，快速的FOV改变会让玩家不适，这时候一个jump
cut反而更好。zoom in也是通过FOV实现的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> targetFOV = <span class="built_in">GetTargetFOV</span> ();</span><br><span class="line"><span class="type">float</span> deltaFOV = mFOV - targetFOV;</span><br><span class="line"><span class="type">float</span> newFOV = targetFOV + (deltaFOV * deltaTime);</span><br><span class="line"><span class="type">float</span> newDeltaFOV = newFOV - targetFOV;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">absF</span>(newDeltaFOV) &lt; <span class="built_in">absF</span>(deltaFOV))</span><br><span class="line">&#123;</span><br><span class="line">  mFOV = newFOV; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="viewport-interpolation">Viewport Interpolation</h3>
<p>改变显示设备的大小，通常用于cinematic sequences和regular game
play之间的转换。比如从2.35:1到1.33:1</p>
<h3 id="player-control-interpolation">Player Control Interpolation</h3>
<h4 id="first-person-cameras">First person cameras</h4>
<p>control interpolation通常用于从一个第一人称control reference
frame变化到一个fixed control reference frame比如object orbiting</p>
<h4 id="third-person-cameras">Third person cameras</h4>
<p>在很多情况下，我们要保证如果相机出现巨大移动，则玩家控制不会马上改变</p>
<p>一个问题是如何处理玩家移动比相机移动快的问题，而且玩家绕着相机垂直轴的任何移动会导致相机绕着该轴的快速转动</p>
<h3 id="interpolation-choices">Interpolation Choices</h3>
<p>首先要问现有的数据是kay value还是control
values；第二，要考虑插值方法的效率和效果；第三，要考虑插值结果的平滑性；最后，也要考虑不同插值方法需要的数据量</p>
<h4 id="linear-interpolation">Linear interpolation</h4>
<p>线性插值只需要三个参数：source value, destination
value和interpolation method</p>
<p>Destination value往往会随时间改变，我们就需要考虑到destination
value的变化率，当插值的变化率不匹配目标值的变化率时，不连续就会发生</p>
<p>插值方法需要考虑是否要用固定的时间完成插值。不考虑变化率会在开始和结束时产生不连续现象</p>
<h4 id="piecewise-interpolation">Piecewise interpolation</h4>
<p>通常有多于两个数据点进行插值，一种策略是把它们视为独立的interpolation
segments： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">foundTime</span> <span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; valueTimes.<span class="built_in">Size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (valueTimes[i+<span class="number">1</span>] &gt; time)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">float</span> timeDelta = valueTimes[i+<span class="number">1</span>] - valueTimes[i];</span><br><span class="line">    timeFactor = (time - valueTimes[i]);</span><br><span class="line">    segment = i;</span><br><span class="line">    source = values[i];</span><br><span class="line">    destination = values[i+<span class="number">1</span>];</span><br><span class="line">    foundTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (foundTime)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Interpolate</span> (source, destination, timeFactor);</span><br></pre></td></tr></table></figure></p>
<p>此外，也可以在每对数据点中假设均匀时间区间，但会有比较大的问题</p>
<h3 id="methods-of-interpolation">Methods of Interpolation</h3>
<h4 id="linear-time-interpolation">Linear time interpolation</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interpolated value = source + ((destination - source) * t)</span><br></pre></td></tr></table></figure>
<h4 id="parametric-functions">Parametric functions</h4>
<p>比如ease函数</p>
<h4 id="spherical-linear-interpolation-1">Spherical linear
interpolation</h4>
<p>用于角的插值</p>
<h3 id="potential-interpolation-problems">Potential Interpolation
Problems</h3>
<h4 id="aesthetic-problems">Aesthetic problems</h4>
<p>一些视觉上的问题包括：</p>
<ul>
<li>Geometry interpenetration</li>
<li>Discontinuities</li>
<li>Interpolation noise</li>
<li>Target object framing</li>
<li>Large orientation changes</li>
<li>Large interpolation distances</li>
</ul>
<h4 id="mathematical-problems">Mathematical problems</h4>
<p>数学上的问题一般是由浮点误差导致的：</p>
<ul>
<li>Co-linear (or exactly opposed) orientation</li>
<li>Coincident positions: 0为除数</li>
<li>Floating-point inaccuracy</li>
</ul>
<h3 id="interruption-of-interpolation">Interruption of
Interpolation</h3>
<p>有可能在一个插值过程中触发了另一个插值，这时候可以从当前值开始直接开始新的插值</p>
<h3 id="transitions">Transitions</h3>
<h4 id="position-during-transitions">Position during transitions</h4>
<h4 id="orientation-during-transitions">Orientation during
transitions</h4>
<p>有两种方法在transition的过程中控制插值相机的朝向，如果source和des相机没有reorienting，那么简单的线性插值或slerp可以处理得很好，但如果有一个或者两个都reorient就会有问题。一个方法是计算从目标值到当前值之间得剩余量（比如角度），如果新的插值大于当前值，则忽略</p>
<h3 id="camera-math-problems">Camera Math Problems</h3>
<h4 id="floating-point-precision">Floating-point precision</h4>
<p>相机系统一般用单精度浮点数，所以不能表示很大的数</p>
<h4 id="epsilon-usage">Epsilon usage</h4>
<p>要根据用途改变epsilon的值</p>
<h4 id="compiler-differences">Compiler differences</h4>
<p>编译器也有不同</p>
<h4 id="hardware-fpu-differences">Hardware FPU differences</h4>
<h4 id="vector-normalization">Vector normalization</h4>
<h4 id="matrix-concatenation-floating-point-drift">Matrix concatenation
floating-point drift</h4>
<p>在应用旋转矩阵后，正交化该矩阵以保证浮点精确度</p>
<h3 id="periodic-camera-mathematical-fixes">Periodic Camera Mathematical
Fixes</h3>
<p>最好在渲染之前检查当前的相机变换是不是正确的，包括：</p>
<ul>
<li>变换矩阵的每个元素不包含异常值，比如NaN</li>
<li>变换矩阵的每个向量都是单位向量</li>
<li>Up-vector和游戏内的Up-vector一致</li>
<li>必要时移除roll</li>
<li>必要时限制相机快速的reorientation</li>
</ul>
<p>如果矩阵不能被修复，则使用上一帧的矩阵；记得多正交化矩阵</p>
<h2 id="chapter-11-implementation">Chapter 11: Implementation</h2>
<h3 id="game-engine-architecture">Game Engine Architecture</h3>
<h4 id="game-update-loop">Game update loop</h4>
<p>大多数相机逻辑都要在其他逻辑之后执行，典型的执行顺序是：</p>
<ul>
<li>Process input</li>
<li>Process pre-logic on game objects</li>
<li>Process main logic (AI, etc.) on game objects</li>
<li>Move game objects and resolve collisions</li>
<li>Process all camera logic</li>
<li>Process post-camera logic for objects (such as dependencies on
camera position, orientation, etc.)</li>
<li>Process all viewport logic</li>
<li>Render scene for each viewport</li>
</ul>
<h4 id="game-system-managers">Game system managers</h4>
<p>一些管理系统包括：</p>
<ul>
<li>Camera manager:
跟踪所有的相机，传递输入、确保每个都得到正确更新</li>
<li>Object manager: 管理游戏中的每个对象，保证逻辑处理顺序正确</li>
<li>Message manager</li>
<li>Audio manager: 通过它控制音效的变化</li>
<li>Input manager: 将输入信息传递给所有需要的游戏对象</li>
</ul>
<h4 id="delta-time">Delta time</h4>
<p>现在游戏通常将逻辑层与渲染层分开，这有利于CPU处理和GPU渲染，游戏逻辑可能以固定的速率更新，也可能以动态的速度更新，从而，相邻两次更新的时间间隔不一定一致，经过的时间就称为delta
time</p>
<h4 id="input-processing">Input processing</h4>
<p>很多相机需要把输入值传递给它们，这通常由相机管理器实</p>
<h3 id="camera-system-architecture">Camera System Architecture</h3>
<h4 id="viewport-manager">Viewport manager</h4>
<p>主要工作是包含所有在场景内需要渲染的东西，处理控制器输入、渲染、masking、buffer管理、aspect
ratio等等，能够被其他游戏系统用于访问关于当前活跃相机的相机系统。数据结构是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CViewportManager</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> int32 TViewportHandle;</span><br><span class="line">    <span class="function">TViewportHandle <span class="type">const</span> <span class="title">CreatViewport</span> <span class="params">(EViewportType)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeleteViewport</span> <span class="params">(TViewportHandle <span class="type">const</span> viewport)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span> <span class="params">(<span class="type">float</span> <span class="type">const</span> deltaTime)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessInput</span> <span class="params">(CInput <span class="type">const</span> &amp; input)</span></span>;</span><br><span class="line">    <span class="function">CViewport <span class="type">const</span> &amp; <span class="title">GetViewport</span> <span class="params">(TViewportHandle <span class="type">const</span> handle)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了显示媒介之后，我们需要描述投影，因此VM需要：</p>
<ul>
<li>Accessors for viewports</li>
<li>Render all viewports</li>
<li>Input handler</li>
<li>Create a new viewport</li>
<li>Activate or deactivate an existing viewport</li>
<li>Delete an existing viewport</li>
<li>Transition (morph) between two viewports</li>
<li>Change viewport properties</li>
<li>Assign an active camera for a viewport</li>
</ul>
<p>每个Viewport都控制了所有需要渲染的信息，比如相机、控制器输入、surface
locatio and
size、渲染模式等等，甚至还包含了用于多种输出设备渲染需要的信息</p>
<p>VM还处理不同viewport之间的过渡，通常用于玩家在菜单界面、暂停时，或者画中画。Transition可能包括：</p>
<ul>
<li>Cut</li>
<li>Wipe</li>
<li>Cross fade</li>
<li>Morphing</li>
</ul>
<h4 id="render-manager">Render manager</h4>
<p>从当前的viewports和cameras获取数据并渲染，此外会移除frustum外的的物体，决定渲染顺序，应用后处理</p>
<h4 id="camera-manager">Camera manager</h4>
<p>CM的主要责任是扮演所有相机的控制器，生成相机新实例、处理转场、插值、优先级、控制器输入、replay
modes和时间控制</p>
<p>CM有Update函数，处理步骤是：</p>
<ul>
<li>决定哪个相机需要开始或结束</li>
<li>更新活动相机的逻辑（插值相机最后）</li>
<li>传递控制器输入</li>
<li>更新audio系统的位置和速度信息</li>
<li>设置渲染环境</li>
</ul>
<h4 id="camera-update-loop">Camera update loop</h4>
<p>相机一般是下面的更新逻辑：</p>
<ul>
<li>Updating active cameras</li>
<li>Update camera scripting</li>
<li>Input processing</li>
<li>Pre-think logic</li>
<li>Think ordering</li>
<li>Cinematic camera deferral: 一般来说，cinematic cameras会在一个update
loop的最开始start，而在update loop的最后结束</li>
<li>Post-think logic</li>
<li>Update audio logic</li>
<li>Debug camera</li>
<li>Render setup</li>
</ul>
<h4 id="hint-manager">Hint manager</h4>
<p>每个CM都有一个与之关联的camera hint manager (CHM)</p>
<h4 id="shake-manager">Shake manager</h4>
<p>相机震动一般发生在渲染阶段而不是实际移动相机，因为这可能导致相机穿过物体。Shake
transform在局部相机空间中计算应用在渲染之前</p>
<p>相机震动有三个组件：</p>
<ul>
<li>Sine wave</li>
<li>Amplitude mapping: 把时间映射为每个axis上的振幅</li>
<li>Random noise</li>
</ul>
<h3 id="game-cameras">Game Cameras</h3>
<h4 id="inherited-camera-behaviors">Inherited camera behaviors</h4>
<p>可以用下面的层级去实现相机类：</p>
<ul>
<li>Actor</li>
<li>Camera</li>
<li>Third Person
<ul>
<li>Slaved</li>
<li>Observer</li>
<li>Path</li>
<li>Surface</li>
<li>Stationary</li>
<li>Transition</li>
<li>Interpolation</li>
<li>Debug</li>
</ul></li>
<li>First Person</li>
</ul>
<h4 id="component-based-camera-behaviors">Component-based camera
behaviors</h4>
<p>不用类继承的方式，另一种方法是使用component-based相机。任何相机的属性都可以拆分为一些可交换的组件，称为behavior，这些behavior能够在运行时组合或交换以产生很多相机变体。一些behavior包括：</p>
<ul>
<li>Determination of the desired position of the camera</li>
<li>Movement toward the desired position including both collision
determination and response</li>
<li>Orientation determination</li>
<li>Rotation toward a desired orientation</li>
<li>Interpolation</li>
<li>Field of view</li>
<li>The rendering effects to apply to this particular camera's view</li>
</ul>
<p>尽管单个component从设计上讲是独立的，但是可能某个特定的component，比如orientation，依赖于其他component的状态，所以需要有特定的component更新顺序</p>
<h4 id="cinematic-cameras">Cinematic cameras</h4>
<p>通常会把cinematic camera与game
camera分开考虑，有自己独立的viewport</p>
<h4 id="debug-camera">Debug camera</h4>
<p>只用于render</p>
<h3 id="scripting-system-implementation">Scripting System
Implementation</h3>
<h4 id="camera-script-objects">Camera script objects</h4>
<p>有时候需要动态改变相机行为，这就是scripting，一些script
objects包括：</p>
<ul>
<li>Camera hints: camera hints通常只是简单的data
repositories，并不要求实际逻辑，除了活跃状态的更新</li>
<li>Trigger volumes</li>
<li>Rendering/lighting effects:
一些渲染效果可以通过给相机发消息实现，或者相机检验游戏状态，或者激活带有特殊效果的相机</li>
<li>Message replay: 引入relay可以使只有一个script object更新</li>
<li>Sequenced event timer:
定义多个游戏事件，它们按照特定的顺序和时间间隔发生</li>
<li>Generic path: 只用一个script object定义path且能够evaluate</li>
</ul>
<h4 id="ordering-of-scripting-logic">Ordering of scripting logic</h4>
<p>如果scripting
logic引起任何需要发送的消息，则它们会立即发送给接收者，但是可能此时接收者已经执行了自己的逻辑，所以要等到下个update时才能做出对当前消息的反应，可以把message
cache</p>
<h4 id="messaging">Messaging</h4>
<p>当事件发生时，需要通知其他游戏物体事件的发生，这一般用messaging
system实现。实际的消息只包含了与该事件有关的信息，比如发送消息的物体、消息本身、其他可能触发该消息的物体</p>
<p>比如当玩家进入trigger volume时，会让对应的script
object发送一个enter消息、是谁发送的消息</p>
<h4 id="prioritization">Prioritization</h4>
<p>可用一个整数代表优先级，也可以用属性表示优先级，比如和玩家之间的距离</p>
<h4 id="interpolation-1">Interpolation</h4>
<p>可以用一个专门的interpolation camera管理相机插值</p>
<h3 id="performance-considerations">Performance Considerations</h3>
<h4 id="amortization">Amortization</h4>
<p>一般用于缓存几个update内的中间值，但相机移动需要立即执行。在采用amortization之前，需要考虑哪些属性不需要每次update都更新，哪些属性需要立即更新</p>
<h4 id="preprocessing">Preprocessing</h4>
<p>大多数的相机CPU消耗都用于ray
casting或碰撞检测，预处理，如沿着特定轨道的相机移动，可以减少CPU开销</p>
<h3 id="tools-support">Tools Support</h3>
<h4 id="world-editor">World editor</h4>
<p>大多数常用的属性都以易用的界面实现，比如camera path definition,
camera hint placement，property editing， pre-defined macros of script
objects:</p>
<ul>
<li>Placement/orientation of cameras</li>
<li>Camera property editing</li>
<li>View from the camera while manupulating</li>
<li>Editing in-game then transferring data back</li>
<li>Limit properties shown to those appropriate for behavior</li>
<li>Paths -- automatic waypoint dropping and connections</li>
<li>Volumes: this is the ability to define 3D regions for various
camera-related functionality</li>
<li>Surfaces: defining surfaces for cameras to move on, for example</li>
<li>Links to target objects: identifying target objects for particular
cameras</li>
<li>Control of position/orientation/roll/fov over time (spline
editor)</li>
<li>Evaluation of target object or interpolant derivation over time:
shows where an object will be located over time in case it has an impact
on the camera behavior</li>
</ul>
<h4 id="camera-collision-mesh">Camera collision mesh</h4>
<p>Camera有自己的collision geometry会更方便，因为可以允许动态改变</p>
<h3 id="camera-debugging-techniques">Camera Debugging Techniques</h3>
<h4 id="interactive-debugging">Interactive debugging</h4>
<p>Interactive debugging包括：</p>
<ul>
<li>Internal property interrogation: 直接看相机数据</li>
<li>Separate debugging camera: 维护一个单独的debug
camera，只在开发环境中使用。当使用debug
camera时，支持某些行为很有用，包括：把角色放置在当前相机位置、展示当前相机位置、从当前相机位置投射射线决定环境属性、暂停游戏运行允许操纵debug
camera、捕捉当前渲染buffer并导出</li>
<li>Control of the update rate of the game:
改变游戏的更新率，尤其是单词更新</li>
<li>General camera state: 跟踪一些相机的事项，包括：state information
(active, interpolating, under player control, etc.), script messaging,
changes to active camera hints/game cameras, occlusion state and the
amount of time occluded, fail-safe activation, invalid camera properties
including the validity of the transformation matrix</li>
<li>Visual representation of camera properties:
可视化相机的一些属性，比如用wireframe sphere or
cube展示相机移动，相机朝向、期望看向点、期望朝向</li>
<li>Property hysteresis: 有时候需要查看相机属性的历史记录，比如camera
position (known as breadcrumbs), camera orientation (display orientation
changes as points on the surface of a unit sphere)</li>
<li>Movement constraints: movement path drawing, based on spline curve
evaluations and represented by an approximation of line segments;
movement surface drawing</li>
<li>Line of sight:
沿着forward画线，同时用颜色标记状态，比如红色表示受到阻挡，还可以显示阻挡物体的材质，比如stone,
ceiling等等</li>
<li>Behavior-specific rendering</li>
<li>Script debugging: script statment execution/filtering, debug message
logging, messaging filtering, object state</li>
</ul>
<h4 id="data-logging">Data logging</h4>
<p>注意logging对游戏性能的影响，一个优化是cache日志信息直到某个不影响游戏性能的时间点</p>
<p>在获取log之后，除了直接阅读文本之外，还可以采用可视化的手段，把数据导入游戏复盘相机数据</p>
<h4 id="game-replaying">Game replaying</h4>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>Sulley
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://sulley.cc/2022/05/05/21/40/" title="《Real-Time Cameras》笔记">http://sulley.cc/2022/05/05/21/40/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag"># 随笔</a>
              <a href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag"># 游戏</a>
              <a href="/tags/%E7%9B%B8%E6%9C%BA/" rel="tag"># 相机</a>
              <a href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag"># 设计</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/27/08/38/" rel="prev" title="Motion Matching -- 概念与发展">
                  <i class="fa fa-chevron-left"></i> Motion Matching -- 概念与发展
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/21/23/40/" rel="next" title="根据角色体型和俯角自动确定FreeLook镜头参数">
                  根据角色体型和俯角自动确定FreeLook镜头参数 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sulley</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">273k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:08</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"littlesulley","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
