<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>An Introduction to Reservoir Sampling (with Pseudo Code)</title>
    <url>/2023/05/28/17/00/</url>
    <content><![CDATA[<p>Given a stream of data formalized as <span class="math inline">\(x_1,
x_2, \cdots, x_n, \cdots\)</span>, how will you randomly sample <span
class="math inline">\(k\)</span> of them when this stream ends.
Apparently you cannot wait for the stream to end and cache all data due
to a underlying prohibitively large data scale, neither can you sample
new <span class="math inline">\(k\)</span> pieces of data at each
incoming step. Can we do this incrementally and guarantee that the
sampled data are fully uniform? Yes, this leads us to the algorithm of
Reservoir Samping.</p>
<span id="more"></span>
<h1 id="problem-definition">Problem Definition</h1>
<p>Let me first give a formal definition to our problem:</p>
<blockquote>
<p>Let <span class="math inline">\(\{x_n\}\)</span> be a stream of data
records where its length is unknown in advance. When the data stream
finishes, return a set of <span class="math inline">\(k\)</span> data
records uniformly sampled from <span
class="math inline">\(\{x_n\}\)</span>.</p>
</blockquote>
<p>The most trivially solution is to store all data records and sample
<span class="math inline">\(k\)</span> indices from the index set <span
class="math inline">\(\{1, 2, \cdots, n\}\)</span>. But this is
intractably storage-expensive as <span
class="math inline">\(\{x_n\}\)</span> may exceed the maximum storaget
limitation.</p>
<p>Can we procedurally take samples without caching each incoming data
record? The answer is yes. I will introduce three common solutions in
the following sections, including the famous <em>Reservoir Sampling</em>
algorithm.</p>
<h1 id="priority-queue">Priority Queue</h1>
<h2 id="theory">Theory</h2>
<p>When current incoming index <span class="math inline">\(i\le
k\)</span>, we just need to keep this data record <span
class="math inline">\(x_i\)</span> and put it into the result set <span
class="math inline">\(\mathcal{R}\gets\mathcal{R}\cup\{x_i\}\)</span>.
When the index <span class="math inline">\(i&gt;k\)</span>, we must
decide whether or not this data record should be stored into <span
class="math inline">\(\mathcal{R}\)</span> and which existing data
record in <span class="math inline">\(\mathcal{R}\)</span> should be
replaced by <span class="math inline">\(x_i\)</span>.</p>
<p>Because we want to <strong>uniformly</strong> sample data records, we
can assign a unique <strong>uniform value</strong> <span
class="math inline">\(u_i\)</span> sampled from <span
class="math inline">\(\mathcal{U}[0,1]\)</span> to each incoming data
record and compare this value to those already stored <span
class="math inline">\(k\)</span> smallest values, denoted by <span
class="math inline">\(\mathcal{P}=\{u_{j_1},u_{j_2},\cdots,
u_{j_k}\}\)</span>. If <span class="math inline">\(u_i\)</span> is
smaller than the largest of <span
class="math inline">\(\mathcal{P}\)</span>, the newly sampled value
<span class="math inline">\(u_i\)</span> will be inserted into <span
class="math inline">\(\mathcal{P}\)</span>, and the old largest value
will be pruned out.</p>
<p>The theory behind is simple:</p>
<blockquote>
<p>Given <span class="math inline">\(n\)</span> random variables sampled
from <span class="math inline">\(\mathcal{U}[0,1]\)</span>, the indices
of the smallest <span class="math inline">\(k\)</span> of them is a
uniform sample of the <span class="math inline">\(k\)</span>-subsets of
<span class="math inline">\(\{1, 2, \cdots, n\}\)</span>.</p>
</blockquote>
<p>How can we efficiently insert a new value and maintain the largest
one? Priority queue, or maximum heap serves our purpose well. By
definition, we can maintain a priority queue <span
class="math inline">\(\mathcal{P}\)</span> of size <span
class="math inline">\(k\)</span> and at each incoming step we sample a
value from <span class="math inline">\(\mathcal{U}[0,1]\)</span>. If the
sampled value is smaller than the largest in <span
class="math inline">\(\mathcal{P}\)</span>, we remove the largest and
insert the new one as well as the associated data record, which can be
done using a pair.</p>
<h2 id="pseudo-code">Pseudo-code</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PriorityQueueSampling</span>(S[<span class="number">1</span>,<span class="number">2</span>,...])  <span class="comment">// S[1,2,...] is the streaming data with unknown length</span></span><br><span class="line">    P := <span class="keyword">new</span> PriorityQueue         <span class="comment">// Instantiate a new priority queue</span></span><br><span class="line">    <span class="keyword">while</span> S <span class="keyword">not</span> end:</span><br><span class="line">        r := <span class="built_in">random</span>(<span class="number">0</span>, <span class="number">1</span>)          <span class="comment">// Uniform sampling</span></span><br><span class="line">        <span class="keyword">if</span> P.Count &lt; k:</span><br><span class="line">            P.<span class="built_in">Insert</span>(r, S.New)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> r &lt; P.Max:</span><br><span class="line">            P.<span class="built_in">Pop</span>()</span><br><span class="line">            P.<span class="built_in">Insert</span>(r, S.New)</span><br><span class="line">        S.<span class="built_in">WaitNext</span>()</span><br><span class="line">    <span class="keyword">return</span> P</span><br></pre></td></tr></table></figure>
<h2 id="complexity">Complexity</h2>
<p>The running time complexity can be divided into two parts (ignoring
the first <span class="math inline">\(k\)</span> data records): one for
when the sampled value <span class="math inline">\(r\)</span> is less
than the current largest value in <span
class="math inline">\(\mathcal{P}\)</span>; the other for each incoming
data record. For the latter, as each data record has be to read, the
total time complexity is <span
class="math inline">\(\mathcal{O}(n)\)</span>; for the former, when the
sampled value <span class="math inline">\(r\)</span> is less than the
largest value in $, the whole priority queue needs to be re-arranged
which makes it take an additional time complexity of <span
class="math inline">\(\mathcal{O}(\log(k))\)</span>.</p>
<p>The expected running complexity is: <span class="math display">\[
\begin{equation}
    \begin{aligned}
        &amp;~~~~~n + \log(k)\sum_{i=k+1}^n\mathrm{Pr}(i~\text{is
selected})\\
        &amp;=n+\log(k)\sum_{i=k+1}^n\frac{k}{i}\\
        &amp;=n+k\log(k)\log(n/k) + \mathcal{O}(1)
    \end{aligned}
\end{equation}
\]</span></p>
<p>The first equality holds because all records have the same chance to
enter the priority queue and are uniformly sampled based on <span
class="math inline">\(\mathcal{U}[0,1]\)</span>. For the <span
class="math inline">\(i\)</span>-th record (<span
class="math inline">\(i&gt;k\)</span>), it has a chance of <span
class="math inline">\(k/i\)</span> to replace one value in the priority
queue. So its probability being selected, or having a value less than
the largest in the priority queue, is exactly <span
class="math inline">\(k/i\)</span>.</p>
<p>The second equality holds according to the formula <span
class="math inline">\(\sum_{i=1}^n\frac{1}{i}=\log(n)+\mathcal{O}(1)\)</span>.</p>
<p>Therefore, the final expected running complexity is <span
class="math inline">\(\mathcal{O}(n+k\log(k)\log(n/k))\)</span>.</p>
<h1 id="reservoir-sampling">Reservoir Sampling</h1>
<h2 id="theory-1">Theory</h2>
<p>Can we avoid using any external data structure, like priority queue,
to uniformly sample what we want? Yes! And it can be much easier.</p>
<p>It goes as follows:</p>
<ol type="1">
<li>Cache the first <span class="math inline">\(k\)</span> data records
and store them into the result set <span
class="math inline">\(\mathcal{R}\)</span>.</li>
<li>For the current incoming step <span class="math inline">\(i
(i&gt;k)\)</span>, sample an integer <span
class="math inline">\(j\)</span> from <span class="math inline">\(\{1,
2, \cdots, k, \cdots, i\}\)</span>. If <span class="math inline">\(j\in
\{1, 2, \cdots, k\}\)</span>, set <span
class="math inline">\(\mathcal{R}[j]=\mathcal{S}[i]\)</span>, otherwise
we discard <span class="math inline">\(\mathcal{S}[i]\)</span> and
proceed.</li>
</ol>
<p>That is, at each step we sample an index from the current index set.
If the sampled integer is within the first <span
class="math inline">\(k\)</span> indices, we replace the corresponding
stored record with current incoming record; otherwise we do nothing.</p>
<p>The core idea to prove it is to show at each step <span
class="math inline">\(i\)</span>, the probability of each seen record
<span class="math inline">\(x_1, x_2, \cdots, x_i\)</span> being
selected is <span class="math inline">\(k/i\)</span>. Assume this holds
for <span class="math inline">\(i\)</span> and we will prove it for
<span class="math inline">\(i+1\)</span>.</p>
<p>For an already selected data record, say <span
class="math inline">\(x_j\)</span>, its probability being selected at
step <span class="math inline">\(i\)</span> is <span
class="math inline">\(k/i\)</span> by induction. At this turn (<span
class="math inline">\(i+1\)</span>), the probability of <span
class="math inline">\(x_j\)</span> still being selected is:</p>
<p><span class="math display">\[
\begin{equation}
    \begin{aligned}
        \text{Pr}(x_j~\text{is still selected in next turn}) &amp;=
\frac{k}{i}\left(1-\frac{k}{i+1}\right)+\frac{k}{i}\frac{k}{i+1}\frac{k-1}{k}\\
        &amp;=\frac{k}{i}\frac{i}{i+1}\\
        &amp;=\frac{k}{i+1}
    \end{aligned}
\end{equation}
\]</span></p>
<p>This closes our proof. The first term means <span
class="math inline">\(x_{i+1}\)</span> is not selected and the second
term means <span class="math inline">\(x_{i+1}\)</span> is selected but
<span class="math inline">\(j\)</span> is not selected. Both cases lead
to the remaining of <span class="math inline">\(x_j\)</span>.</p>
<p>This algorithm is called <strong>Reservoir Sampling</strong>.</p>
<p>*PS: I don't know why it's given this name, maybe because it stores
<span class="math inline">\(k\)</span> samples from a population of data
records like a reservoir?</p>
<h2 id="pseudo-code-1">Pseudo Code</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReservoirSampling</span>(S[<span class="number">1</span>,<span class="number">2</span>,...]])  <span class="comment">// S[1,2,...] is the streaming data with unknown length</span></span><br><span class="line">    R[<span class="number">1.</span>..k] := S[<span class="number">1.</span>..k]        <span class="comment">// Initialize result set R from the first k samples of S</span></span><br><span class="line">    <span class="keyword">while</span> S <span class="keyword">not</span> end:</span><br><span class="line">        j := <span class="built_in">RandomInt</span>(<span class="number">1</span>, i)</span><br><span class="line">        <span class="keyword">if</span> j &lt;= k:</span><br><span class="line">            R[j] := S[i]</span><br><span class="line">    <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure>
<h2 id="complexity-1">Complexity</h2>
<p>Each incoming data record needs to be read from source streaming.
Hence, the running complexity is <span
class="math inline">\(\mathcal{O}(n)\)</span>.</p>
<h1 id="improved-reservoir-sampling">Improved Reservoir Sampling</h1>
<h2 id="theory-2">Theory</h2>
<p>Can we further improve the vanilla reservoir sampling algorithm? You
may ask, how can we achieve this if every record has to be read from
streaming. Yes, the optimal complexity is <span
class="math inline">\(\mathcal{O}(n)\)</span> if <strong>each</strong>
record is read. But what if we skip some records and straightly locate
to the next selected record? Well, with this in mind, we can indeed
improve the original reservoir sampling algorithm.</p>
<p>Going back to what we did in <a href="#priority-queue">priority
queue</a>, we sample a value from the uniform distribution <span
class="math inline">\(\mathcal{U}[0,1]\)</span> for each data record and
compare it to existing cached largest value. In other words, denote the
current maximum value by <span class="math inline">\(w\)</span>, the
probability of selecting current data record <span
class="math inline">\(x_{i+1}\)</span> will be <span
class="math inline">\(w\)</span>, and the probability of not selecting
it is <span class="math inline">\(1-w\)</span>. Extending it to <span
class="math inline">\(l\)</span> steps further. The probability of
selecting <span class="math inline">\(x_{i+l}\)</span> is <span
class="math inline">\((1-w)^{l-1}w\)</span>, or in the form of <span
class="math inline">\((1-w)^{l-1}-(1-w)^{l}\)</span>. Accumulate <span
class="math inline">\(l\)</span> from <span
class="math inline">\(1\)</span> to infinity, we have the following
cumulative distribution function (CDF):</p>
<p><span class="math display">\[F(x_{i+l}~\text{is
selected})=\sum_{j=1}^l\text{Pr}(x_{i+j}~\text{is
selected})=1-(1-w)^l\]</span></p>
<p>With that being said, if <span class="math inline">\(x_i\)</span> is
selected, we can sample a value <span
class="math inline">\(r\sim\mathcal{U}[0,1]\)</span> and set <span
class="math inline">\(r=1-(1-w)^l\)</span>. Then we successfully sample
the next selection index <span
class="math inline">\(l=\text{floor}\left(\dfrac{\log(r)}{\log(1-w)}\right)+1\)</span>.
Here we set <span class="math inline">\(r\gets 1-r\)</span> since <span
class="math inline">\(r\)</span> is uniformly sampled.</p>
<p>Now that we obtain our next selection index <span
class="math inline">\(i+l\)</span>, what is <span
class="math inline">\(w\)</span> then? Apparently we cannot keep it as
it is because the new sample <span
class="math inline">\(w_{i+l}\)</span> must have a smaller value than
<span class="math inline">\(w\)</span>. Well, actually <span
class="math inline">\(w_{i+l}\)</span> has the same distribution as
<span class="math inline">\(\max\{u_1,\cdots,u_k\}\)</span> where all
<span class="math inline">\(u_1, \cdots,
u_k\sim\mathcal{U}[0,w]\)</span> independenly. Here is the reason
(without strict proof):</p>
<ul>
<li>Each stored record has the same chance to be replaced by <span
class="math inline">\(x_{i+l}\)</span> as they are all randomly
sampled.</li>
<li>And each stored record's value <span class="math inline">\(u_j (j=1,
\cdots, k)\)</span> is sampled from <span
class="math inline">\(\mathcal{U}[0,w]\)</span> since we only know the
maximum <span class="math inline">\(w\)</span> and the real value thus
lies in a uniform distribution <span
class="math inline">\(\mathcal{U}[0,w]\)</span>.</li>
<li>We only care about the maximum of them and treat the maximum as the
new <span class="math inline">\(w\)</span>, i.e., <span
class="math inline">\(w=\max\{u_1,\cdots,u_k\}\)</span>.</li>
</ul>
<p>Now, calculating new <span class="math inline">\(w\)</span> reduces
to the follow problem: given a uniformly and independently sampled value
set <span class="math inline">\(\{u_1,\cdots,u_k\}\)</span> from <span
class="math inline">\(\mathcal{U}[0,w]\)</span>, how to sample their
maximum <span class="math inline">\(\max\{u_1,\cdots,u_k\}\)</span>.
This can be done by first sampling a random value <span
class="math inline">\(r\sim\mathcal{U}[0,1]\)</span> and then take <span
class="math inline">\(w\cdot r^{1/k}\)</span>.</p>
<p>Here is the proof:</p>
<p>Denote the maximum by <span
class="math inline">\(u=\max\{u_1,\cdots,u_k\}\)</span>, we have the
following equation hold:</p>
<p><span class="math display">\[\text{Pr}(u\le
x)=\prod_{j=1}^k\text{Pr}(u_j\le x)=F_X(x)^k\]</span></p>
<p>where <span class="math inline">\(F_X(x)\)</span> is the CDF of
uniform distribution that is <span class="math inline">\(x/w\)</span>
with <span class="math inline">\(x\in[0,w]\)</span>. Put it into <span
class="math inline">\(\text{Pr}(u\le x)\)</span> we have:</p>
<p><span class="math display">\[F_U(x)=\text{Pr}(u\le
x)=\left(\frac{x}{w}\right)^k,x\in[0,w]\]</span></p>
<p>We can then sample <span
class="math inline">\(r\sim\mathcal{U}[0,1]\)</span> and set <span
class="math inline">\(r=\left(\frac{x}{w}\right)^k\)</span>, which gives
us the new <span class="math inline">\(w\gets w\cdot r^{1/k}\)</span>.
Having obtained the next selection index <span
class="math inline">\(i+l\)</span> and the new maximum value <span
class="math inline">\(w\)</span>, we can iterative this procedure until
end of stream. Compared to vanilla reservoir sampling, this method does
not need to read each incoming data record and rather randomly skip some
of them, directly finding the next selection.</p>
<h2 id="pseudo-code-2">Pseudo Code</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ImprovedReservoirSampling</span>(S[<span class="number">1</span>,<span class="number">2</span>,...]])  <span class="comment">// S[1,2,...] is the streaming data with unknown length</span></span><br><span class="line">    R[<span class="number">1.</span>..k] := S[<span class="number">1.</span>..k]                <span class="comment">// Initialize result set R from the first k samples of S</span></span><br><span class="line">    w := <span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="built_in">random</span>())/k)</span><br><span class="line">    <span class="keyword">while</span> S <span class="keyword">not</span> end:</span><br><span class="line">        i := i + <span class="built_in">floor</span>(<span class="built_in">log</span>(<span class="built_in">random</span>())/<span class="built_in">log</span>(<span class="number">1</span>-w)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= n:</span><br><span class="line">            R[<span class="built_in">RandomInt</span>(<span class="number">1</span>,k)] := S[i]</span><br><span class="line">            w := w * <span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="built_in">random</span>())/k)</span><br><span class="line">    <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure>
<h2 id="complexity-2">Complexity</h2>
<p>The complexity can be divided into two parts: one for the first <span
class="math inline">\(k\)</span> records and the other for each upcoming
record. For the first part, the complexity is fixed <span
class="math inline">\(\mathcal{O}(k)\)</span>, and for the latter, the
complexity is <span
class="math inline">\(\mathcal{O}(k\log(n/k))\)</span> (the probability
of selecting <span class="math inline">\(x_i\)</span> is <span
class="math inline">\(k/i\)</span>, as stated in <a
href="#complexity">priority queue</a>). Therefore, the overall
complexity is <span
class="math inline">\(\mathcal{O}(k+k\log(n/k))\)</span>.</p>
<h1 id="references">References</h1>
<p>Reservoir sampling:
https://en.wikipedia.org/wiki/Reservoir_sampling#Statistical_properties<br />
Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n))):
https://dl.acm.org/doi/pdf/10.1145/198429.198435</p>
]]></content>
      <categories>
        <category>数学 - 概率论</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>采样</tag>
        <tag>蓄水池采样</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Bresenham算法画直线</title>
    <url>/2020/10/18/16/03/</url>
    <content><![CDATA[<p>Bresenham's
Algorithm是计算机图形学中用于画直线的算法，它只涉及整型数值的乘法和加法，在底层运算上提高了效率。本文介绍Bresenham算法的思路与扩展。</p>
<span id="more"></span>
<p>我们用显示器看到的各种图像都是由一个一个像素组成的，比如计算机要在显示器上显示一条线段，那么就要决定哪些像素填色，哪些不填色，如下图所示。下面我们假定像素点坐标为<span
class="math inline">\((x_i,y_i)\)</span>且坐标为整数，所给线段的两端点为<span
class="math inline">\((x&#39;,y&#39;),(x&#39;&#39;,y&#39;&#39;)\)</span>，且坐标也为整数。</p>
<p><img data-src="/images/bresenham/1.png" /></p>
<h1 id="naive-algorithm">Naive Algorithm</h1>
<p>显然，线段所在的直线的斜率是<span
class="math inline">\(k=\frac{y&#39;&#39;-y&#39;}{x&#39;&#39;-x&#39;}\)</span>，直线的方程就能够显式地写出来：<span
class="math inline">\(y=kx+b\)</span>，其中<span
class="math inline">\(b=y&#39;-kx&#39;\)</span>。</p>
<p>于是我们可以得到一个非常朴素的算法：从点<span
class="math inline">\((x_1,y_1)=(x&#39;,y&#39;)\)</span>开始，每次让横坐标加一，即<span
class="math inline">\(x_2=x_1+1,x_3=x_2+1,\cdots\)</span>，然后依次把横坐标代入到直线方程中，得到纵坐标<span
class="math inline">\(f(x_i)=kx_i+b\)</span>，然后去找离它最近的<span
class="math inline">\(y_i\)</span>，可以表达为<span
class="math inline">\(y_i=\lfloor
f(x_i)+0.5\rfloor\)</span>，从而点<span
class="math inline">\((x_i,y_i)\)</span>就是要填色的像素。接下来考虑<span
class="math inline">\(f(x_{i+1})\)</span>，重复这个过程，直到<span
class="math inline">\(x_i\ge x&#39;&#39;+1\)</span>。</p>
<p>这个方法如下图所示，注意红色线段和蓝色线段部分是直线上的变化：</p>
<figure>
<img data-src="/images/bresenham/2.png"
alt="给定线段的两点，可以得到它的直线方程，然后依次增大像素点的横坐标，求出对应横坐标的函数值，判断它的纵坐标是什么，得到填充点" />
<figcaption
aria-hidden="true">给定线段的两点，可以得到它的直线方程，然后依次增大像素点的横坐标，求出对应横坐标的函数值，判断它的纵坐标是什么，得到填充点</figcaption>
</figure>
<p>当然这个算法可以再高效一点，因为上面在算<span
class="math inline">\(f(x_i)\)</span>的时候是用直线方程去算，每次计算都有一个加法和一个乘法，我们可以迭代地去做：<span
class="math inline">\(f(x_i)=kx_i+b=k(x_{i-1}+1)+b=f(x_{i-1})+k\)</span>。现在，计算<span
class="math inline">\(f(x_i)\)</span>就只需要一次加法即可。</p>
<p>这个算法的好处在于，只要直线不是<span
class="math inline">\(x=a\)</span>，无论<span
class="math inline">\(k\)</span>是多少，两个点的位置如何，这个算法都适用。当然，<span
class="math inline">\(x=a\)</span>的情况特殊考虑即可，问题不大。</p>
<p>但是这个算法的问题在于，斜率<span
class="math inline">\(k\)</span>往往是浮点数（即使端点都是整型），而计算机计算浮点数的效率远没有计算整型快，而在图形学中，需要进行大量的即时演算，我们希望能够尽量避免浮点运算。而且，在求<span
class="math inline">\(y_i=\lfloor
f(x_i)+0.5\rfloor\)</span>时必不可少需要取整，这进一步降低了运算的效率。</p>
<h1 id="bresenham-algorithm">Bresenham Algorithm</h1>
<p>下面我们介绍Bresenham算法，一种基于Naive算法的改进版本，它不需要使用取整函数，而且大部分的加法与乘法运算都是基于整型，在运算效率上大大提高。下面我们假设直线斜率<span
class="math inline">\(0&lt;k\le 1\)</span>且<span
class="math inline">\(x&#39;&lt;x&#39;&#39;\)</span>，原因及一般的情况我们在下面会介绍。</p>
<p>现在我们仔细观察Naive算法，会发现其计算瓶颈主要由<span
class="math inline">\(f(x_i)=f(x_{i+1})+k\)</span>和<span
class="math inline">\(\lfloor
f(x_i)+0.5\rfloor\)</span>带来，换句话说，Naive算法假定我们对每一个<span
class="math inline">\(x_i\)</span>都要去计算它在直线上的精确位置<span
class="math inline">\(f(x_i)\)</span>，而且还要直接计算它离哪个纵坐标更近。</p>
<p>假定我们现在已经着色了点<span
class="math inline">\((x_i,y_i)\)</span>，如下图所示。</p>
<figure>
<img data-src="/images/bresenham/3.png"
alt="Bresenhan算法相比Naive算法的改进之处在于，在求像素纵坐标的时候，不直接用取整函数，而是考虑上下相邻两个像素点与函数值的距离，小的那个才是真正需要着色的，于是就把问题转为了两段距离的大小比较" />
<figcaption
aria-hidden="true">Bresenhan算法相比Naive算法的改进之处在于，在求像素纵坐标的时候，不直接用取整函数，而是考虑上下相邻两个像素点与函数值的距离，小的那个才是真正需要着色的，于是就把问题转为了两段距离的大小比较</figcaption>
</figure>
<p>由于我们的假定<span
class="math inline">\(k&lt;1\)</span>，所以下一个要着色的点只能是<span
class="math inline">\((x_{i+1},y_i)\)</span>或者<span
class="math inline">\((x_{i+1},y_{i+1})\)</span>，也就等价于计算<span
class="math inline">\(y_{i+1}-f(x_{i+1})\)</span>和<span
class="math inline">\(f(x_{i+1})-y_i\)</span>的大小，我们把它们分别记为<span
class="math inline">\(d_\text{upper}\)</span>和<span
class="math inline">\(d_\text{lower}\)</span>。现在对它们做差，就得到：</p>
<p><span
class="math display">\[d_\text{upper}-d_\text{lower}=y_{i+1}+y_i-2f(x_{i+1})=2y_i+1-2[k(x_i+1)+b]=2y_i-2kx_i+B\]</span></p>
<p>上面，<span class="math inline">\(B=1-2k-2b\)</span>是与<span
class="math inline">\(x_i,y_i\)</span>无关的常量。所以，现在我们就只关心<span
class="math inline">\(d_\text{upper}-d_\text{lower}\)</span>的正负如何，但是上式还是有<span
class="math inline">\(k\)</span>，我们记<span
class="math inline">\(\Delta y=y&#39;&#39;-y&#39;,\Delta
x=x&#39;&#39;-x&#39;\)</span>，于是<span class="math inline">\(k=\Delta
y/\Delta x\)</span>，代入到上式，就得到了：</p>
<p><span
class="math display">\[d_\text{upper}-d_\text{lower}=2y_i-2\frac{\Delta
y}{\Delta x}x_i+B\Rightarrow \Delta
x(d_\text{upper}-d_\text{lower})=2\Delta x y_i-2\Delta y x_i+\Delta
xB\]</span></p>
<p>由于我们又假设了<span
class="math inline">\(x&#39;&lt;x&#39;&#39;\)</span>，所以<span
class="math inline">\(\Delta x\)</span>为正，要判断<span
class="math inline">\(d_\text{upper}-d_\text{lower}\)</span>的符号也就是要判断<span
class="math inline">\(2\Delta x y_i-2\Delta y x_i+\Delta
xB\)</span>的符号，此刻我们记<span class="math inline">\(p_i=2\Delta x
y_i-2\Delta y x_i+\Delta xB\)</span>。所以，只要判断<span
class="math inline">\(p_i\)</span>是大于0还是小于0，就可以判断对横坐标<span
class="math inline">\(x_{i+1}\)</span>而言，是要选<span
class="math inline">\(y_i\)</span>还是<span
class="math inline">\(y_{i+1}\)</span>为纵坐标了。</p>
<p>现在我们把<span
class="math inline">\(x&#39;\)</span>代入，就得到初始值<span
class="math inline">\(p_0\)</span>: <span class="math display">\[
p_0=2\Delta x(kx&#39;+b)-2\Delta y x&#39;+\Delta x(1-2k-2b)=2\Delta
xkx&#39;+2\Delta x b-2\Delta yx&#39;+\Delta x-2\Delta xk-2\Delta x b\\\\
=2x&#39;\Delta y-2x&#39;\Delta y+\Delta x-2\Delta y=\Delta x-2\Delta y
\]</span></p>
<p>虽然上式已经成功去掉了计算<span
class="math inline">\(f(x_{i+1})\)</span>，但是要计算<span
class="math inline">\(p_i\)</span>还需要每次都加常数项<span
class="math inline">\(B\)</span>，而它仍然包含了浮点数<span
class="math inline">\(k,b\)</span>，我们还是想要不计算它们。但是我们观察到，<span
class="math inline">\(p_{i+1},p_i\)</span>都包含常数项<span
class="math inline">\(\Delta x
B\)</span>，所以我们对它们做差就可以消去常数项，得到:</p>
<p><span class="math display">\[p_{i+1}-p_i=(2\Delta xy_i-2\Delta
yx_i)-(2\Delta xy_{i+1}-2\Delta yx_{i+1})=2\Delta x(y_i-y_{i+1})-2\Delta
y\]</span></p>
<p>或者写成下面的递推形式：</p>
<p><span class="math display">\[p_{i+1}=p_i+2\Delta
x(y_i-y_{i+1})-2\Delta y\]</span></p>
<p>现在，已经不用再计算浮点数<span
class="math inline">\(k,b\)</span>了。我们前面已经说了，可以用<span
class="math inline">\(p_i\)</span>去判断<span
class="math inline">\(y_{i+1}\)</span>和<span
class="math inline">\(y_i\)</span>的关系，然后，就可以把<span
class="math inline">\(y_{i+1}-y_i\)</span>代入上式，计算出<span
class="math inline">\(p_{i+1}\)</span>了。</p>
<p><strong>所以</strong>，当<span
class="math inline">\(p_i&gt;0\)</span>的时候，<span
class="math inline">\(d_\text{upper}&gt;d_\text{lower}\)</span>，<span
class="math inline">\(y_{i+1}\)</span>等于<span
class="math inline">\(y_i\)</span>，此时计算得<span
class="math inline">\(p_{i+1}=p_i-2\Delta y\)</span>；当<span
class="math inline">\(p_i&lt;0\)</span>时，<span
class="math inline">\(d_\text{upper}&lt;d_\text{lower}\)</span>，<span
class="math inline">\(y_{i+1}=y_i+1\)</span>，此时计算得<span
class="math inline">\(p_{i+1}=p_i+2\Delta x-2\Delta
y\)</span>。然后再用<span
class="math inline">\(p_{i+1}\)</span>去判断<span
class="math inline">\(y_{i+2}\)</span>，从而可以计算<span
class="math inline">\(p_{i+2}\)</span>，一直下去，直到<span
class="math inline">\(x_i\ge x&#39;&#39;+1\)</span>。</p>
<p>注意我们的两个前提<span class="math inline">\(k&lt;1\)</span>和<span
class="math inline">\(x&#39;&lt;x&#39;&#39;\)</span>，前者保证了<span
class="math inline">\(y_i\)</span>每次最多增加1，后者保证了<span
class="math inline">\(\Delta x\)</span>为正。</p>
<p>总结来说，Bresenham算法的流程是： <span class="math display">\[
p_0 \rightarrow(x_1,\hat{y}\_1) \rightarrow p_1
\rightarrow(x_2,\hat{y}\_2) \rightarrow \cdots \rightarrow p_n
\rightarrow (x_{n+1},\hat{y}_{n+1})
\]</span> 这里的<span
class="math inline">\(\hat{y}_i\)</span>根据计算结果选择。</p>
<p>下面是一个例子，设给定的两点是<span
class="math inline">\((1,3),(10,5)\)</span>，从而<span
class="math inline">\(\Delta x=9,\Delta y=2, p_0=\Delta-2\Delta
y=5,2\Delta y=4, 2\Delta x-2\Delta
y=14\)</span>，把这些都计算好之后，首先填充<span
class="math inline">\((1,3)\)</span>这个像素，然后发现<span
class="math inline">\(p_0=5&gt;0\)</span>，则下一个点的纵坐标还是3，于是填色像素<span
class="math inline">\((2,3)\)</span>，计算<span
class="math inline">\(p_1=p_0-2\Delta
y=1&gt;0\)</span>；发现又为正，则下一个像素是<span
class="math inline">\((3,3)\)</span>，计算<span
class="math inline">\(p_2=p_1-2\Delta
y=-3\)</span>；此时发现为负，则向上移动一格，要填充的像素是<span
class="math inline">\((4,4)\)</span>，再计算<span
class="math inline">\(p_3=p_2+2\Delta x-2\Delta
y=11\)</span>；以此类推。</p>
<figure>
<img data-src="/images/bresenham/4.png"
alt="一个使用Bresenhan算法画线的实例" />
<figcaption
aria-hidden="true">一个使用Bresenhan算法画线的实例</figcaption>
</figure>
<p>由于线段没有方向性，所以我们可以始终将第一个点设为第二个点的左侧，即<span
class="math inline">\(x&#39;&lt;x&#39;&#39;\)</span>。那么现在的问题就是要解决<span
class="math inline">\(k\le 0\)</span>和<span
class="math inline">\(k&gt;1\)</span>的问题了。可以发现，不同的<span
class="math inline">\(k\)</span>其实对应了平面的不同区域，根据对角线与坐标轴可以分为四个区域。现在，只需要对<span
class="math inline">\(k\le 0\)</span>和<span
class="math inline">\(k&gt;1\)</span>对应的线段进行对称操作，就可以转换为<span
class="math inline">\(0&lt;k\le
1\)</span>的情况。在求得所有填色的像素之后，再把这些像素对称回去即可。</p>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>算法</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Customizing Actor&#39;s Details Panel and Accessing its CDO Components</title>
    <url>/2023/03/02/10/53/</url>
    <content><![CDATA[<p>Recently I've been writing a new functionality for my plugin. To
facilitate its use, I want some buttons on the Details panel where these
buttons will modify the blueprint class's CDO data. The first step,
accessing the blueprint class's specific component, however is not as
simple as I thought. You cannot use the
<code>FindComponentByClass</code> function or its equivalents to access
the component of the blueprint class at the CDO state. The second step,
customizing the Details panel, requires me to create a new editor module
and implements the <code>IDetailCustomization</code> interface in a very
notoriously clumsy way. This post introduces how to customize actor's
Details panel and access its CDO components.</p>
<span id="more"></span>
<h1
id="step-1-create-a-new-class-implementing-idetailcustomization">Step 1:
Create A New Class Implementing <code>IDetailCustomization</code></h1>
<p>According to the <a
href="https://docs.unrealengine.com/5.1/en-US/details-panel-customization-in-unreal-engine/">official
documentation</a>, the <code>IDetailCustomization</code> interface can
be used for any class that lays out details for its properties or
functions.</p>
<p>Start by creaing a new class implementing this interface:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IDetailCustomization.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FMyDetail</span> : <span class="keyword">public</span> IDetailCustomization</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Used to create a singleton instance.</span></span><br><span class="line">    <span class="function"><span class="type">static</span> TSharedRef&lt;IDetailCustomization&gt; <span class="title">MakeInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Used to specifically implement your customization.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CustomizeDetails</span><span class="params">(IDetailLayoutBuilder&amp; DetailBuilder)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">UActorSequenceComponent* <span class="title">GetActorSequenceComponent</span><span class="params">(AMyClass* Object)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Then in its <code>.cpp</code> file you should implement the two
declared functions:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDetail.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DetailLayoutBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DetailCategoryBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DetailWidgetRow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Widgets/Input/SButton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/SCS_Node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCTEXT_NAMESPACE <span class="string">&quot;MyDetail&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">TSharedRef&lt;IDetailCustomization&gt; <span class="title">FKeyframeExtensionDetail::MakeInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MakeShared</span>&lt;FKeyframeExtensionDetail&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FKeyframeExtensionDetail::CustomizeDetails</span><span class="params">(IDetailLayoutBuilder&amp; DetailBuilder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TArray&lt; TWeakObjectPtr&lt;UObject&gt; &gt; Objects;</span><br><span class="line">    DetailBuilder.<span class="built_in">GetObjectsBeingCustomized</span>(Objects);</span><br><span class="line">    <span class="keyword">if</span> (Objects.<span class="built_in">Num</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AMyClass* Object = (AMyClass*)Objects[<span class="number">0</span>].<span class="built_in">Get</span>();</span><br><span class="line">    IDetailCategoryBuilder&amp; KeyframeCategory = DetailBuilder.<span class="built_in">EditCategory</span>(<span class="string">&quot;ECamera Actions&quot;</span>, <span class="built_in">FText</span>(), ECategoryPriority::Important);</span><br><span class="line"></span><br><span class="line">    KeyframeCategory.<span class="built_in">AddCustomRow</span>(FText::<span class="built_in">GetEmpty</span>())</span><br><span class="line">    .<span class="built_in">NameContent</span>()</span><br><span class="line">    [</span><br><span class="line">        <span class="built_in">SNew</span>(STextBlock)</span><br><span class="line">        .<span class="built_in">Text</span>(FText::<span class="built_in">FromString</span>(<span class="string">&quot;Keyframe Extension&quot;</span>))</span><br><span class="line">        .<span class="built_in">Font</span>(IDetailLayoutBuilder::<span class="built_in">GetDetailFont</span>())</span><br><span class="line">    ]</span><br><span class="line">    .<span class="built_in">ValueContent</span>()</span><br><span class="line">    [</span><br><span class="line">        <span class="built_in">SNew</span>(SHorizontalBox)</span><br><span class="line">        + SHorizontalBox::<span class="built_in">Slot</span>()</span><br><span class="line">        .<span class="built_in">Padding</span>(<span class="number">0</span>)</span><br><span class="line">        .<span class="built_in">AutoWidth</span>()</span><br><span class="line">        [</span><br><span class="line">            <span class="built_in">SNew</span>(SButton)</span><br><span class="line">            .<span class="built_in">ToolTipText</span>(FText::<span class="built_in">FromString</span>(<span class="string">&quot;Tootip here.&quot;</span>))</span><br><span class="line">            .<span class="built_in">Content</span>()</span><br><span class="line">            [</span><br><span class="line">                <span class="built_in">SNew</span>(STextBlock)</span><br><span class="line">                .<span class="built_in">Text</span>(FText::<span class="built_in">FromString</span>(<span class="string">&quot;Toss Sequence&quot;</span>))</span><br><span class="line">                .<span class="built_in">Font</span>(IDetailLayoutBuilder::<span class="built_in">GetDetailFont</span>())</span><br><span class="line">            ]</span><br><span class="line">            .<span class="built_in">IsEnabled_Lambda</span>([<span class="keyword">this</span>, Object]()-&gt;<span class="type">bool</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="built_in">OnClicked_Lambda</span>([<span class="keyword">this</span>, Object]()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Object)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Access the CDO component. Will explain later.</span></span><br><span class="line">                    UActorSequenceComponent* ActorSequenceComponent = <span class="built_in">GetActorSequenceComponent</span>(Object);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If this object is currently in blueprint (CDO)</span></span><br><span class="line">                    <span class="keyword">if</span> (Object-&gt;<span class="built_in">IsTemplate</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">DoSomething</span>(ActorSequenceComponent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If this object is currently in level (instance).</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">DoSomething</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span> (FReply::<span class="built_in">Handled</span>());</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LOCTEXT_NAMESPACE</span></span><br></pre></td></tr></table></figure>
<p>It is quite easy to understand the code. What I am basically doing is
first to get all customized objects and get the one I'm interested in.
Then I specify the actor's category I want to customize. Last under this
category I add a new row that includes a button with showing text "Toss
Sequence".</p>
<p>The most core part is the action this button executes after you click
it, defined in <code>.OnClicked_Lambda</code>. In my case I want to
access the <code>UActorSequenceComponent</code> component, so I define a
new function <code>GetActorSequenceComponent</code> and it returns a
<code>UActorSequenceComponent</code> pointer. This component is exactly
the one contained in the class's CDO. The next four lines first check
whether this object is in blueprint or in level, and then execute
different functions.</p>
<h1 id="step-2-accessing-component-in-cdo">Step 2: Accessing Component
in CDO</h1>
<p>Function <code>GetActorSequenceComponent</code> implements accessing
a specific component in CDO:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">UActorSequenceComponent* <span class="title">FMyDetail::GetActorSequenceComponent</span><span class="params">(AMyClass* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UActorSequenceComponent* ActorSequenceComponent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (Object)</span><br><span class="line">    &#123;</span><br><span class="line">        UBlueprintGeneratedClass* CurrentBPClass = <span class="built_in">Cast</span>&lt;UBlueprintGeneratedClass&gt;(Object-&gt;<span class="built_in">GetClass</span>());</span><br><span class="line">        <span class="keyword">if</span> (CurrentBPClass &amp;&amp; CurrentBPClass-&gt;SimpleConstructionScript)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> USCS_Node* Component : CurrentBPClass-&gt;SimpleConstructionScript-&gt;<span class="built_in">GetAllNodes</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                UActorSequenceComponent* TemporaryComponent = <span class="built_in">Cast</span>&lt;UActorSequenceComponent&gt;(Component-&gt;ComponentTemplate);</span><br><span class="line">                <span class="keyword">if</span> (TemporaryComponent != <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ActorSequenceComponent = TemporaryComponent;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ActorSequenceComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>I don't want to dive into the details of each class and function
mentioned above. To put it simply, this function first gets the
blueprint generated class and then the
<code>SimpleConstructionScript</code> member which is a graph describing
the components to instantiate. Within SCS, we can visit each node and
check if it is the component of interest. Last, we return the
pointer.</p>
<h1
id="step-3-registering-the-customized-details-panel-in-.build.cs">Step
3: Registering the Customized Details Panel in <em>.Build.cs</em></h1>
<p>As the last step, you should register the custom class layout in the
<em>.Build.cs</em> file. Basically this should be within the editor
module rather than the runtime counterpart.</p>
<p>Register is quite simple. In your <em>.Build.cs</em> file, add
several lines in <code>StartupModule()</code> and
<code>ShutdownModule()</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FEasyCameraEditorModule::StartupModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; PropertyModule = FModuleManager::<span class="built_in">LoadModuleChecked</span>&lt;FPropertyEditorModule&gt;(<span class="string">&quot;PropertyEditor&quot;</span>);</span><br><span class="line">    PropertyModule.<span class="built_in">RegisterCustomClassLayout</span>(</span><br><span class="line">        <span class="comment">// Drop all prefix such as U and A.</span></span><br><span class="line">        <span class="string">&quot;MyClass&quot;</span>, </span><br><span class="line">        FOnGetDetailCustomizationInstance::<span class="built_in">CreateStatic</span>(&amp;FMyDetail::MakeInstance)</span><br><span class="line">        );</span><br><span class="line">    PropertyModule.<span class="built_in">NotifyCustomizationModuleChanged</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FEasyCameraEditorModule::ShutdownModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FModuleManager::<span class="built_in">Get</span>().<span class="built_in">IsModuleLoaded</span>(<span class="string">&quot;PropertyEditor&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; PropertyModule = FModuleManager::<span class="built_in">LoadModuleChecked</span>&lt;FPropertyEditorModule&gt;(<span class="string">&quot;PropertyEditor&quot;</span>);</span><br><span class="line">        PropertyModule.<span class="built_in">UnregisterCustomClassLayout</span>(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="result">Result</h1>
<p>Compile and open Unreal editor. In the blueprint Details panel, you
can see three new buttons have been added (I add two more buttons). Each
button, when clicked, successfully executes its behaviour as
exptected.</p>
<p><img data-src="/images/customizing-actors-details-panel/1.jpg" /></p>
]]></content>
      <categories>
        <category>游戏 - 引擎</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>游戏</tag>
        <tag>UE</tag>
        <tag>蓝图</tag>
        <tag>CDO</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>How are FBX files Imported in Unreal Engine</title>
    <url>/2023/02/19/12/52/</url>
    <content><![CDATA[<p>This post briefly introduces how FBX files are imported into Unreal
Engine, particularly for animation sequences.</p>
<span id="more"></span>
<p>In <code>SkeletalMeshEdit.cpp</code>, you can find the function
<code>bool UnFbx::UnFFbxImporter::ImportAnimation</code>, and this is
where FBX import takes place.</p>
<h1 id="find-valid-bone-names">Find Valid Bone Names</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TArray&lt;FName&gt; FbxRawBoneNames;</span><br><span class="line"><span class="built_in">FillAndVerifyBoneNames</span>(Skeleton, SortedLinks, FbxRawBoneNames, FileName);</span><br><span class="line"><span class="function">FAnimCurveImportSettings <span class="title">AnimImportSettings</span><span class="params">(DestSeq, NodeArray, SortedLinks, FbxRawBoneNames, AnimTimeSpan)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Function <code>FillAndVerifyBoneNames</code> will copy all bone names
into <code>FbxRawBoneNames</code> and verify whether they are duplicate
or invalid. <code>FbxRawBoneNames</code> now contains all valid bone
names.</p>
<p><code>AnimImportSettings</code> is a helper structure to pass around
the common animation parameters including the AnimationSequence asset
reference, FBX nodes, bone names, and animation time span.</p>
<h1 id="import-blend-shapes">Import Blend Shapes</h1>
<p>Having everything prepared, we can import raw animation curves into
the AnimationSequence asset. The first type of data we would like to
import is the blend shape (morph target) curves. This is implemented by
function <code>ImportBlendShapeCurves</code>.</p>
<p>The function process can be described using the following pseudo
code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach (FBXNode : FBXNodeArray) </span><br><span class="line">    foreach (BlendShape : FBXNode-&gt;BlendShapes)</span><br><span class="line">        foreach (Channel : BlendShape-&gt;BlendShapeChannels)</span><br><span class="line">        &#123;</span><br><span class="line">            FbxAnimCurve* Curve = GetShapeChannel (BlendShape, Channel)</span><br><span class="line">            if (ShouldImportCurve (Curve))</span><br><span class="line">            &#123;</span><br><span class="line">                int TargetShapeCount = Channel-&gt;GetTargetShapeCount()</span><br><span class="line">                if (TargetShapeCount &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (TargetShapeCount == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ImportCurveToAnimSequence (AnimSeq, Channel, Curve)</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        // Scale blend shapes values by 0.01</span><br><span class="line">                        Algo::Transform(FbxInbetweenFullWeights, InbetweenFullWeights, [](double Input)&#123; return Input * 0.01f; &#125;)</span><br><span class="line"></span><br><span class="line">                        // Collect inbetween shape names</span><br><span class="line">                        for (int32 InbetweenIndex = 0; InbetweenIndex &lt; InbetweenCount; ++InbetweenIndex)</span><br><span class="line">						&#123;</span><br><span class="line">							FbxShape* Shape = Channel-&gt;GetTargetShape(InbetweenIndex)</span><br><span class="line">							CurveNames.Add(MakeName(Shape-&gt;GetName()))</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">                        // Convert FBX curve into rich curve</span><br><span class="line">                        FRichCurve ChannelWeightCurve;</span><br><span class="line">						ImportCurve(Curve, ChannelWeightCurve)</span><br><span class="line">						if (AnimSeq)</span><br><span class="line">						&#123;</span><br><span class="line">							ChannelWeightCurve.BakeCurve(1.0f / AnimSeq-&gt;ImportResampleFramerate)</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">                        // Use the primary curve to generate inbetween shape curves + a modified primary curve</span><br><span class="line">                        TArray&lt;FRichCurve&gt; Results = ResolveWeightsForBlendShapeCurve(ChannelWeightCurve, InbetweenFullWeights)</span><br><span class="line">						if (ImportRichCurvesToAnimSequence(AnimSeq, CurveNames, Results, 0))</span><br><span class="line">						&#123;</span><br><span class="line">							for (const FString&amp; CurveName : CurveNames)</span><br><span class="line">								MySkeleton-&gt;AccumulateCurveMetaData(*CurveName, false, true)</span><br><span class="line">						&#125;	</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>ImportRichCurvesToAnimSequence</code> is worth
particular attention. It practically updates the AnimationSequence with
the curves created and modified in function
<code>ImportBlendShapeCurves</code>.</p>
<p>Let's first examine the function
<code>ImportRichCurvesToAnimSequence</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach (CurveName : CurveNames)</span><br><span class="line">&#123;</span><br><span class="line">    // Add or retrieve curve</span><br><span class="line">    if (!SkeletonCurveMapping-&gt;Exists(CurveName))</span><br><span class="line">    &#123;</span><br><span class="line">        // Make skeleton dirty</span><br><span class="line">        Skeleton-&gt;Modify()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get corresponding curve</span><br><span class="line">    FAnimationCurveIdentifier FloatCurveId (CurveName, ERawCurveTrackTypes::RCT_Float)</span><br><span class="line">    const FFloatCurve* TargetCurve = AnimSeq-&gt;GetDataModel()-&gt;FindFloatCurve(FloatCurveId)</span><br><span class="line"></span><br><span class="line">    // Update curve and set keys</span><br><span class="line">	AnimSeq-&gt;Controller.SetCurveKeys(FloatCurveId, RichCurves[CurveIndex].GetConstRefOfKeys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then, let's examine function <code>SetCurveKeys</code>, which is
defined in <code>AnimDataContyroller.cpp</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get the curve according to curve id</span><br><span class="line">FRichCurve* RichCurve = Model-&gt;GetMutableRichCurve(CurveId)</span><br><span class="line"></span><br><span class="line">if (RichCurve)</span><br><span class="line">&#123;</span><br><span class="line">    // Set rich curve values</span><br><span class="line">	RichCurve-&gt;SetKeys(CurveKeys);</span><br><span class="line"></span><br><span class="line">    // On curve changed notify</span><br><span class="line">    FCurveChangedPayload Payload;</span><br><span class="line">	Payload.Identifier = CurveId;</span><br><span class="line">	Model-&gt;Notify(EAnimDataModelNotifyType::CurveChanged, Payload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, go to <code>RichCurve.cpp</code> and you will see the
definition of function <code>SetKeys</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FRichCurve::SetKeys</span><span class="params">(<span class="type">const</span> TArray&lt;FRichCurveKey&gt;&amp; InKeys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">	Keys.<span class="built_in">SetNum</span>(InKeys.<span class="built_in">Num</span>());</span><br><span class="line">	KeyHandlesToIndices.<span class="built_in">SetKeyHandles</span>(InKeys.<span class="built_in">Num</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (int32 Index = <span class="number">0</span>; Index &lt; InKeys.<span class="built_in">Num</span>(); ++Index)</span><br><span class="line">	&#123;</span><br><span class="line">		Keys[Index] = InKeys[Index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AutoSetTangents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>which is pretty straightforward.</p>
<h1 id="import-animation">Import Animation</h1>
<p>Function <code>UnFbx::FFbxImporter::ImportBoneTracks</code> is
responsible for importing bone animation tracks. Its pseudo code is as
follows.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach (BoneName : FbxRawBoneNames)</span><br><span class="line">&#123;</span><br><span class="line">    CheckValidity (BoneName)</span><br><span class="line"></span><br><span class="line">    FRawAnimSequenceTrack RawTrack</span><br><span class="line">    for (CurTime = StartTime; CurTime &lt; EndTime; CurTime += TimeInc)</span><br><span class="line">    &#123;</span><br><span class="line">        LocalTransform = GetLocalTransformFromRawMatrixData (CurTime)</span><br><span class="line">        RawTrack.ScaleKeys.Add(FVector3f(LocalTransform.GetScale3D()))</span><br><span class="line">		RawTrack.PosKeys.Add(FVector3f(LocalTransform.GetTranslation()))</span><br><span class="line">		RawTrack.RotKeys.Add(FQuat4f(LocalTransform.GetRotation()))</span><br><span class="line"></span><br><span class="line">        if (Success)</span><br><span class="line">        &#123;</span><br><span class="line">            if (SkeletonHasBone (BoneName))</span><br><span class="line">            &#123;</span><br><span class="line">                // Add a new track</span><br><span class="line">                Controller.AddBoneTrack(BoneName)</span><br><span class="line">				Controller.SetBoneTrackKeys(BoneName, RawTrack.PosKeys, RawTrack.RotKeys, RawTrack.ScaleKeys)</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                // Create animation attribute and add the transform keys</span><br><span class="line">                UE::Anim::AddTypedCustomAttribute&lt;FTransformAnimationAttribute, FTransform&gt;(...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="import-bone-metadata">Import Bone Metadata</h1>
<p>The final step is to import the bone metadata. It simply calls the
<code>ImportNodeCustomProperties(AnimSeq, SkeletonNode)</code> for each
skeleton node.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach (Property : NodeProperties)</span><br><span class="line">&#123;</span><br><span class="line">    MetadataTag = &quot;FBX.&quot; + NodeName + &quot;.&quot; + Property.GetName()</span><br><span class="line">    MetadataValue = GetFbxPropertyStringValue(Property)</span><br><span class="line">    AnimSeq-&gt;GetOutermost()-&gt;GetMetaData()-&gt;SetValue(AnimSeq, *MetadataTag, *MetadataValue)</span><br><span class="line"></span><br><span class="line">    foreach (ChildNode : NodeChildren)</span><br><span class="line">    &#123;</span><br><span class="line">        ImportNodeCustomProperties (AnimSeq, ChildNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>游戏 - 动画</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>游戏</tag>
        <tag>UE</tag>
        <tag>编辑器</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Motion Matching -- 概念与发展</title>
    <url>/2022/03/27/08/38/</url>
    <content><![CDATA[<p>这是我在组内分享的一次关于Motion
Matching基本知识的介绍，放在此备份。</p>
<span id="more"></span>
<div class="pdf-container" data-target="/resources/pdf/MotionMatching-概念与发展.pdf" data-height="800px"></div>
]]></content>
      <categories>
        <category>游戏 - 动画</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>动画</tag>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>A Brief Note on Version Control and Project Organization</title>
    <url>/2022/11/21/16/03/</url>
    <content><![CDATA[<p>This is a brief note about the e-book <a
href="https://resources.unity.com/games/version-control-project-organization-best-practices-ebook">Version
Control and Project Organization Best Practice Guide</a> present at
Unite 2022. In this book, we can learn fundamental concepts of version
control and some best practices for organizing a Unity project. If you
are new to Unity, or you prepare to set up a larger scale Unity project,
this may be what you need.</p>
<span id="more"></span>
<h1 id="foundational-concepts">Foundational concepts</h1>
<ul>
<li><strong>Version control</strong> enables you to keep a historical
track of your entire project. It facilitates your collaboration with
your team through trackable and revertible commits organized in the form
of timeline.</li>
<li><strong>Why use version control</strong>
<ul>
<li>Useful for making experimental changes</li>
<li>Easy iteration</li>
<li>Avoid conflict</li>
</ul></li>
<li><strong>Centralized vs. distributed version control</strong>
<ul>
<li>Centralized: repository is resided in a dedicated server, and
changes are fetched from and sent to the repository directly. To avoid
conflicts, users can lock files for modification, which is known as
checking out the file.</li>
<li>Distributed: users have local copy of the project and submit changes
whenever they want without always working on the latest files like on a
centralized system. But it costs a lot of space to store the entire
history changes.</li>
</ul></li>
<li><strong>Typical workflow</strong>
<ul>
<li>Centralized
<ol type="1">
<li>Update your working copy with changes from the server</li>
<li>Make your changes</li>
<li>Commit your changes to the central server</li>
</ol></li>
<li>Distributed
<ol type="1">
<li>Pull any remote changes into your local repo</li>
<li>Make changes</li>
<li>Commit changes</li>
<li>Push changes back to the remote repo</li>
</ol></li>
</ul></li>
</ul>
<h1 id="best-practices-for-organizing-a-unity-project">Best practices
for organizing a Unity project</h1>
<ul>
<li><strong>Folder structure</strong>
<ul>
<li>Recommendations:
<ul>
<li>Document your naming conventions and folder structure.</li>
<li>Be consistent with your naming convention.</li>
<li>Don't use spaces in file and folder names.</li>
<li>Separate testing or sandbox areas.</li>
<li>Avoid extra folders at the root level.</li>
<li>Keep your internal assets from third-party ones.</li>
</ul></li>
</ul></li>
<li>The <code>.meta</code> file: it holds information about the file
which it is associated with, e.g., Textures, meshes, audio clips that
have particular import settings.</li>
<li><strong>Naming standards</strong>:
<ul>
<li>Use descriptive names, not abbreviate.</li>
<li>Use Camel case/Pascal case.</li>
<li>Use underscore sparingly.</li>
<li>Use number suffixes to denote a sequence.</li>
<li>Follow document naming.</li>
</ul></li>
<li><strong>Workflow optimization</strong>:
<ul>
<li>Split up your assets: break levels into smaller scenes, using
<code>SceneManager.LoadSceneAsync</code>; break work up into Prefabs
where possible.</li>
<li>Use <code>Preset</code> to save asset settings.</li>
</ul></li>
<li><strong>Code standards</strong>
<ul>
<li>Decide a code standard and stick with it.</li>
<li>When using namespace, break your folder structure up by the
namespace for better organization.</li>
<li>Using a standard header.</li>
<li>Using script templates by creating an
<code>Assets/ScriptTemplates</code> folder.</li>
<li>You can also use your own keywords and replace them with an Editor
script implementing the <code>OnWillCreateAsset</code> method.
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /*-------------------------------------------</span></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"><span class="comment">// Creation Date: #DATETIME#</span></span><br><span class="line"><span class="comment">// Author: #DEVELOPER#</span></span><br><span class="line"><span class="comment">// Description: #PROJECTNAME#</span></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"><span class="comment">// -------------------------------------------*/</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KeywordReplace</span> : <span class="title">UnityEditor</span> .<span class="title">AssetModificationProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnWillCreateAsset</span> (<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        path = path.Replace(<span class="string">&quot;.meta&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> index = path.LastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> file = path.Substring(index);</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="string">&quot;.cs&quot;</span> &amp;&amp; file != <span class="string">&quot;.js&quot;</span> &amp;&amp; file != <span class="string">&quot;.boo&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        index = Application.dataPath.LastIndexOf(<span class="string">&quot;Assets&quot;</span>);</span><br><span class="line">        path = Application.dataPath.Substring(<span class="number">0</span>, index) + path;</span><br><span class="line">        <span class="keyword">if</span> (!System.IO.File.Exists(path))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> fileContent = System.IO.File.ReadAllText(path);</span><br><span class="line"></span><br><span class="line">        fileContent = fileContent.Replace(<span class="string">&quot;#CREATIONDATE#&quot;</span>, System.DateTime.Today.ToString(<span class="string">&quot;dd/MM/yy&quot;</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        fileContent = fileContent.Replace(<span class="string">&quot;#PROJECTNAME#&quot;</span>, PlayerSettings.product-Name);</span><br><span class="line">        fileContent = fileContent.Replace(<span class="string">&quot;#DEVELOPER#&quot;</span>, System.Environment.User-Name);</span><br><span class="line"></span><br><span class="line">        System.IO.File.WriteAllText(path, fileContent);</span><br><span class="line">        AssetDatabase.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="version-control-systems">Version control systems</h1>
<ul>
<li>Git: Fork, GitKraken, VS Code, VS, SourceTree, Sublime Merge.</li>
<li>Perforce (Helix Core): see <a
href="https://www.perforce.com/blog/vcs/how-to-use-unity-version-control">here</a>
to learn how to integrate Perforce into Unity.</li>
<li>Apache Subversion (SVN)</li>
<li>Plastic SCM: see <a
href="https://unity.com/products/plastic-scm">here</a> to learn more
about Plastic SCM.</li>
</ul>
<p><img data-src="/images/vcs/1.png" /></p>
<h1 id="settings-up-unity-to-work-with-version-control">Settings up
Unity to work with version control</h1>
<ul>
<li><strong>Editor project settings</strong>
<ul>
<li>Perforce: Edit -&gt; Project Settings -&gt; Version Control -&gt;
Mode.</li>
<li>Plastic SCM: click the Plastic SCM icon in the toolbar on the top
right in Unity Editor.</li>
</ul></li>
<li>What to ignore: Do not commit the <code>Library</code> folder, as
well as the <code>.exe</code> or <code>.apk</code> files.</li>
<li>Work with large files: teams prefer a centralized workflow where
large binary files would only on a central server with individual users
only accessing the latest version on their machines, rather than a
distributed one where many copies of historical files are stored on
local machines. If using Git, be sure to include Git LFS.</li>
</ul>
<h1 id="best-practices-for-version-control">Best practices for version
control</h1>
<p>Some suggestions you may need to make teamwork more efficient:</p>
<ul>
<li>Commit little, commit often.</li>
<li>Keep commit messages clean.</li>
<li>Avoid indiscriminate commits. It is important to understand that you
should only commit what you have changed in the project.</li>
<li>Get the latest
<ul>
<li>Git: pull -&gt; edit -&gt; pull -&gt; commit -&gt; pull -&gt;
push.</li>
<li>Perforce: get latest -&gt; check out files -&gt; edit -&gt;
submit</li>
</ul></li>
<li>Know your toolset
<ul>
<li>Git: UI client</li>
<li>Plastic SCM: Gluon</li>
<li>Perforce Helix Core: built-in Unity Editor tools</li>
</ul></li>
<li>Feature branches and Git Flow: main, hotfix, release, develop, etc.
Both Plastic SCM and Perforce have automated tools to help manage
merging branches back into mainline. Plastic SCM does this with the help
of <a
href="https://www.plasticscm.com/mergebot-devops?utm_source=demand-gen&amp;utm_medium=PDF&amp;utm_campaign=asset-links-gmg-achieve-quality&amp;utm_content=version-control-and-project-organization-ebook">MergeBot</a>,
and Perforce uses <a
href="https://www.perforce.com/products/helix-swarm">Helix Swarm</a> for
managing code reviews that can also be set up with automated
testing.</li>
</ul>
<p>The biggest takeaway is the importance of clear team communication.
As a team, you need to agree on your guidelines</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Which Splines Do You Need? A Comprehensive Dive into Common Splines</title>
    <url>/2023/05/03/18/22/</url>
    <content><![CDATA[<p>This post introduces some widely used splines in computer games
including Bézier curves, cubic Hermite splines, Catmull-Rom splines,
B-splines, Kochanek–Bartels splines, etc. We show these splines can be
bridged through re-formulation. Then, we focus on the extension and
generalization of Bézier curves and introduce mathematical methods to
create dynamic smooth splines. Last, we develop a simple Editor in
Unreal Engine to enable easy creation of splines under different
constraints and conditions.</p>
<span id="more"></span>
<h1 id="common-splines">Common Splines</h1>
<h2 id="bézier-curve">Bézier Curve</h2>
<p>The most typical and widely-used spline might be Bézier curves.
Bézier curve leverages a set of control points to define a smooth and
continuous curve generated by interpolation between these control
points. Using the De Casteljau's algorithm,<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> we
can easily express a Bézier curve in terms of a sum of Bernstein
polynomials:</p>
<p><span class="math display">\[
\mathbf{B}(t)=\sum_{i=0}^n\mathbf{p}_ib_{i,n}(t),
~b_{i,n}(t)=\binom{n}{i}(1-t)^{n-i}t^i
\]</span></p>
<p>When there are four control points, the generated curve is called
cubic Bézier curve. A cubic Bézier curve can be expanded as:</p>
<p><span class="math display">\[
\mathbf{B}(t)=(1-t)^3\mathbf{p}_0+3(1-t)^2t\mathbf{p}_1+3(1-t)t^2\mathbf{p}_2+t^3\mathbf{p}_3,~0\le
t\le 1
\]</span></p>
<p>The derivative of an <span class="math inline">\(n\)</span>-th order
curve is:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\mathbf{B}&#39;(t)&amp;=\left(\sum_{i=0}^n\mathbf{p}_ib_{i,n}(t)\right)&#39;\\
&amp;=\sum_{i=0}^n\mathbf{p}_i\binom{n}{i}\left((1-t)^{n-i}t^i\right)&#39;\\
&amp;=\sum_{i=0}^n\mathbf{p}_i\binom{n}{i}\left(-(n-i)(1-t)^{n-i-1}t^i+i(1-t)^{n-i}t^{i-1}\right)\\
&amp;=n\sum_{i=0}^{n-1}b_{i,n-1}(t)(\mathbf{p}_{i+1}-\mathbf{p}_i)
\nonumber
\end{aligned}
\end{equation}
\]</span></p>
<p>Similarly, we can obtain the second-order derivative:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\mathbf{B}&#39;&#39;(t)&amp;=n\sum_{i=0}^{n-1}\left(b_{i,n-1}(t)\right)&#39;(\mathbf{p}_{i+1}-\mathbf{p}_i)\\
&amp;=n\sum_{i=0}^{n-1}(\mathbf{p}_{i+1}-\mathbf{p}_i)\left(-(n-1-i)\binom{n-1}{i}(1-t)^{n-2-i}t^i+i\binom{n-1}{i}(1-t)^{n-1-i}t^{i-1}\right)\\
&amp;=n(n-1)\sum_{i=0}^{n-2}b_{i,n-2}(t)(\mathbf{p}_{i+2}-2\mathbf{p}_{i+1}+\mathbf{p}_i)
\nonumber
\end{aligned}
\end{equation}
\]</span></p>
<p>We will use these results later soon.</p>
<h3 id="degree-elevation">Degree elevation</h3>
<p>Suppose <span class="math inline">\(\mathbf{B}(t)\)</span> is an
<span class="math inline">\(n\)</span>-th order Bézier curve and we want
to elevate its degree to <span class="math inline">\(n+1\)</span>. We
can do this via the following process:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\mathbf{B}(t)&amp;=(1-t)\mathbf{B}(t)+t\mathbf{B}(t)\\
&amp;=(1-t)\sum_{i=0}^n\mathbf{p}_ib_{i,n}(t)+t\sum_{i=0}^n\mathbf{p}_ib_{i,n}(t)\\
&amp;=\sum_{i=0}^n\frac{n+1-i}{n+1}b_{i,n+1}(t)\mathbf{p}_i +
\sum_{i=0}^n\frac{i+1}{n+1}b_{i+1,n+1}(t)\mathbf{p}_i\\
&amp;=\sum_{i=0}^{n+1}\left(\frac{n+1-i}{n+1}\mathbf{p}_i+\frac{i}{n+1}\mathbf{p}_{i-1}\right)b_{i,n+1}(t)\\
&amp;=\sum_{i=0}^{n+1}\mathbf{p}&#39;_{i}b_{i,n+1}~~\left(\mathbf{p}&#39;_{i}=\frac{n+1-i}{n+1}\mathbf{p}_i+\frac{i}{n+1}\mathbf{p}_{i-1}\right)
\nonumber
\end{aligned}
\end{equation}
\]</span></p>
<p>Note that when <span class="math inline">\(i=0\)</span>, <span
class="math inline">\(\mathbf{p}&#39;_0=\mathbf{p}_0\)</span>, and when
<span class="math inline">\(i=n+1\)</span>, <span
class="math inline">\(\mathbf{p}&#39;_{n+1}=\mathbf{p}_n\)</span>. So
<span class="math inline">\(\mathbf{p}_{-1}\)</span> and <span
class="math inline">\(\mathbf{p}_{n+1}\)</span> can be arbitrary. We
simply set them to zero.</p>
<h3 id="composite-bézier-curves">Composite Bézier curves</h3>
<p>A composite Bézier curve is a series of Bézier curves joined end to
end where the first point of one curve coincides with the last point of
the previous curve. If a Bézier curve is composite, we say it's <span
class="math inline">\(\mathsf{C}^0\)</span> continuous.</p>
<p>However, sometimes we want higher degrees of continuity than <span
class="math inline">\(\mathsf{C}^0\)</span> at the joint of Bézier
curves (note that individual curves are <span
class="math inline">\(\mathsf{C}^\infty\)</span> within their own
inteval, and the discontinuity only happens at the meetings of
consecutive curves).</p>
<p>Given two Bézier curves <span
class="math inline">\([\mathbf{p}_0,\mathbf{p}_1,\mathbf{p}_2,\mathbf{p}_3]\)</span>
and <span
class="math inline">\([\mathbf{p}_3,\mathbf{p}_4,\mathbf{p}_5,\mathbf{p}_6]\)</span>,
we can define different degrees of continuity at <span
class="math inline">\(\mathbf{p}_3\)</span>:</p>
<ul>
<li><p><span class="math inline">\(\mathsf{C}^0/\mathsf{G}^0\)</span>
(positional continuity): consecutive Bézier curves meet at the same
point. This holds by definition. In this case, it's <span
class="math inline">\(\mathbf{p}_3\)</span>.</p></li>
<li><p><span class="math inline">\(\mathsf{C}^1\)</span> (velocity
continuity): the incoming and outgoing derivatives of <span
class="math inline">\(\mathbf{p}_3\)</span> are the same, vouching for a
smooth transition from the first curve to the second. To show this, we
let <span
class="math inline">\(\mathbf{B}&#39;(1)_\text{first}=\mathbf{B}&#39;(0)_\text{second}\)</span>,
and the solution is <span
class="math inline">\(3(\mathbf{p}_3-\mathbf{p}_2)=3(\mathbf{p}_4-\mathbf{p}_3)\)</span>.
This gives us <span
class="math inline">\(2\mathbf{p}_3=\mathbf{p}_2+\mathbf{p}_4\)</span>.
This equation tells us that <span
class="math inline">\(\mathbf{p}_2\)</span> and <span
class="math inline">\(\mathbf{p}_4\)</span> are not only colinear with
respect to <span class="math inline">\(\mathbf{p}_3\)</span>, but their
vector lengths are also the same. Rewriting this equation to <span
class="math inline">\(\mathbf{p}_4 = 2\mathbf{p}_3-\mathbf{p}_2\)</span>
suggests <span class="math inline">\(\mathbf{p}_4\)</span> is fully
determined by <span class="math inline">\(\mathbf{p}_2\)</span> and
<span class="math inline">\(\mathbf{p}_3\)</span> if we want <span
class="math inline">\(\mathsf{C}^1\)</span> continuity.</p></li>
<li><p><span class="math inline">\(\mathsf{G}^1\)</span> (tangent
continuity): <span class="math inline">\(\mathbf{p}_2\)</span> and <span
class="math inline">\(\mathbf{p}_4\)</span> are colinear but not
requiring their vector lengths to be equal. Thus, we say <span
class="math inline">\(\mathsf{G}^1\)</span> is less strict than <span
class="math inline">\(\mathsf{C}^1\)</span>. If a composite curve is
<span class="math inline">\(\mathsf{C}^1\)</span>, then it must be <span
class="math inline">\(\mathsf{G}^1\)</span>. To guarantee <span
class="math inline">\(\mathsf{G}^1\)</span>, we just add an extra degree
of freedom to the vector length: <span
class="math inline">\(\mathbf{p}_4=\mathbf{p}_3+\beta(\mathbf{p}_3-\mathbf{p}_2)~(\beta&gt;0)\)</span>.
<span class="math inline">\(\mathsf{G}^1\)</span> means the two curves
share a common tangent direction at the join point.</p></li>
<li><p><span class="math inline">\(\mathsf{C}^2\)</span> (acceleration
continuity): following a similar process to <span
class="math inline">\(\mathsf{C}^1\)</span> continuity, the <span
class="math inline">\(\mathsf{C}^2\)</span> continuity can be defined by
<span
class="math inline">\(\mathbf{p}_5=\mathbf{p}_1+4(\mathbf{p}_3-\mathbf{p}_2)\)</span>.
That is to say, <span class="math inline">\(\mathbf{p}_5\)</span> is
fully determined by <span class="math inline">\(\mathbf{p}_1,
\mathbf{p}_2\)</span> and <span
class="math inline">\(\mathbf{p}_3\)</span>. You should be very careful
of using <span class="math inline">\(\mathsf{C}^2\)</span> continuity:
the <span class="math inline">\(\mathsf{C}^2\)</span> continuity causes
a loss of two control points <span
class="math inline">\(\mathbf{p}_4\)</span> and <span
class="math inline">\(\mathbf{p}_5\)</span>, leaving only one free
control point <span class="math inline">\(\mathbf{p}_6\)</span>. You
perhaps cannot get the curve shape you expect. If you do not want to
loss control over these points, you can use uniform B-splines, which
will be introduced later.</p></li>
<li><p><span class="math inline">\(\mathsf{G}^2\)</span> (curvature
continuity): this type of continuity requires <span
class="math inline">\(k\mathbf{B}&#39;&#39;(1)_\text{first}=\mathbf{B}&#39;&#39;(0)_\text{second}~(k&gt;0)\)</span>
except requiring <span class="math inline">\(\mathsf{G}^1\)</span>,
i.e., satisfying <span
class="math inline">\(\mathbf{p}_5=\mathbf{p}_3+(\mathbf{p}_3-\mathbf{p}_2)(2\beta_1+\beta_1^2+\beta_2/2)+(\mathbf{p}_1-\mathbf{p}_2)\beta^2_1\)</span>.
To obtain this result, first expand <span
class="math inline">\(k\mathbf{B}&#39;&#39;(1)_\text{first}=\mathbf{B}&#39;&#39;(0)_\text{second}\)</span>
and then plug <span
class="math inline">\(\mathbf{p}_4=\mathbf{p}_3+\beta(\mathbf{p}_3-\mathbf{p}_2)\)</span>
in. Last, substitute for <span class="math inline">\(k\)</span> with
<span class="math inline">\(\beta_1^2\)</span> and <span
class="math inline">\(\beta\)</span> with <span
class="math inline">\(\beta_1+\beta_2/4\)</span>, and you will get the
right formula. Curvature continuity implies that the curves share a
common center of curvature at the join point.</p></li>
<li><p><span class="math inline">\(\mathsf{C}^3\)</span> (jolt
continuity): if a composite Bézier curve is <span
class="math inline">\(\mathsf{C}^3\)</span>, it satisfies <span
class="math inline">\(\mathbf{p}_6=\mathbf{p}_3+(\mathbf{p}_3-\mathbf{p}_0)+6(\mathbf{p}_1-2\mathbf{p}_2+\mathbf{p}_3)\)</span>.
In this case, the fist curve full determines the second curve and thus
the third, forth curve, etc. Now we say the generated composite Bézier
curve is <span class="math inline">\(\mathsf{C}^\infty\)</span> as there
is indeed no joins.</p></li>
</ul>
<p>If a curve is <span class="math inline">\(\mathsf{C}^n\)</span>, then
it must be <span class="math inline">\(\mathsf{G}^n\)</span>. If a curve
is <span class="math inline">\(\mathsf{C}^n/\mathsf{G}^n\)</span>, then
it must be <span
class="math inline">\(\mathsf{C}^{n-1}/\mathsf{G}^{n-1}\)</span>.</p>
<h3 id="rational-bézier-curves">Rational Bézier curves</h3>
<h2 id="cubic-hermite-splines">Cubic Hermite splines</h2>
<p>Cubic Hermite splines construct a curve based on two points along
with their respecive tangents.</p>
<p>Suppose the given starting point is <span
class="math inline">\(\mathbf{p}_0\)</span> at <span
class="math inline">\(t=0\)</span> and ending point <span
class="math inline">\(\mathbf{p}_1\)</span> at <span
class="math inline">\(t=1\)</span>, as well as the starting tangent
<span class="math inline">\(\mathbf{d}_0\)</span> and <span
class="math inline">\(\mathbf{d}_1\)</span>. The fitted cubic polynomial
can be defined by:</p>
<p><span
class="math display">\[\mathbf{p}(t)=(2t^3-3t^2+1)\mathbf{p}_0+(t^3-2t^2+t)\mathbf{d}_0+(-2t^3+3t^2)\mathbf{p}_1+(t^3-t^2)\mathbf{d}_1\]</span></p>
<p>Proof is quite simple. Assume our function is <span
class="math inline">\(\mathbf{p}(t)=at^3+bt^2+ct+d\)</span>, and given
that <span class="math inline">\(\mathbf{p}(0)=\mathbf{p}_0,
\mathbf{p}(1)=\mathbf{p}_1, \mathbf{p}&#39;(0)=\mathbf{d}_0,
\mathbf{p}&#39;(1)=\mathbf{d}_1\)</span>, we have:</p>
<p><span class="math display">\[
\begin{cases}
d&amp;=~\mathbf{p}_0\\
a+b+c+d&amp;=~\mathbf{p}_1\\
c&amp;=~\mathbf{d}_0\\
3a+2b+c&amp;=~\mathbf{d}_1
\end{cases}
\]</span></p>
<p>Solving it gives us:</p>
<p><span class="math display">\[
\mathbf{p}(t)=(2\mathbf{p}_0-2\mathbf{p}_1+\mathbf{d}_0+\mathbf{d}_1)t^3+(-3\mathbf{p}_0+3\mathbf{p}_1-2\mathbf{d}_0-\mathbf{d}_1)t^2+\mathbf{d}_0t+\mathbf{p}_0
\]</span></p>
<p>Rearranging <span class="math inline">\(\mathbf{p}(t)\)</span> gives
the equation proposed at the beginning.</p>
<p>We can also reformulate <span
class="math inline">\(\mathbf{p}(t)\)</span> in terms of Bézier curves
with respect to the four control points <span
class="math inline">\(\mathbf{p}_0,
\mathbf{p}_0+\frac{1}{3}\mathbf{d}_0,
\mathbf{p}_1-\frac{1}{3}\mathbf{d}_1,\mathbf{p}_1\)</span>. To show
this, recall that a cubic Bézier curve can be expresses as:</p>
<p><span class="math display">\[
\mathbf{B}(t)=\sum_{i=0}^n\mathbf{p}_ib_{i,n}(t),
~b_{i,n}(t)=\binom{n}{i}(1-t)^{n-i}t^i
\]</span></p>
<p>We can rewrite <span class="math inline">\(\mathbf{p}(t)\)</span> as
follows:</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{p}(t)&amp;=(2t^3-3t^2+1)\mathbf{p}_0+(t^3-2t^2+t)\mathbf{d}_0+(-2t^3+3t^2)\mathbf{p}_1+(t^3-t^2)\mathbf{d}_1\\
&amp;=(b_{0,3}(t)+b_{1,3}(t))\mathbf{p}_0+\frac{1}{3}b_{1,3}(t)\mathbf{d}_0+(b_{2,3}(t)+b_{3,3}(t))\mathbf{p}_1-\frac{1}{3}b_{2,3}(t)\mathbf{d}_1\\
&amp;=b_{0,3}(t)\mathbf{p}_0+b_{1,3}(t)\left(\mathbf{p}_0+\frac{1}{3}\mathbf{d}_0\right)+b_{2,3}(t)\left(\mathbf{p}_1-\frac{1}{3}\mathbf{d}_1\right)+b_{3,3}(t)\mathbf{p}_1
\end{aligned}
\]</span></p>
<p>This shows that a cubic Bézier curve that patches the control points
in the middle determines the tangents of the interpolation curve at the
respective outer points.<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
<h2 id="b-splines">B-splines</h2>
<h3 id="non-uniform-rational-b-spline-nurbs">Non-uniform rational
B-spline (NURBS)</h3>
<h2 id="beta-splines">Beta-splines</h2>
<h2 id="catmull-rom-splines">Catmull-Rom splines</h2>
<h1 id="connections-between-splines">Connections between Splines</h1>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"
role="doc-endnote"><p>https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"
role="doc-endnote"><p>https://en.wikipedia.org/wiki/Cubic_Hermite_spline<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>动画</tag>
        <tag>Spline</tag>
        <tag>Curve</tag>
        <tag>曲线</tag>
        <tag>插值</tag>
      </tags>
  </entry>
  <entry>
    <title>《Assassain&#39;s Creed Valhalla》玩后感</title>
    <url>/2020/11/12/23/23/</url>
    <content><![CDATA[<p><code>刺客信条：英灵殿</code>（Assassin's Creed
Valhalla，下称<code>英灵殿</code>）无疑是刺客信条“神话三部曲”中最成功的一部，无论是从游戏的质量上，还是从销售成绩上。在80个小时的主线与10多个小时的“内置DLC”游玩后，我个人对英灵殿的评价可以总结为“自我突破，承前启后”。说它自我突破是因为它革除了起源和奥德赛中的绝大部分缺点，在自我的改进中完成了里程碑式的跨越；说它承前启后式因为它标志着刺客信条系列一次华丽而成功的转型与过渡，是游戏特色与市场充分交合后的最佳发展方向，是游戏缺点自我祓除与优点渐进式凸显的结果。本文将重点从游戏的任务系统、剧情节奏和人物刻画这三个方面介绍英灵殿的蜕变，至于游戏画面和风景，<del>还有育碧特色BUG，</del>都是刺客信条系列经典的历史特征了，在本文不再赘述。</p>
<span id="more"></span>
<h1
id="任务系统众星捧月映空青稀光散落满夜明">任务系统：众星捧月映空青，稀光散落满夜明</h1>
<h1
id="剧情节奏一马平川驰此间峰峦叠嶂牛羊见">剧情节奏：一马平川驰此间，峰峦叠嶂牛羊见</h1>
<h1
id="人物刻画穷极千里观百态瓦泥滂沱照众生">人物刻画：穷极千里观百态，瓦泥滂沱照众生。</h1>
<h1
id="总结长路漫漫终将至共邀朝阳行远方">总结：长路漫漫终将至，共邀朝阳行远方。</h1>
<p><img data-src="/images/acv-impression/1.png" /></p>
<p><img data-src="/images/acv-impression/2.png" /></p>
<p><img data-src="/images/acv-impression/3.png" /></p>
<p><img data-src="/images/acv-impression/4.png" /></p>
<p><img data-src="/images/acv-impression/5.png" /></p>
<p><img data-src="/images/acv-impression/6.png" /></p>
<p><img data-src="/images/acv-impression/7.png" /></p>
<p><img data-src="/images/acv-impression/8.png" /></p>
<p><img data-src="/images/acv-impression/9.png" /></p>
<p><img data-src="/images/acv-impression/10.png" /></p>
<p><img data-src="/images/acv-impression/11.png" /></p>
<p><img data-src="/images/acv-impression/12.png" /></p>
<p><img data-src="/images/acv-impression/13.png" /></p>
<p><img data-src="/images/acv-impression/14.png" /></p>
<p><img data-src="/images/acv-impression/15.png" /></p>
<p><img data-src="/images/acv-impression/16.png" /></p>
<p><img data-src="/images/acv-impression/17.png" /></p>
]]></content>
      <categories>
        <category>游戏 - 玩后感</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>生活</tag>
        <tag>刺客信条</tag>
      </tags>
  </entry>
  <entry>
    <title>ComponentCameraSystem - A Simplified Camera System for You to Create Plentiful Gameplay Camera Movements and Effects</title>
    <url>/2023/02/09/23/21/</url>
    <content><![CDATA[<p><strong>ComponentCameraSystem</strong> is a simplified, extensible
and designer-friendly camera system for Unreal Engine. It enhances the
built-in spring arm and camera components in native Unreal editor across
a wide variety of common gameplay camera behaviours such as keeping a
target at a fixed screen position, moving on rail, and resolving
occulusion in complex occasions, enabling you to easily create plentiful
smooth camera movements and effects within only few minutes. Go to the
<a
href="https://sulleyyys-organization.gitbook.io/manuals-of-ccs/">Documentation</a>
for more details.</p>
<p>Currently <strong>ComponentCameraSystem</strong> supports Unreal
Engine versions &gt;= 5.0. So before using this plugin, please upgrade
your project to Unreal Engine 5.0 at its minimum version
requirement.</p>
<p>You can buy this plugin at Unreal <a
href="https://www.unrealengine.com/marketplace/en-US/product/component-camera-system">Marketplace</a>.
Persistent upgrade will be made to make it more stable and support more
features.</p>
]]></content>
      <categories>
        <category>游戏 - 相机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>游戏</tag>
        <tag>UE</tag>
        <tag>插件</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/07/23/00/</url>
    <content><![CDATA[<p>之前因为重装系统，所以hexo源文件全都消失了，包括写的所有文章（/(ㄒoㄒ)/~~），于是重新部署了一下Blog，换了个更清新的，也是新的一年新的盼头吧！这告诫我们，一定要备份！</p>
<span id="more"></span>
<h1 id="测试">测试</h1>
<h2 id="代码">代码</h2>
<p>现在来测试一下代码</p>
<details class="note info no-icon"><summary><p>This is a code test</p>
</summary>
<h4 id="details-and-code">Details and code</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure>

</details>
<h2 id="latex">Latex</h2>
<p><span class="math display">\[f(x)=\sum_{k=1}^N k^2\]</span></p>
]]></content>
  </entry>
  <entry>
    <title>无穷连根式求极限的充要条件</title>
    <url>/2020/09/09/18/52/</url>
    <content><![CDATA[<p>在刷习题集或者考试的时候我们经常会遇到诸如<span
class="math inline">\(\sqrt{1+\sqrt{2+\sqrt{3+\cdots}}}\)</span>或者<span
class="math inline">\(\sqrt{2+\sqrt{2+\sqrt{2+\cdots}}}\)</span>的极限求解或极限存在性证明。解决此类问题的方法有很多，但都可以归结为一点：缩放。要么是两端缩放然后夹逼定理，要么是证明有界然后两边取极限。本文记录此类问题极限存在的一个充要条件，以供参阅。</p>
<span id="more"></span>
<h1 id="ramanujans-problem">Ramanujan's Problem</h1>
<p>这类问题最著名的是拉马努金（Ramanujan）所提出的恒等式：</p>
<blockquote>
<p>证明: <span
class="math display">\[3=\sqrt{1+2\sqrt{1+3\sqrt{1+\cdots}}}\tag{1}\]</span></p>
</blockquote>
<p>这个等式的证明是简单而有趣的：</p>
<p><span class="math display">\[3=\sqrt{1+2\cdot
4}=\sqrt{1+2\sqrt{1+3\cdot
5}}=\sqrt{1+2\sqrt{\cdots+n\sqrt{1+(n+1)(n+3)}}}\]</span></p>
<p>同时，Ramanujan还断言下面的结论：</p>
<p><span
class="math display">\[\lim_{n\to\infty}\sqrt{1+2\sqrt{1+\cdots+n\sqrt{1}}}=3\]</span></p>
<p>这个的证明也是容易的。首先把上式和（1）式比较，就发现上式以3为上界，并且由单调性可知，其极限是存在的。为了证明<span
class="math inline">\(a_n=\sqrt{1+2\sqrt{1+\cdots+n\sqrt{1}}}\)</span>的极限就是3，我们证明：对任意的<span
class="math inline">\(3&gt;\epsilon&gt;0\)</span>，都存在<span
class="math inline">\(N\)</span>，使得所有的<span
class="math inline">\(n&gt;N\)</span>都有<span
class="math inline">\(a_n&gt;3-\epsilon\)</span>。</p>
<p>现在任取<span
class="math inline">\(0&lt;\epsilon&lt;3\)</span>，令<span
class="math inline">\(3-\epsilon=3r\)</span>，故<span
class="math inline">\(0&lt;r=1-\epsilon/3&lt;1\)</span>，故有：</p>
<p><span
class="math display">\[3-\epsilon=3r=r\sqrt{1+2\sqrt{\cdots+n\sqrt{1+(n+1)(n+3)}}}\]</span></p>
<p>把<span class="math inline">\(r\)</span>乘进去，就有：</p>
<p><span
class="math display">\[3-\epsilon=\sqrt{r^2+2\sqrt{r^{2^2}+\cdots+n\sqrt{r^{2^n}[1+(n+1)(n+3)]}}}\tag{2}\]</span></p>
<p>由于<span class="math inline">\(1&gt;r^{2^i},\forall
i=1,2,\cdots\)</span>，且存在<span
class="math inline">\(N\)</span>，当<span
class="math inline">\(n&gt;N\)</span>时，有</p>
<p><span
class="math display">\[1&gt;r^{2^n}[1+(n+1)(n+2)]=r^{2^n}(n+2)^2\]</span></p>
<p>把这些全部带入（2）式，就可以证明：</p>
<p><span
class="math display">\[3-\epsilon=\sqrt{r^2+2\sqrt{r^{2^2}+\cdots+n\sqrt{r^{2^n}[1+(n+1)(n+3)]}}}&lt;\sqrt{1+2\sqrt{1+\cdots+n\sqrt{1}}}=a_n,n&gt;N\]</span></p>
<p>从而完成证明。</p>
<h1 id="polyas-criterionpolya准则">Polya's Criterion（Polya准则）</h1>
<p>在考虑普遍情况下首先来观察一些特例，一个典型的特例就是形如<span
class="math inline">\(\sqrt{a_1+\sqrt{a_2+\cdots}}\)</span>的无穷根式，每个根号的次数都是<span
class="math inline">\(2\)</span>，或者幂次都是<span
class="math inline">\(2^{-1}\)</span>。对于<span
class="math inline">\(a_1\)</span>来看，控制它的幂次是<span
class="math inline">\(\frac{1}{2}\)</span>，对于<span
class="math inline">\(a_2\)</span>来说，控制它的幂次是<span
class="math inline">\(2^{-2}\)</span>，对于<span
class="math inline">\(a_n\)</span>来说，控制它的幂次是<span
class="math inline">\(2^{-n}\)</span>。假设这个无穷根式极限存在，那么我们关心的肯定是<span
class="math inline">\(n\)</span>足够大时，它被什么控制，显然是<span
class="math inline">\(a_n\)</span>及控制它的<span
class="math inline">\(2^{-n}\)</span>的幂次。所以，一个合理的猜测是，如果<span
class="math inline">\(a_n^{2^{-n}}\)</span>极限存在，那么该根式就收敛。下面我们将看到，这个猜测已经非常接近“真相”，甚至是真相的一部分。</p>
<h2 id="description">Description</h2>
<p>设序列<span
class="math inline">\(u_n=\sqrt{a_1+\sqrt{a_2+\cdots+\sqrt{a_n}}}\)</span>，则<span
class="math inline">\(\{u_n\}\)</span>可以用下述条件判定：</p>
<p><span class="math display">\[
\begin{cases}
\text{converges},&amp;\text{if}\;
\overline{\lim}_{n\to\infty}\frac{\log\log a_n}{n}&lt;\log 2\\
\text{diverges},&amp;\text{if}\;
\overline{\lim}_{n\to\infty}\frac{\log\log a_n}{n}&gt;\log 2
\end{cases}
\]</span></p>
<p>上述准则还可以进一步推广为：</p>
<blockquote>
<p>序列<span class="math inline">\(\{u_n\}\)</span>收敛的充要条件是：
<span class="math display">\[\overline{\lim_{n\to\infty}} n \left(
\frac{\log\log a_n}{n}-\log2 \right) &lt;+\infty\tag{3}\]</span></p>
</blockquote>
<p>注意到，这个极限可以取有限数或者负无穷。我们将在陈述下面的<strong>定理一</strong>之后进行证明。</p>
<blockquote>
<p><strong>（定理一）</strong> 序列<span
class="math inline">\(u_n=\sqrt{a_1+\sqrt{a_2+\cdots+\sqrt{a_n}}}\)</span>收敛当且仅当存在有限上极限
<span
class="math display">\[\overline{\lim_{n\to\infty}}a_n^{2^{-n}}&lt;+\infty\]</span></p>
</blockquote>
<p>首先证明<em>必要性</em>，即假定<span
class="math inline">\(\{u_n\}\)</span>收敛。因为<span
class="math inline">\(u_n\ge a_n^{2^{-n}}\)</span>，故<span
class="math inline">\(\overline{\lim}_{n\to\infty}a_n^{2^{-n}}\)</span>一定是有限的，得证。</p>
<p>再来证明<em>充分性</em>。假定<span
class="math inline">\(\overline{\lim}_{n\to\infty}a_n^{2^{-n}}&lt;+\infty\)</span>，则存在<span
class="math inline">\(G&gt;0\)</span>使得对所有<span
class="math inline">\(n&gt;0\)</span>，有<span
class="math inline">\(a_n^{2^{-n}}\le G\)</span>，因此<span
class="math inline">\(a_n\le G^{2^n}\)</span>。从而有：</p>
<p><span class="math display">\[u_n\le
\sqrt{G^2+\sqrt{G^{2^2}+\cdots+\sqrt{G^{2^n}}}}=G\sqrt{1+\sqrt{1+\cdots+\sqrt{1}}}\]</span></p>
<p>同时又因为</p>
<p><span
class="math display">\[2=\sqrt{2+2}=\sqrt{2+\sqrt{2+2}}=\cdots=\sqrt{2+\sqrt{2+\cdots+\sqrt{2+2}}}&gt;\sqrt{1+\sqrt{1+\cdots+\sqrt{1}}}\]</span></p>
<p>从而有<span class="math inline">\(u_n&lt;2G,\forall
n&gt;0\)</span>，又由<span
class="math inline">\(\{u_n\}\)</span>的单调性知收敛。</p>
<p>到此为止，我们发现<strong>定理一</strong>和开始我们的猜测是非常相似的，只是<strong>定理一</strong>只需要上极限，这比我们的猜测更加宽松。下面我们利用此定理证明Polya's
Criterion.</p>
<h2 id="proof-of-polyas-criterion">Proof of Polya's Criterion</h2>
<p>当<span
class="math inline">\(\overline{\lim}_{n\to\infty}\frac{\log\log
a_n}{n}&lt;\log 2\)</span>时，存在<span
class="math inline">\(N\)</span>，当<span
class="math inline">\(n&gt;N\)</span>时<span
class="math inline">\((\log\log a_n)/n&lt;\log 2\)</span>，也即<span
class="math inline">\(a_n^{2^{-n}}&lt;\mathrm{e}\)</span>，由<strong>定理一</strong>知<span
class="math inline">\(\{u_n\}\)</span>收敛。</p>
<p>当<span
class="math inline">\(\overline{\lim}_{n\to\infty}\frac{\log\log
a_n}{n}&gt;\log 2\)</span>时，存在某个<span
class="math inline">\(a&gt;1\)</span>，对某些无限的<span
class="math inline">\(n\)</span>，使得<span
class="math inline">\((\log\log a_n)/n&gt;a\log 2\)</span>，也即<span
class="math inline">\(\log a_n&gt;2^{an}\)</span>。因此，对这些<span
class="math inline">\(n\)</span>而言：</p>
<p><span
class="math display">\[a_n^{2^{-n}}&gt;e^{2^{(a-1)n}}\]</span></p>
<p>因此<span
class="math inline">\(\overline{\lim}_{n\to\infty}a_n^{2^{-n}}=+\infty\)</span>.</p>
<p>最后考虑<span
class="math inline">\(\overline{\lim}_{n\to\infty}\frac{\log\log
a_n}{n}=\log 2\)</span>。</p>
<p>若<span class="math inline">\(\{u_n\}\)</span>收敛，则<span
class="math inline">\(\overline{\lim}_{n\to\infty}a_n^{2^{-n}}\)</span>有限，即存在<span
class="math inline">\(G&gt;1\)</span>对所有<span
class="math inline">\(n\)</span>成立<span
class="math inline">\(a_n^{2^{-n}}&lt;G\)</span>，因而<span
class="math inline">\(\log a_n&lt;2^n\log G\)</span>。此时若<span
class="math inline">\(a_n&gt;1\)</span>，则</p>
<p><span class="math display">\[n\left(\frac{\log\log
a_n}{n}-\log2\right)&lt;\log\log G\]</span></p>
<p>而当<span class="math inline">\(a_n\le 1\)</span>时，按照约定有<span
class="math inline">\((\log\log
a_n)/n=-\infty\)</span>，则综上公式（3）的必要性得证。</p>
<p>同时公式（3）也是充分的。假定条件成立但<span
class="math inline">\(\{u_n\}\)</span>不收敛，则由<strong>定理一</strong>知<span
class="math inline">\(\overline{\lim}_{n\to\infty}a_n^{2^{-n}}=+\infty\)</span>，则对任意的<span
class="math inline">\(G&gt;\mathrm{e}\)</span>，有充分大的<span
class="math inline">\(n\)</span>使得<span
class="math inline">\(a_n^{2^{-n}}&gt;G\)</span>，从而<span
class="math inline">\(\log a_n&gt;2^n\log G\)</span>，于是有</p>
<p><span class="math display">\[n\left(\frac{\log\log
a_n}{n}-\log2\right)&gt;\log\log G\]</span></p>
<p>这说明上极限是无穷大，与假设矛盾。充分性得证。</p>
<h2 id="examples">Examples</h2>
<h3 id="例一">例一</h3>
<p>现在我们考虑一个序列<span
class="math inline">\(u_n=\sqrt{x+\sqrt{x+\cdots+\sqrt{x}}}\)</span>，当<span
class="math inline">\(x&lt;1\)</span>的时候，它的上界是<span
class="math inline">\(\sqrt{1+\sqrt{1+\cdots}}\)</span>，而后者我们上面已经证明了它的上界是2。现在我们考虑<span
class="math inline">\(x&gt;1\)</span>的情景。此时有：</p>
<p><span
class="math display">\[u_n&lt;\sqrt{x^2+\sqrt{x^{2^2}+\cdots+\sqrt{x^{2^n}}}}&lt;2x\]</span></p>
<p>所以我们证明了，对<span
class="math inline">\(x&gt;0\)</span>，序列<span
class="math inline">\(\{u_n\}\)</span>都是收敛的，并且没有使用<strong>定理一</strong>。</p>
<h3 id="例二">例二</h3>
<p>现在考虑下述恒等式：</p>
<p><span
class="math display">\[x(2^n+x)=x\sqrt{2^{2n}+x(2^{n+1}+x)}\]</span></p>
<p>于是可以立即得到：</p>
<p><span class="math display">\[
\begin{aligned}
x(2+x)&amp;=x\sqrt{2^2+x(2^2+x)}\\
&amp;=x\sqrt{2^2+x\sqrt{2^4+x(2^4+x)}}\\
&amp;=\cdots\\
&amp;=x\sqrt{2^2+x\sqrt{2^4+\cdots+x\sqrt{2^{2n}+x(2^{n+1}+x)}}}\\
&amp;=x\sqrt{2^2+x\sqrt{2^4+x\sqrt{\cdots}}}
\end{aligned}
\]</span></p>
<p>现在令<span class="math inline">\(x=1\)</span>，就有：</p>
<p><span
class="math display">\[3=\sqrt{2^2+\sqrt{2^4+\cdots}}\]</span></p>
<p>用<span class="math inline">\(x/2\)</span>替换<span
class="math inline">\(x\)</span>，有：</p>
<p><span
class="math display">\[2+\frac{x}{2}=\sqrt{2^2+\frac{x}{2}\sqrt{2^4+\frac{x}{2}\sqrt{2^6+\cdots}}}\]</span></p>
<p>两边约去2，就有：</p>
<p><span
class="math display">\[1+\frac{x}{4}=\sqrt{1+\frac{x}{2}\sqrt{1+\frac{x}{2^2}\sqrt{1+\cdots}}}\]</span></p>
<h3 id="例三">例三</h3>
<p>由余弦二倍角公式<span
class="math inline">\(\cos2\theta=2\cos^2\theta-1\)</span>可知：</p>
<p><span
class="math display">\[2\cos\theta=\sqrt{2+2\cos2\theta}=\sqrt{2+\sqrt{2+\cdots+\sqrt{2+2\cos
2^n\theta}}}\]</span></p>
<p>此时令<span
class="math inline">\(\theta=\frac{\pi}{2^{n+1}}\)</span>，就有：</p>
<p><span
class="math display">\[2\cos\frac{\pi}{2^{n+1}}=\sqrt{2+\sqrt{2+\cdots+\sqrt{2+0}}}\Rightarrow\\\\
\cos\frac{\pi}{2^{n+1}}=\sqrt{\frac{1}{2}+\frac{1}{2}\sqrt{\frac{1}{2}+\cdots+\frac{1}{2}\sqrt{\frac{1}{2}}}}\]</span></p>
<p>所以可以立刻得到下式的极限：</p>
<p><span
class="math display">\[\lim_{n\to\infty}4^n\left(1-\sqrt{\frac{1}{2}+\frac{1}{2}\sqrt{\frac{1}{2}+\cdots+\frac{1}{2}\sqrt{\frac{1}{2}}}}\right)\\\\
=\lim_{n\to\infty}4^n\left(1-\cos\frac{\pi}{2^{n+1}}\right)\\\\
=\lim_{n\to\infty}4^n\cdot\frac{\pi^2}{2^{2n+2+1}} (1-\cos x\sim
\frac{1}{2}x^2)\\\\
=\frac{\pi^2}{8}\]</span></p>
<h1 id="herschfelds-convergence-theorem-herschfeld收敛定理">Herschfeld’s
Convergence Theorem （Herschfeld收敛定理）</h1>
<p>Polya's Criterion只考虑了指数为<span
class="math inline">\(\frac{1}{2}\)</span>的情况，对于更加普遍的情况，即形如<span
class="math inline">\(u_n=(a_1+(a_2+(\cdots+a_n^{r_n}))^{r_2})^{r_1}
(a_i\ge 0,0&lt;r_i\le 1)\)</span>的序列，Herschfeld’s Convergence
Theorem给出了一个其收敛的充要条件。</p>
<p><a
href="https://www.tandfonline.com/doi/abs/10.1080/00029890.1935.11987745?journalCode=uamm20">Herschfeld’s
Convergence Theorem</a> 告诉我们了一个无穷根式收敛的充要条件：</p>
<blockquote>
<p>设序列<span
class="math inline">\(u_n=(a_1+(a_2+(\cdots+a_n^{r_n}))^{r_2})^{r_1}
(a_i\ge 0,0&lt;r_i\le 1)\)</span>且级数<span
class="math inline">\(S=\sum_{i=1}^\infty r_1r_2\cdots
r_i\)</span>收敛，则序列<span
class="math inline">\(\{u_n\}\)</span>收敛的充分必要条件是： <span
class="math display">\[\overline{\lim_{n\to\infty}}a_n^{r_1r_2\cdots
r_n}&lt;+\infty\]</span></p>
</blockquote>
<p>这个定理的证明之后有空了补充。</p>
<h1 id="后记">后记</h1>
<p>实际上无穷根式分为右无穷根式（Right Infinite
Radicals）和左无穷根式（Left Infinite
Radicals）两种，这里重点讨论的是右无穷根式的情况，左无穷根式可以仿照进行推导。</p>
]]></content>
      <categories>
        <category>数学 - 数学分析</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一道有趣的概率题</title>
    <url>/2022/10/20/23/59/</url>
    <content><![CDATA[<p>设<span class="math inline">\(X_1,X_2,\cdots\sim
U(0,1)\)</span>独立同分布，令<span
class="math inline">\(\tau:=\min_n\{n\vert X_1+\cdots+X_{n-1}\le1 \wedge
X_1+\cdots+X_{n-1}+X_n&gt;1\}\)</span>，求<span
class="math inline">\(\mathbb{E}[X_1+\cdots+X_\tau]\)</span>。换句话说，我们要求最先使得若干个独立同分布于<span
class="math inline">\((0,1)\)</span>的随机变量之和大于<span
class="math inline">\(1\)</span>的期望。</p>
<span id="more"></span>
<h1 id="问题定义">问题定义</h1>
<p>这个问题的定义已经定义在上面了，这里再复述一遍：</p>
<p>设<span class="math inline">\(X_1,X_2,\cdots\sim
U(0,1)\)</span>独立同分布，令<span
class="math inline">\(\tau:=\min_n\{n\vert X_1+\cdots+X_{n-1}\le1 \wedge
X_1+\cdots+X_{n-1}+X_n&gt;1\}\)</span>，求<span
class="math inline">\(\mathbb{E}[X_1+\cdots+X_\tau]\)</span>。</p>
<h1 id="引入函数">引入函数</h1>
<p>乍一看这个题似乎无从下手，但是我们可以发现这里<span
class="math inline">\(&gt;1\)</span>这个条件似乎可以换成任意一个<span
class="math inline">\(&gt;t
(t&gt;0)\)</span>，这启发我们用一个函数去表示我们要求的式子，然后通过求解一个“递推式”（实际上是一个微分方程）解出这个函数，进而得到某个具体点的值。</p>
<p>从这个思路出发，我们不妨定义<span
class="math inline">\(\tau_t:=\min_n\{n\vert X_1+\cdots+X_{n-1}\le t
\wedge X_1+\cdots+X_{n-1}+X_n&gt;t\}\)</span>，进而令<span
class="math inline">\(f(t):=\mathbb{E}[X_1+\cdots+X_{\tau_t}]\)</span>。显然，我们的目标就是求<span
class="math inline">\(f(1)\)</span>。</p>
<h1 id="求解方程">求解方程</h1>
<p>那么，怎么求出<span
class="math inline">\(f(t)\)</span>呢？注意题目中的条件<span
class="math inline">\(X_1,X_2,\cdots\sim
U(0,1)\)</span>独立同分布，因此我们可以把<span
class="math inline">\(f(t)\)</span>里面的<span
class="math inline">\(X_1\)</span>拆出来，变成：</p>
<p><span
class="math display">\[f(t)=\mathbb{E}[X_1]+\mathbb{E}[X_2+\cdots+X_{\tau_t}]\]</span></p>
<p>为了简便起见，我们不妨限定<span
class="math inline">\(t&lt;1\)</span>。此时考虑两种情况：<span
class="math inline">\(X_1=s&gt;t\)</span>和<span
class="math inline">\(X_1=s\le t\)</span>。</p>
<p>如果<span class="math inline">\(s&gt;t\)</span>，那么<span
class="math inline">\(f(t)\)</span>就等于<span
class="math inline">\(\mathbb{E}[X_1]\)</span>，所以这等价<span
class="math inline">\(f(t|s&gt;t)=\mathbb{E}[X_1\vert
X_1&gt;t]=\dfrac{1-t^2}{2}\)</span>。</p>
<p>如果<span class="math inline">\(s\le
t\)</span>，那么就相当于后面的<span
class="math inline">\(X_2+\cdots+X_{\tau_t}&gt;t-s\)</span>且<span
class="math inline">\(X_2+\cdots+X_{\tau_t-1}\le
t-s\)</span>，再由独立同分布知道这就是<span
class="math inline">\(f(t-s)\)</span>，但这是以<span
class="math inline">\(X_t=s\le t\)</span>为条件的，所以实际上还要对<span
class="math inline">\(s\)</span>求个积分，也就是：</p>
<p><span class="math display">\[f(t|s\le
t)=\frac{t^2}{2}+\int_{0}^tf(t-s)\mathrm{d}s\]</span></p>
<p>把上面两个加起来，就有：</p>
<p><span class="math display">\[f(t)=f(t|s\le
t)+f(t|s&gt;t)=\frac{1}{2}+\int_0^tf(x)\mathrm{d}x\]</span></p>
<p>进而得到微分方程及其初始值：</p>
<p><span
class="math display">\[f&#39;(t)=f(t),~~f(0)=\frac{1}{2}\]</span></p>
<p>很容易求解得到<span
class="math inline">\(f(t)=\mathrm{e}^t/2\)</span>，所以我们就能得到最终的答案<span
class="math inline">\(f(1)=\mathrm{e}/2\)</span>。</p>
]]></content>
      <categories>
        <category>数学 - 概率论</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率论</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《游戏设计的236个技巧》笔记</title>
    <url>/2021/08/17/01/07/</url>
    <content><![CDATA[<p>本文是《游戏设计的236个技巧：游戏机制、关卡设计和镜头窍门》的笔记。</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>一款优秀的游戏是如何让玩家在某个瞬间感到无比有趣、极度畅快的呢？本书旨在引领读者发现“让游戏更有趣的设计技巧”。
本书将内容分为“玩家角色”“敌人角色”“关卡设计”“碰撞检测”“镜头”五个部分。</p>
<h1 id="让3d游戏更有趣的玩家角色技术">让3D游戏更有趣的玩家角色技术</h1>
<h2
id="能够吸引2d游戏玩家的3d游戏设计技巧超级马里奥兄弟超级马里奥3d大陆">能够吸引2D游戏玩家的3D游戏设计技巧（《超级马里奥兄弟》《超级马里奥3D大陆》）</h2>
<ul>
<li>马里奥飞奔的感觉让人很舒服。
<ul>
<li>按住十字键开始加速，即使放开十字键也不会马上停住，而是有惯性。</li>
<li>按B键冲刺的过程中按反方向键，就会出现一个急刹车的动作。</li>
</ul></li>
<li>但是塞尔达中林克就没有惯性，让玩家精准停在想停的位置。</li>
<li>这是因为游戏想带给玩家的<strong>游戏体验</strong>不同。
<ul>
<li>塞尔达的游戏体验是探索与战斗：不需要过多关注奔跑的细节动作。</li>
<li>超级马里奥的游戏体验是单人挑战障碍赛跑：关注如何更快奔跑、转弯、准确停止并穿越障碍物。将“无法简单停止”作为一种操纵上的风险加入游戏，除了能给游戏带来紧张感之外，还能让玩家在熟悉操作之后获得成就感。</li>
</ul></li>
</ul>
<h3
id="b键冲刺带来的感官刺激以及风险与回报的趣味性">B键冲刺带来的感官刺激以及风险与回报的趣味性</h3>
<ul>
<li>操纵冲刺中的马里奥会给玩家带来畅快感。
<ul>
<li>通过运动或动作获得感官上的舒畅体验的过程称为<strong>感官体验</strong>。</li>
</ul></li>
<li>有趣秘密还在挑战中蕴含的风险与回报。
<ul>
<li>马里奥通过加速的移动实现了风险与回报，玩家按住B是一种主动提高风险与回报的行为。<br />
</li>
</ul></li>
<li>在超级马里奥兄弟之前，动作类游戏的跳跃一直都是跳跃到固定高度，但是超马采用了按键时长与跳跃高度相关的机制。</li>
<li>在跳跃时按方向键可以控制马里奥在空间左右移动。</li>
<li>在跳跃过程中碰到墙壁等障碍物不会下落，这虽然有悖物理，但是给了玩家更舒适的游戏体验。</li>
</ul>
<h3 id="勾起玩家跳跃冲动的互动式玩法">勾起玩家跳跃冲动的互动式玩法</h3>
<ul>
<li>宫本茂说：“我认为互动的乐趣之一在于：一个人对自己的某种想法付诸实践之后，能够获得相应的反馈”。</li>
<li>《超马》为跳跃这一动作准备了大量的反馈。
<ul>
<li><strong>操作复杂度&lt;动作数&lt;反馈数</strong>。</li>
<li>即用较少的动作获得较多的反馈。</li>
</ul></li>
<li>那么《超马》凭什么让人能够不自由自主地想要按下跳跃键呢？
<ul>
<li>存在让玩家不由自主想要去实践地机制，称其为“游戏的钓饵”。比如玩家用小马里奥顶砖块，获得的反应是砖块向上被拱起这一动画。
这一动画会在玩家心中放下一个钓饵，让玩家觉得砖块里藏着什么。</li>
<li>游戏里一定要有<strong>引诱玩家付诸实践的钓饵</strong>。</li>
</ul></li>
</ul>
<h3 id="从2d马里奥到3d马里奥">从《2D马里奥》到《3D马里奥》</h3>
<ul>
<li>《3D马里奥》出乎意料地取消了移动动作的惯性，可能是因为3D视角的距离感相比2D要更难以掌握，加入惯性会使操作难度上升。</li>
<li>《3D马里奥》中镜头角度局限在了“侧面”“上方”“倾斜”三种固定模式中，而不是像一般3D游戏将视角决定权交给玩家。同时，滑垫也被限制在了16个方向以内，让镜头角度与移动角度保持一致，从而<strong>帮助玩家找回2D游戏的感觉</strong>，同时也避免了因斜向移动导致误判跳跃距离。</li>
<li>同时，在《超级马里奥3D大陆》中还首次加入了在跳跃过程中改变方向的机制。</li>
<li>加入了翻滚、远跳、翻滚跳等动作，吸引高端玩家重复挑战关卡。</li>
</ul>
<h3 id="小结">小结</h3>
<ul>
<li>要给玩家带来“感官刺激”“风险与回报”“动作与反应”和“连环钓饵”。</li>
<li>游戏体验的真实性并不仅取决于贴图和声效等外观因素，通过游戏内部机制表现出的“互动的乐趣”也有巨大影响。</li>
</ul>
<h2
id="让游戏更具临场感的玩家角色动作设计技巧战神三">让游戏更具临场感的玩家角色动作设计技巧（战神三）</h2>
<h3 id="不需控制镜头的移动操作机制">不需控制镜头的移动操作机制</h3>
<ul>
<li>战神是TPS游戏，角色的移动方向与遥感倾斜方向一致。也会自动选取最佳角度。</li>
<li>采用自动镜头的3D动作游戏需要很好地处理镜头移动。
<ul>
<li>可以<strong>为每个场景设置不同风格的自动镜头</strong>，同时让玩家体验到2D游戏简单而又直观的操作感，以及3D游戏身临其境般的操作感。</li>
<li>通过自动镜头，战神三创造出了电影般的临场感与魄力。</li>
</ul></li>
</ul>
<h3
id="实现快节奏战斗的玩家移动动作机制">实现快节奏战斗的玩家移动动作机制</h3>
<ul>
<li>要实现快节奏战斗，玩家必须能够灵活转身、迅速静止，因此战神三的静止具有即时性，同时旋转左摇杆可以实现角色的原地旋转。</li>
<li>《怪猎4》玩家的转身半径要大于战神三，原地回头的时间也略长。
<ul>
<li>怪猎4想创造出“狩猎”的感觉。</li>
</ul></li>
<li>每个游戏都有一套能让玩家觉得舒服的“<strong>速度</strong>”（转身速度、移动速度、拔刀速度、收刀速度、硬直速度）“<strong>节奏</strong>”（具体的动作设计、动作之间的连贯性）和“<strong>触感</strong>”（动作的打击感）。根据这三点找出合适的玩家角色动作机制，是现代游戏开发的重点。</li>
</ul>
<h3 id="不带来烦躁感的地图切换机制">不带来烦躁感的地图切换机制</h3>
<ul>
<li>战神三在切换地图之后玩家仍然<strong>继承之前的移动方向</strong>。只要玩家不放开左摇杆方向，就会继续沿着切换前的方向行进。</li>
<li>3D动作游戏的核心是：<strong>让玩家角色的动作准确反映玩家意图</strong>。</li>
</ul>
<h3
id="让人不由得手指发力的玩家角色动作机制">让人不由得手指发力的玩家角色动作机制</h3>
<ul>
<li>为烘托角色服务的动作需要由<strong>互动动作</strong>实现。
<ul>
<li>比如开宝箱这个动作需要玩家长按R1，主角运足全身力量掀开宝箱的动画贯彻玩家按键始终，引得玩家下意识加大按键力道。</li>
<li>开门同理。</li>
<li>这种称为<strong>互动性演出</strong>。</li>
</ul></li>
</ul>
<h3 id="小结-1">小结</h3>
<ul>
<li>战神三在角色动作上的设计创造玩家与玩家角色融为一体的真实游戏体验。</li>
</ul>
<h2
id="让割草游戏更有趣的攻击动作设计技巧战神三">让割草游戏更有趣的攻击动作设计技巧（战神三）</h2>
<h3 id="让攻击准确命中目标敌人的机制">让攻击准确命中目标敌人的机制</h3>
<ul>
<li>战神三并没有锁定操作，实际上，游戏一致在进行锁定和解除锁定，只是玩家没有察觉到而已。
<ul>
<li>玩家倾斜左摇杆时，玩家角色会锁定移动方向上最近的敌人。</li>
<li>锁定过程中，角色会一直面朝敌人。</li>
<li>可以通过左摇杆锁定其他敌人，如果超出一定距离，锁定会解除。</li>
<li>消灭敌人后，锁定会自动解除，如果还有其他敌人，会继续自动锁定。</li>
</ul></li>
</ul>
<h3 id="让连击畅快淋漓的机制">让连击畅快淋漓的机制</h3>
<ul>
<li>普通攻击以灵活为主，一般会在第三击转换为大范围横向攻击。</li>
<li>重攻击出招慢，以纵向为主。</li>
<li>开始以普通攻击震慑周围敌人，再以重击给单个敌人予以重创。</li>
<li>战神三在设计攻击种类和连击招式时，为每一个攻击动作都分配了固定的用途，玩家能够享受制定战术的乐趣。</li>
<li>每一个招式都是由<strong>攻击动画</strong>
、<strong>攻击力</strong>、<strong>攻击方向</strong>、<strong>追踪性能</strong>等要素组合而成。
<ul>
<li>所谓“追踪性能”，就是指玩家角色发动攻击招式时，根据已锁定的敌人所在的位置自动进行追踪的功能。</li>
<li>普通攻击威力小但追踪性能高，重击威力大但追踪性能低。</li>
<li>如果一款游戏的连击系统能让玩家觉得畅快淋漓，那么其对追踪的调整一定十分到位。</li>
</ul></li>
</ul>
<h3
id="菜鸟也能轻松上手的畅快的浮空连击机制">菜鸟也能轻松上手的畅快的浮空连击机制</h3>
<ul>
<li>割草类游戏都将空中连击的下落设置得比较慢。</li>
<li>在战神三中，玩家只需长按键就可发动挑空攻击。</li>
<li>此外，在玩家随挑空攻击后插入了短暂的慢放，相当于一个信号，帮助玩家准确把握发动空中连击的时机。</li>
</ul>
<h3 id="用简单操作发动复杂连击的机制">用简单操作发动复杂连击的机制</h3>
<ul>
<li>两个攻击键，短按与长按。</li>
<li>如果连击第一招需要判断长按还是短按，需要在“长按”判定结束之前，所有受影响的连击都应用同一个攻击动画。</li>
<li>战神三中的连击只有第一招需要判定按键长短，连击过程不需要。《鬼泣》和《猎天使魔女》则支持连击过程长按。</li>
<li>战神三还可以在连击过程中切换武器。</li>
</ul>
<h2
id="让玩家角色动作更细腻的设计技巧塞尔达传说天空之剑">让玩家角色动作更细腻的设计技巧（《塞尔达传说：天空之剑》）</h2>
<ul>
<li>将玩家动作与角色为动作融为一体。 ###
支撑海量解密内容的玩家角色移动动作</li>
<li>按下Z键，镜头会自动调整至林克面朝的方向。</li>
<li>在悬崖边行走不会跌落。</li>
</ul>
<h3
id="让玩家下意识选择合适动作的z注视机制">让玩家下意识选择合适动作的Z注视机制</h3>
<ul>
<li>采用“普通移动”“Z注视移动”“Z注视锁定敌人移动”三种移动模式。</li>
</ul>
<h3
id="能单独当游戏玩的移动动作奋力冲刺">能单独当游戏玩的移动动作——奋力冲刺</h3>
<ul>
<li>冲刺消耗耐力值，设置了只有奋力冲刺才能通过的斜坡。</li>
<li>翻滚冲刺、沿墙冲刺等等。</li>
</ul>
<h3
id="没有跳跃键却可以体验真实跳跃的机制">没有跳跃键却可以体验真实跳跃的机制</h3>
<ul>
<li>自动触发跳跃，但并没有失去跳跃的乐趣。玩家依然需要掌控距离，需要助跑等等。</li>
<li>自动跳跃可以避免空气墙。</li>
</ul>
<h2
id="头脑与身体一起享受的剑战动作设计技巧塞尔达传说天空之剑">头脑与身体一起享受的剑战动作设计技巧（《塞尔达传说：天空之剑》）</h2>
<h3 id="能帅气挥剑的机制">能帅气挥剑的机制</h3>
<ul>
<li>要将遥控器当成真剑来操作，带来了前所未有的战斗动作享受。</li>
<li>Wii将人的动作符号化，让普通玩家也能享受到乐趣。</li>
</ul>
<h3 id="攻击与体力的机制">攻击与体力的机制</h3>
<ul>
<li>游戏系统设定的连击结束时攻击即结束，最后一招往往动作较大、破绽较多。</li>
<li>为玩家设置体力参数，归零时攻击结束。</li>
<li>玩家没有体力或者没有挥动Wii时，攻击结束。</li>
<li>一般动作游戏是A与B结合，而天空之剑是B与C组合。</li>
</ul>
<h3 id="让玩家痛快反击的盾击机制">让玩家痛快反击的盾击机制</h3>
<ul>
<li>盾击会让敌人暂时失去平衡，创造反击的机会。</li>
<li>盾击是通过“玩家盾击动作”与“敌人攻击动作”中设置的“盾击成功判定帧”进行判定的。如果这两个动作中的“盾击成功帧”重合，则判定盾击成功。</li>
<li>盾牌加入耐久。</li>
</ul>
<h3 id="实现剑战动作的机制">实现剑战动作的机制</h3>
<ul>
<li>当面对多个敌人时，只集中精力与一名敌人对战，基本上是一对一。</li>
<li>通过Z注视机制实现剑战。受到Z注视的敌人会先积极攻击。</li>
</ul>
<h3 id="剑战动作与割草游戏的区别">剑战动作与割草游戏的区别</h3>
<ul>
<li>战斗中的跳跃不同。塞尔达采用了自动跳跃，不会出现跳跃闪避攻击的情况。战神则可以通过跳跃躲避敌人。</li>
<li>割草游戏有大量的AOE，塞尔达大多为单体攻击。</li>
</ul>
<h2
id="完美演绎英雄的玩家角色动作设计技巧蝙蝠侠阿甘之城">完美演绎英雄的玩家角色动作设计技巧（《蝙蝠侠：阿甘之城》）</h2>
<h3
id="能像蝙蝠一样在三维空间自如穿梭的机制">能像蝙蝠一样在三维空间自如穿梭的机制</h3>
<ul>
<li>滑翔与抓钩就是“平面+高度”的移动手段，还有其他作用。</li>
<li>在大楼之间移动时，玩家只需要按住X操作左摇杆，就能根据间隔和高度进行跳跃或自动切换至滑翔状态。不会因为跳跃失误而遭失败。</li>
<li>抓钩也实现了精准操作和粗略操作。</li>
</ul>
<h3
id="通过简单操作实现高自由度的玩家角色动作的机制">通过简单操作实现高自由度的玩家角色动作的机制</h3>
<ul>
<li>玩家角色的移动动作就有很多种，移动动作并不由玩家的手柄决定，而是由玩家触碰的物体决定。（类似刺客信条）</li>
<li>蝙蝠侠将移动动作特有的难点——时机把握从基本移动操作中剔除，是一款专注功能可供性的动作游戏。</li>
</ul>
<h3 id="演绎一名不会轻易死亡的英雄">演绎一名不会轻易死亡的英雄</h3>
<ul>
<li>在奔跑中碰到墙壁，移动动画会终止。</li>
<li>在滑翔时碰到墙壁，蝙蝠侠也不会落下去，而是抓住墙壁。</li>
</ul>
<h2
id="让玩家化身为英雄的设计技巧蝙蝠侠阿甘之城">让玩家化身为英雄的设计技巧（《蝙蝠侠：阿甘之城》）</h2>
<h3 id="让战术自由度更高的机制">让战术自由度更高的机制</h3>
<ul>
<li>潜行动作游戏在游戏中的流程分为“侦察”“制定战术”“捕食战术”“格斗战术”四个阶段。</li>
<li>蝙蝠侠在捕食战斗阶段能削减敌人多少就成了战斗取胜的关键。</li>
<li>蝙蝠侠提供了50多种不同的动作，具有极高的自由度。</li>
</ul>
<h3 id="让人忍不住要尝试的工具机制">让人忍不住要尝试的工具机制</h3>
<ul>
<li>蝙蝠侠中有很多工具，或者道具，一共有20多种。这些工具不会击溃敌人，只会造成负面效果，保证了工具不会打破战斗平衡性。</li>
<li><strong>工具和战斗动作可以组合，使得产生“有趣的反应”和“新动作”</strong>。</li>
</ul>
<h3
id="让玩家完美演绎蝙蝠侠的捕食者动作的机制">让玩家完美演绎蝙蝠侠的捕食者动作的机制</h3>
<ul>
<li>“无声压制”和“转角隐蔽压制”可以无声无息地击溃敌人，所以玩家能够立刻开始下一步动作而不被敌人发现。</li>
<li>“粉碎重击”和“边缘压制”能产生很大的声响。</li>
<li>利用有利位置，可以将敌人吊起来剥夺其行动力的“倒吊压制”。</li>
</ul>
<h3
id="改变动作游戏定式的自由流程格斗机制">改变动作游戏定式的自由流程格斗机制</h3>
<ul>
<li>在一般的动作游戏种，玩家需要根据周围敌人的情况选择固定的攻击动作或连击，然后输入指令来发动。
<ul>
<li>要先考虑与敌人的距离、招式的速度、招式的追踪性能、招式的属性。</li>
</ul></li>
<li>自由格斗，玩家输入的不是攻击招式，而是适合周围状况的攻击动作。</li>
<li>一个按键对应多个攻击招式以及敌人反应。</li>
<li>蝙蝠侠仍然是一款根据环境自动选择动作的游戏。</li>
</ul>
<h2
id="还原机器人动画的玩家角色动作设计技巧终极地带引导亡灵之神">还原机器人动画的玩家角色动作设计技巧（《终极地带：引导亡灵之神》）</h2>
]]></content>
      <categories>
        <category>游戏 - 游戏理论</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>你为什么不笑了</title>
    <url>/2022/10/29/00/35/</url>
    <content><![CDATA[<p>你为什么不笑了？</p>
<span id="more"></span>
<p>奶奶，你为什么不笑了？<br />
还记得，一年前的你，<br />
走在春风里，<br />
向着山顶慢慢登去。<br />
你摘下路边的一朵浅梅，<br />
捧在手心。<br />
阳光洒下，<br />
手中的梅花，也映衬出了你脸上的笑容。</p>
<p>你的儿子女儿挽着你的手，<br />
一步一步向山顶走去，<br />
你看见一棵古树，<br />
你说这是拍照好去处。<br />
女儿扶着你，<br />
你扶着树，<br />
阳光洒下，<br />
树上的绿叶，也甘愿陪衬你脸上的笑容。</p>
<p>来到山顶，<br />
黄花遍地，<br />
你开心得像个孩子，<br />
伸出双手，<br />
比了两个大大的耶，<br />
那时的你，真的好美。</p>
<p>奶奶，从什么时候开始，你不笑了？<br />
从拔掉爷爷呼吸机的那个夜晚开始，<br />
你似乎一直睡得不好。<br />
你还能梦见吗，<br />
另一张空荡荡的床上，<br />
曾经那个老人的模样？<br />
从前他是那样健康，<br />
如今却骨瘦嶙峋，<br />
让时间风干了皮肤，<br />
侵蚀了思想。<br />
你还能看见吗，<br />
那个明媚下午的阳光，<br />
案前那个老人伏着阅读着，报刊也泛黄。</p>
<p>奶奶，你为什么不笑了？<br />
近日来，<br />
你总是抱怨，<br />
胸口有恙。<br />
你变得啰嗦、唠叨，<br />
总是对小事斤斤计量。<br />
我好想你能多笑笑，<br />
放下生活的疲劳，<br />
忘却心中的郁结，<br />
再回忆，<br />
我们一起出游时，<br />
小鸟的啼叫，<br />
鲜花的绽放，<br />
阳光的照耀，<br />
我们手拉着手，<br />
在田园中，聊些家常，传来欢笑。</p>
<p>奶奶，时间真的很残酷，<br />
也许当我走时，<br />
这个世界便再无你的回响，<br />
人生人寂，人来人往，<br />
至我去时，此情已了，略无痕迹。</p>
<p>奶奶，再让我看看你的笑，<br />
那个阳光中，<br />
像孩子般最天真的笑容。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>十二月的花</title>
    <url>/2020/12/22/09/29/</url>
    <content><![CDATA[<p>埙吹响了海岸<br />
琴穿梭叶间<br />
笛在天空啼鸣<br />
伴奏着雪花片片</p>
<p>孩子们欢笑着相聚<br />
踏着雪<br />
吱吱嘎嘎</p>
<p>把欢乐捏成一团团棉<br />
随风起舞<br />
在阳光下<br />
雪爱上了花</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
        <tag>打油诗</tag>
      </tags>
  </entry>
  <entry>
    <title>向量绕任意轴旋转的简单推导</title>
    <url>/2021/06/07/08/38/</url>
    <content><![CDATA[<p>图形学中有关旋转的一个问题是，一个（三维空间的）向量绕一个任意轴旋转若干角度后的角度是什么。本文简单进行推导，给出显式结果。</p>
<span id="more"></span>
<h1 id="方法一向量分解">方法一：向量分解</h1>
<h2 id="推导过程">推导过程</h2>
<p>首先介绍一个最容易理解的方法——向量分解。假设要旋转的向量是<span
class="math inline">\(\mathbf{p}\)</span>，要旋转的轴是<span
class="math inline">\(\mathbf{n}\)</span>，是一个单位向量，要旋转的角度是<span
class="math inline">\(\theta\)</span>。再设旋转后的轴是<span
class="math inline">\(\mathbf{p}&#39;\)</span>。</p>
<p>现在我们把<span
class="math inline">\(\mathbf{p}\)</span>分解为两个向量，一个平行于<span
class="math inline">\(\mathbf{n}\)</span>，另一个垂直于<span
class="math inline">\(\mathbf{n}\)</span>，即： <span
class="math display">\[\mathbf{p}=\mathbf{p}_\perp+\mathbf{p}_\parallel\]</span>
容易知道，平行于<span
class="math inline">\(\mathbf{n}\)</span>的分向量<span
class="math inline">\(\mathbf{p}_\parallel\)</span>就是<span
class="math inline">\(\mathbf{p}\)</span>在<span
class="math inline">\(\mathbf{n}\)</span>上的投影（推导过程略）： <span
class="math display">\[\mathbf{p}_\parallel=(\mathbf{n}\cdot\mathbf{p})\mathbf{n}\]</span>
从而就能得到<span class="math inline">\(\mathbf{p}_\perp\)</span>：
<span
class="math display">\[\mathbf{p}_\perp=\mathbf{p}-\mathbf{p}_\parallel\]</span>
同样地可以将旋转后的向量分解： <span
class="math display">\[\mathbf{p}&#39;=\mathbf{p}&#39;_\perp+\mathbf{p}&#39;_\parallel\]</span>
显然，旋转后的向量对应的平行分量<span
class="math inline">\(\mathbf{p}&#39;_\parallel\)</span>是不变的： <span
class="math display">\[\mathbf{p}&#39;_\parallel=\mathbf{p}_\parallel\]</span>
这里的关键在于求垂直分量<span
class="math inline">\(\mathbf{p}&#39;_\perp\)</span>。</p>
<figure>
<img data-src="/images/arbitrary_rotation/1.png"
alt="将向量分解为一个平行向量和一个垂直向量" />
<figcaption
aria-hidden="true">将向量分解为一个平行向量和一个垂直向量</figcaption>
</figure>
<p>根据已知的旋转轴<span
class="math inline">\(\mathbf{n}\)</span>，我们就知道它对应的平面<span
class="math inline">\(V\)</span>，而向量<span
class="math inline">\(\mathbf{p}\)</span>与<span
class="math inline">\(\mathbf{p}&#39;\)</span>的垂直分量就在该平面内。该平面的维度是2，因此只需要找到两个基向量，就可以通过这两个基向量的线性组合表示该平面的任意向量。</p>
<p>其中一个基向量我们已经找到了，就是<span
class="math inline">\(\mathbf{p}_\perp\)</span>，而另一个我们可以通过<span
class="math inline">\(\mathbf{n}\)</span>与<span
class="math inline">\(\mathbf{p}_\perp\)</span>的叉乘实现，得到的向量与<span
class="math inline">\(\mathbf{n}\)</span>和<span
class="math inline">\(\mathbf{p}_\perp\)</span>垂直，且在平面<span
class="math inline">\(V\)</span>内。且注意到： <span
class="math display">\[\mathbf{n}\times
\mathbf{p}_\perp=\mathbf{n}\times(\mathbf{p}-\mathbf{p}_\parallel)=\mathbf{n}\times\mathbf{p}-\mathbf{n}\times\mathbf{p}_\parallel=\mathbf{n}\times\mathbf{p}\]</span>
并且有： <span class="math display">\[\|\mathbf{n}\times
\mathbf{p}\|=\|\mathbf{n}\times
\mathbf{p}_\perp\|=\|\mathbf{n}\|\cdot\|\mathbf{p}_\perp\|\cdot\sin(\pi/2)=\|\mathbf{p}_\perp\|\]</span>
进而我们能导出旋转后的垂直分量<span
class="math inline">\(\mathbf{p}&#39;_\perp\)</span>： <span
class="math display">\[\mathbf{p}&#39;_\perp=\cos(\theta)\|\mathbf{p}_\perp\|\cdot\frac{\mathbf{p}_\perp}{\|\mathbf{p}_\perp\|}+\sin(\theta)\|\mathbf{p}_\perp\|\cdot\frac{\mathbf{n}\times\mathbf{p}}{\|\mathbf{n}\times\mathbf{p}\|}=\cos(\theta)\mathbf{p}_\perp+\sin(\theta)(\mathbf{n}\times\mathbf{p})\]</span>
最后，我们得到旋转后的向量<span
class="math inline">\(\mathbf{p}&#39;\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{p}&#39;&amp;=\mathbf{p}&#39;_\perp+\mathbf{p}&#39;_\parallel\\
&amp;=\cos(\theta)\mathbf{p}_\perp+\sin(\theta)(\mathbf{n}\times\mathbf{p})+\mathbf{p}_\parallel\\
&amp;=\cos(\theta)(\mathbf{p}-\mathbf{p}_\parallel)+\mathbf{p}_\parallel+\sin(\theta)(\mathbf{n}\times\mathbf{p})\\
&amp;=\cos(\theta)\mathbf{p}+(1-\cos(\theta))(\mathbf{n}\cdot\mathbf{p})\mathbf{n}+\sin(\theta)(\mathbf{n}\times\mathbf{p})
\end{aligned}
\]</span></p>
<p>搞定！</p>
<h2 id="矩阵形式">矩阵形式</h2>
<p>我们知道向量的叉乘可以表示为： <span class="math display">\[
\mathbf{n}\times\mathbf{p}=
\begin{bmatrix}
0&amp;-n_z&amp;n_y\\
n_z&amp;0&amp;-n_x\\
-n_y&amp;n_x&amp;0
\end{bmatrix}
\mathbf{p}=\mathbf{N}\mathbf{p}
\]</span> 注意到，矩阵<span
class="math inline">\(\mathbf{N}\)</span>有如下的性质： <span
class="math display">\[\mathbf{N}(\mathbf{N}\mathbf{p})=\mathbf{N}^2\mathbf{p}=\mathbf{n}\times(\mathbf{n}\times\mathbf{p})\]</span>
所以我们可以把旋转公式写成下述形式： <span
class="math display">\[\mathbf{p}&#39;=\mathbf{p}+(1-\cos(\theta))\mathbf{N}^2\mathbf{p}+\sin(\theta)\mathbf{N}\mathbf{p}=\mathbf{R}\mathbf{p}\]</span>
其中<span
class="math inline">\(\mathbf{R}=\mathbf{I}+\sin(\theta)\mathbf{N}+(1-\cos(\theta))\mathbf{N}^2\)</span>。上面的等式需要注意到<span
class="math inline">\((\mathbf{n}\cdot\mathbf{p})\mathbf{n}=\mathbf{p}+\mathbf{N}^2\mathbf{p}\)</span>。</p>
<p>所以，使用Rodrigues'旋转公式，只需要首先令<span
class="math inline">\(\mathbf{N}=\begin{bmatrix}0&amp;-n_z&amp;n_y\\n_z&amp;0&amp;-n_x\\-n_y&amp;n_x&amp;0\end{bmatrix}\)</span>，然后再计算<span
class="math inline">\(\mathbf{R}=\mathbf{I}+\sin(\theta)\mathbf{N}+(1-\cos(\theta))\mathbf{N}^2\)</span>，就能得到旋转后的向量为<span
class="math inline">\(\mathbf{p}&#39;=\mathbf{R}\mathbf{p}\)</span>。</p>
<h1 id="方法二坐标轴对齐">方法二：坐标轴对齐</h1>
<p>既然直接绕着任意轴旋转比较困难，那为啥不先进行整个空间的旋转，把旋转轴旋转为坐标轴，这样就能把向量绕任意轴旋转转化为向量绕标准坐标轴旋转。这就是我们非常熟悉的问题了。</p>
<p>假定我们考虑的是三维空间的旋转（对更高维的情况容易推论），即标准坐标系为<span
class="math inline">\(\mathbf{x}=(1,0,0),\mathbf{y}=(0,1,0),\mathbf{z}=(0,0,1)\)</span>。我们有旋转轴<span
class="math inline">\(\mathbf{n},\Vert\mathbf{n}\Vert=1\)</span>和待旋转向量<span
class="math inline">\(\mathbf{p}\)</span>。</p>
<p>首先，我们构建一个坐标系<span
class="math inline">\(\mathbf{u},\mathbf{v},\mathbf{w}\)</span>，该坐标系的一个轴就是<span
class="math inline">\(\mathbf{n}\)</span>，我们利用叉乘实现：</p>
<p><span class="math display">\[
\mathbf{u}=\mathbf{n},\qquad
\mathbf{v}=\frac{\mathbf{n}\times\mathbf{p}}{\Vert\mathbf{n}\times\mathbf{p}\Vert},\qquad
\mathbf{w}=\mathbf{n}\times \mathbf{v}
\]</span></p>
<p>现在，我们要把坐标轴<span
class="math inline">\(\mathbf{u},\mathbf{v},\mathbf{w}\)</span>分别旋转到坐标轴<span
class="math inline">\(\mathbf{x},\mathbf{y},\mathbf{z}\)</span>的位置，这可以用下面的旋转矩阵实现：</p>
<p><span class="math display">\[
\mathbf{Q}=
\begin{bmatrix}
\mathbf{u}\\
\mathbf{v}\\
\mathbf{w}
\end{bmatrix}=
\begin{bmatrix}
x_u&amp;y_u&amp;z_u\\
x_v&amp;y_v&amp;z_v\\
x_w&amp;y_w&amp;z_w
\end{bmatrix}
\]</span></p>
<p>很容易验证：<span
class="math inline">\(\mathbf{x}=\mathbf{Q}\mathbf{u},\mathbf{y}=\mathbf{Q}\mathbf{v},\mathbf{z}=\mathbf{Q}\mathbf{w}\)</span>，从而就有<span
class="math inline">\(\mathbf{I}=\mathbf{Q}\mathbf{Q}^\top=\mathbf{Q}^\top\mathbf{Q}\)</span>，这就验证了<span
class="math inline">\(\mathbf{Q}\)</span>是正交的。</p>
<p>现在，原来的向量<span
class="math inline">\(\mathbf{p}\)</span>就变成了<span
class="math inline">\(\mathbf{Q}\mathbf{p}\)</span>，原来绕<span
class="math inline">\(\mathbf{n}\)</span>旋转（也就是绕<span
class="math inline">\(\mathbf{u}\)</span>旋转）就变成了绕<span
class="math inline">\(\mathbf{x}\)</span>旋转，而我们知道绕<span
class="math inline">\(\mathbf{x}\)</span>轴旋转<span
class="math inline">\(\theta\)</span>的旋转矩阵是： <span
class="math display">\[
\mathbf{T}=
\begin{bmatrix}
1&amp;0&amp;0\\
0&amp;\cos(\theta)&amp;-\sin(\theta)\\
0&amp;\sin(\theta)&amp;\cos(\theta)
\end{bmatrix}
\]</span> 因此，旋转后的向量就是<span
class="math inline">\(\mathbf{T}\mathbf{Q}\mathbf{p}\)</span>。现在，只需要把旋转后的向量再旋转回原来的位置就好了，我们只需要再乘以<span
class="math inline">\(\mathbf{Q}\)</span>的逆即可。由于<span
class="math inline">\(\mathbf{Q}\)</span>是正交的，所以有<span
class="math inline">\(\mathbf{Q}^{-1}=\mathbf{Q}^\top\)</span>。把上面的结果合起来，就能得到最终的结果是：
<span class="math display">\[\mathbf{p}&#39;=\mathbf{Q}^\top
\mathbf{T}\mathbf{Q}\mathbf{p}\]</span></p>
<h1 id="检验">检验</h1>
<p>现在我们用代码来检验一下上述三种方法是否能得到同样的结果，以及它们的运算效率如何。比较的方法包括：
1. 向量分解-向量形式 2. 向量分解-矩阵形式 3. 对标轴对齐</p>
<p>程序在虚拟机上运行，RAM为4G，硬盘20G，处理器为2个Intel Core i5-10400F
CPU @ 2.90GHz。</p>
<p>代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;eigen3/Eigen/Eigen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using vector decomposation - the vector form</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecomposeVector</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f rotatedVector = <span class="built_in">cos</span>(rotationAngle) * p </span><br><span class="line">                                + (<span class="number">1</span> - <span class="built_in">cos</span>(rotationAngle)) * (n.<span class="built_in">dot</span>(p)) * n </span><br><span class="line">                                + <span class="built_in">sin</span>(rotationAngle) * (n.<span class="built_in">cross</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: vector decomposition - the vector form. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using vector decomposation - the matrix form</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecomposeMatrix</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Matrix3f N = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">N &lt;&lt; <span class="number">0</span>, -<span class="built_in">n</span>(<span class="number">2</span>), <span class="built_in">n</span>(<span class="number">1</span>),</span><br><span class="line">     <span class="built_in">n</span>(<span class="number">2</span>), <span class="number">0</span>, -<span class="built_in">n</span>(<span class="number">0</span>),</span><br><span class="line">     -<span class="built_in">n</span>(<span class="number">1</span>), <span class="built_in">n</span>(<span class="number">0</span>), <span class="number">0</span>;</span><br><span class="line">Eigen::Matrix3f R = Eigen::Matrix3f::<span class="built_in">Identity</span>() + <span class="built_in">sin</span>(rotationAngle) * N + (<span class="number">1</span> - <span class="built_in">cos</span>(rotationAngle)) * N * N;</span><br><span class="line">Eigen::Vector3f rotatedVector = R * p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: vector decomposition - the matrix form. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotation using axis coordination</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AxisCoordination</span><span class="params">(<span class="type">const</span> Eigen::Vector3f &amp;n, <span class="type">const</span> Eigen::Vector3f &amp;p, <span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> rotationAngle = angle / <span class="number">180.0</span> * PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f crossed = n.<span class="built_in">cross</span>(p);</span><br><span class="line">Eigen::Vector3f u = n;</span><br><span class="line">Eigen::Vector3f v = crossed / crossed.<span class="built_in">norm</span>();</span><br><span class="line">Eigen::Vector3f w = n.<span class="built_in">cross</span>(v);</span><br><span class="line">Eigen::Matrix3f Q = Eigen::Matrix3f::<span class="built_in">Identity</span>(), T = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">0</span>) = u;</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">1</span>) = v;</span><br><span class="line">Q.<span class="built_in">row</span>(<span class="number">2</span>) = w;</span><br><span class="line">T &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>, <span class="built_in">cos</span>(rotationAngle), -<span class="built_in">sin</span>(rotationAngle),</span><br><span class="line">     <span class="number">0</span>, <span class="built_in">sin</span>(rotationAngle), <span class="built_in">cos</span>(rotationAngle);</span><br><span class="line">Eigen::Vector3f rotatedVector = Q.<span class="built_in">transpose</span>() * T * Q * p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> endTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">double</span> deltaTime = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(endTime-startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Method: axis coordination. The rotated vector p&#x27; is (&quot;</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">rotatedVector</span>(<span class="number">2</span>)</span><br><span class="line">     &lt;&lt; <span class="string">&quot;). The time used is &quot;</span> &lt;&lt; deltaTime &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> angle = <span class="number">60</span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">p</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">n</span><span class="params">(<span class="number">2.0</span>, <span class="number">8.6</span>, <span class="number">-3.1</span>)</span></span>;</span><br><span class="line">    n.<span class="built_in">normalize</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// execute functions</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The vector p is (&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">p</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;). &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;The rotation axis n is (&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">n</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;). &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DecomposeVector</span>(n, p, angle);</span><br><span class="line">    <span class="built_in">DecomposeMatrix</span>(n, p, angle);</span><br><span class="line">    <span class="built_in">AxisCoordination</span>(n, p, angle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出是： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.213724</span>,<span class="number">0.919011</span>,<span class="number">-0.331271</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (3.57449,0.643966,0.899062). The time used is 0.016354</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">3.57449</span>,<span class="number">0.643966</span>,<span class="number">0.899062</span>). The time used is <span class="number">0.016642</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (3.57449,0.643966,0.899062). The time used is 0.021062</span></span></span><br></pre></td></tr></table></figure> 再多试几组：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">1</span>,<span class="number">-654.1</span>,<span class="number">12.88</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.995044</span>,<span class="number">0.0136933</span>,<span class="number">-0.0984901</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (-59.7309,-338.298,-556.777). The time used is 0.015503</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">-59.7309</span>,<span class="number">-338.298</span>,<span class="number">-556.777</span>). The time used is <span class="number">0.015297</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (-59.7309,-338.298,-556.777). The time used is 0.021547</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">32.5</span>,<span class="number">45.1</span>,<span class="number">-2.2</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0.57735</span>,<span class="number">0.57735</span>,<span class="number">0.57735</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (5.16667,52.4667,17.7667). The time used is 0.015558</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">5.16667</span>,<span class="number">52.4667</span>,<span class="number">17.7667</span>). The time used is <span class="number">0.015215</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (5.16667,52.4667,17.7667). The time used is 0.020841</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">The vector p <span class="title">is</span> <span class="params">(<span class="number">666</span>,<span class="number">0</span>,<span class="number">0</span>)</span>. The rotation axis n <span class="title">is</span> <span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span>. </span></span><br><span class="line"><span class="function">Method: vector decomposition - the vector form. The rotated vector p<span class="string">&#x27; is (1.78454e-05,666,0). The time used is 0.01517</span></span></span><br><span class="line"><span class="string"><span class="function">Method: vector decomposition - the matrix form. The rotated vector p&#x27;</span> is (<span class="number">0</span>,<span class="number">666</span>,<span class="number">0</span>). The time used is <span class="number">0.015402</span></span></span><br><span class="line"><span class="function">Method: axis coordination. The rotated vector p<span class="string">&#x27; is (1.78454e-05,666,0). The time used is 0.020898</span></span></span><br></pre></td></tr></table></figure>
<p>最后一组出现了精度问题，所以代码中还应该加入判断 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(value - <span class="built_in">round</span>(value)) &lt; epsilon)</span><br><span class="line">     value = <span class="built_in">round</span>(value);</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子来看，<strong>向量分解-向量形式</strong>与<strong>向量分解-矩阵形式</strong>运行效率是一致的，而<strong>坐标轴对齐</strong>的效率较低，这主要是由计算三次矩阵乘法导致的。</p>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>根据角色体型和俯角自动确定FreeLook镜头参数</title>
    <url>/2022/06/21/23/40/</url>
    <content><![CDATA[<p>最近项目涉及到一个需求：如何自动确定镜头的参数（在Unity中即为轨道的高度和半径）。这个问题可以形式化为：给定角色身高<span
class="math inline">\(X\)</span>、看向点偏移<span
class="math inline">\(Y\)</span>、俯角<span
class="math inline">\(A\)</span>和人物在画面中的占高比<span
class="math inline">\(T\)</span>，自动计算出相机到看向点的距离<span
class="math inline">\(D\)</span>、相机中轨的半径<span
class="math inline">\(R\)</span>和相机中轨的高度<span
class="math inline">\(H\)</span>。本文推导出该计算公式，实现镜头参数自动化处理。</p>
<span id="more"></span>
<h1
id="角色高度看向点偏移俯角与相机参数">角色高度、看向点偏移、俯角与相机参数</h1>
<p>我们的第一步目标是：给定角色高度<span
class="math inline">\(X\)</span>、看向点偏移<span
class="math inline">\(Y\)</span>和俯角<span
class="math inline">\(A\)</span>，能够自动计算出相机距离、相机轨道的半径<span
class="math inline">\(R\)</span>和高度<span
class="math inline">\(H\)</span>。在此之前，首先需要明确几个概念：</p>
<ul>
<li>角色高度：角色模型在游戏中的实际高度，因为我们目前关心的角色在屏幕中的占高比，暂不考虑角色宽度；</li>
<li>看向点偏移：从角色Root结点的Y轴偏移量，如果等于角色高度则位于角色头顶位置，等于零则位于Root位置；</li>
<li>俯角：相机看向角色看向点时与XZ平面的夹角；</li>
<li>相机距离：相机到看向点的距离；</li>
<li>相机轨道高度：相机从角色Root点开始的Y轴高度；</li>
<li>相机轨道半径：相机轨道在当前高度上的半径。</li>
</ul>
<p>这几个参数的关系可以用下图来表示：</p>
<figure>
<img data-src="/images/auto-camera-params/1.png"
alt="几个参数之间的关系。X：角色高度，Y：看向点偏移，A：俯角，D：相机距离，H：相机高度，R：相机半径。" />
<figcaption
aria-hidden="true">几个参数之间的关系。X：角色高度，Y：看向点偏移，A：俯角，D：相机距离，H：相机高度，R：相机半径。</figcaption>
</figure>
<p>我们不难得出下面的关系：</p>
<p><span class="math display">\[
\begin{align}
    R &amp;= \cos(A)D\\
    H &amp;= \tan(A)R+Y
\end{align}
\]</span></p>
<p>但这是对<span class="math inline">\(H\ge Y\)</span>的情况，当<span
class="math inline">\(H&lt;Y\)</span>时，我们有：</p>
<p><span class="math display">\[
\begin{align}
    R &amp;= \cos(A)D\\
    H &amp;= -\tan(A)R+Y
\end{align}
\]</span></p>
<p>但是由于我们在计算俯角时，以下方向为正方向，当<span
class="math inline">\(H&lt;Y\)</span>时，俯角<span
class="math inline">\(A\)</span>实际上是负值，所以也不需要加负号。于是，最终的公式仍然是统一的。</p>
<h1
id="人物高度人物占高比fov与相机距离">人物高度、人物占高比、FOV与相机距离</h1>
<p>上述公式的一个前提是需要知道<span
class="math inline">\(D\)</span>（<span
class="math inline">\(A\)</span>可自定，<span
class="math inline">\(Y=X/2\)</span>或<span
class="math inline">\(Y=2X/3\)</span>），而我们实际上关注的是人物在整个画面中的占高比，而相机屏幕与FOV有关，所以为了计算<span
class="math inline">\(D\)</span>，实际上就是要考虑通过FOV和人物高度、人物占高比计算出相机距离。</p>
<p>现在我们假定人物占高比固定为<span
class="math inline">\(1/3\)</span>，可以根据需求自行推导。</p>
<figure>
<img data-src="/images/auto-camera-params/2.png"
alt="通过FOV和人物高度计算出相机距离。我们固定了1/3的人物占高比。" />
<figcaption
aria-hidden="true">通过FOV和人物高度计算出相机距离。我们固定了1/3的人物占高比。</figcaption>
</figure>
<p>如上图所示，相机投影的上半部分角度为FOV的一半，在这里我们假设FOV为<span
class="math inline">\(55°\)</span>，那么一半就是<span
class="math inline">\(55°/2\)</span>。设相机距离为<span
class="math inline">\(D\)</span>，当角色高度的一半，即<span
class="math inline">\(X/2\)</span>占屏幕上半的<span
class="math inline">\(1/3\)</span>时，我们不难得到下述公式：</p>
<p><span class="math display">\[
\begin{equation}
    D=\frac{1.5X}{\tan(55^\circ/2)}
\end{equation}
\]</span></p>
<p>但是上述公式没有考虑俯角，这就会导致一定的误差。下面我们分<span
class="math inline">\(A\le 55^\circ/2\)</span>和<span
class="math inline">\(A&gt;55^\circ/2\)</span>两种情况讨论，如下图所示：</p>
<figure>
<img data-src="/images/auto-camera-params/3.png"
alt="修正后的相机距离用俯角、FOV和人物高度计算得出。我们固定了1/3的人物占高比。" />
<figcaption
aria-hidden="true">修正后的相机距离用俯角、FOV和人物高度计算得出。我们固定了1/3的人物占高比。</figcaption>
</figure>
<p>角色半高在相机屏幕空间中的投影为<span
class="math inline">\(\cos(A)X/2\)</span>。所以我们能够得到下述修正公式：</p>
<p><span class="math display">\[
D=\frac{1.5\cos(A)X}{\tan(55^\circ/2)}
\]</span></p>
<p>该公式对两种情况都是适用的。</p>
<h1 id="总结">总结</h1>
<p>总的来说，只要给定角色身高<span
class="math inline">\(X\)</span>、看向点偏移<span
class="math inline">\(Y\)</span>（一般来说设置为<span
class="math inline">\(Y=X/2\)</span>或者<span
class="math inline">\(Y=2X/3\)</span>）和俯角<span
class="math inline">\(A\)</span>，在固定人物在画面中占高比<span
class="math inline">\(1/3\)</span>和FOV为<span
class="math inline">\(55^\circ\)</span>的前提下，就可以根据下述公式计算相机到看向点距离<span
class="math inline">\(D\)</span>、相机中轨半径<span
class="math inline">\(R\)</span>和相机中轨高度<span
class="math inline">\(H\)</span>：</p>
<p><span class="math display">\[
\begin{align}
D &amp;= \frac{1.5\cos(A)X}{\tan(55^\circ/2)}\\
R &amp;= \cos(A)D\\
H &amp;= \tan(A)R + Y
\end{align}
\]</span></p>
<p>如果你需要改变人物在画面的占高比，或者相机的FOV，只需要按照上面的推导方法修改公式即可。</p>
<p>当然，你也可以继续精细化上述公式，如考虑实际的看向点偏移，但一般来说差别不是很大，在此不再赘述。</p>
]]></content>
      <categories>
        <category>游戏 - 相机</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>樱花</title>
    <url>/2021/06/29/00/24/</url>
    <content><![CDATA[<p>昨夜 我收到一封书札<br />
旧纸上 缀满了一朵樱花<br />
风干的墨迹 渗透了陌生人的迷茫<br />
我慢慢 把信合上</p>
<p>昨夜 我写了一封书札<br />
述说着 近日的苦闷衷肠<br />
窗外的灯火 依旧那么辉煌<br />
我贴上 一朵樱花珍藏</p>
<p>同样的夜晚 走过了岁月多少锋芒<br />
心中仍 呐喊着一个熟悉人的回响<br />
把信 随风寄向远方<br />
留给陌生的他 打开新的过往<br />
愿他不要怯懦 续写昨夜的感慨<br />
还有清晨的阳光</p>
<p>案台旁 樱花在绽放</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
        <tag>打油诗</tag>
      </tags>
  </entry>
  <entry>
    <title>用生成函数和复数巧解一道计数题</title>
    <url>/2022/06/26/23/03/</url>
    <content><![CDATA[<p>对集合<span
class="math inline">\(\{1,2,\cdots,2000\}\)</span>，求出其中有多少子集，使得子集中的元素和为5的倍数。本文对<a
href="https://youtu.be/bOXCLR3Wric">3Blue3Brown的解法</a>上进行总结，形成较为数学化的语言。本题背后有较为深刻的数学思想，故记载于此。</p>
<span id="more"></span>
<h1 id="把原问题转化为生成函数">把原问题转化为生成函数</h1>
<p>原题是：对集合<span
class="math inline">\(\mathcal{S}=\{1,2,\cdots,2000\}\)</span>，求出其中有多少子集，使得子集中的元素和为5的倍数。</p>
<p>首先容易想到的是，可以采用穷举法，遍历<span
class="math inline">\(\mathcal{S}\)</span>的每个子集，检查是否满足条件。但是，穷举法的复杂度是<span
class="math inline">\(2^{2000}\)</span>，这对计算机来说都是一个天文数字。显然，需要另辟蹊径。</p>
<p>不妨先简化一下题目：求出集合<span
class="math inline">\(\mathcal{S}\)</span>中有多少个子集，使元素之和为<span
class="math inline">\(5\)</span>，我们可以很快地列出这些集合：</p>
<p><span class="math display">\[\{5\},\{1,4\},\{2,3\}\]</span></p>
<p>换句话说，<span class="math inline">\(5\)</span>可以表示为：<span
class="math inline">\(5=5=1+4=2+3\)</span>，如果我们把它表示成一个关于未知数<span
class="math inline">\(x\)</span>的多项式，那么就有：</p>
<p><span class="math display">\[x^5=x^0x^5=x^1x^4=x^2x^3\]</span></p>
<p>什么情况会同时出现<span
class="math inline">\(x^0,x^1,x^2,x^3,x^4,x^5\)</span>呢？答案是<strong>生成函数</strong>。这启发我们使用下面的生成函数：</p>
<p><span class="math display">\[
\begin{equation}
\label{eq1}
f(x)=(1+x)(1+x^2)(1+x^3)(1+x^4)(1+x^5)
\end{equation}
\]</span></p>
<p>这个多项式展开之后的结果是：</p>
<p><span
class="math display">\[f(x)=1+x+x^2+2x^3+2x^4+{\color{red}3x^5}+\cdots\]</span></p>
<p>注意五次项<span
class="math inline">\(x^5\)</span>前面的系数是3，这是因为，<span
class="math inline">\(x^5\)</span>有三个来源，分别是<span
class="math inline">\(1x^5,x^1x^4,x^2x^3\)</span>，正好对应了之前简化题中的结果！</p>
<p>现在分析一下，多项式<span
class="math inline">\(\eqref{eq1}\)</span>中的每个<span
class="math inline">\(x^i\)</span>项，都代表了整数<span
class="math inline">\(i\)</span>，如果在括号<span
class="math inline">\(1+x^i\)</span>中选择了<span
class="math inline">\(x^i\)</span>，则表示把<span
class="math inline">\(i\)</span>这个整数加入集合，如果选择了<span
class="math inline">\(1\)</span>，则表示不加入<span
class="math inline">\(i\)</span>。而把整个多项式展开之后的结果<span
class="math inline">\(f(x)=c_0+c_1x+c_2x^2+\cdots\)</span>，项<span
class="math inline">\(x^i\)</span>前面的系数<span
class="math inline">\(c_i\)</span>，正好代表了元素之和为<span
class="math inline">\(i\)</span>的集合的个数！</p>
<p>这时候，我们就能把原问题转化为下面的生成函数：</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\label{eq2}
f(x)&amp;=(1+x)(1+x^2)(1+x^3)(1+x^4)(1+x^5)\cdots(1+x^{2000})\\
&amp;=c_0+c_1x+c_2x^2+c_3x^3+c_4x^4+c_5x^5+\cdots
\end{aligned}
\end{equation}
\]</span></p>
<p>求出其中所有次数为<span
class="math inline">\(5\)</span>的倍数的项系数之和：</p>
<p><span class="math display">\[
\begin{equation}
\label{eq3}
S=c_5+c_{10}+c_{15}+\cdots
\end{equation}
\]</span></p>
<p>下面的问题就是如何求出<span class="math inline">\(S\)</span>。</p>
<h1 id="转化为复数问题">转化为复数问题</h1>
<p>显然，我们不可能把<span
class="math inline">\(S\)</span>中的每一项都求出来，只能设法一次求出<span
class="math inline">\(S\)</span>，那么怎么办呢？</p>
<p>我们还是先考虑简化问题，假设现在生成函数是:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
f(x)&amp;=(1+x)(1+x^2)(1+x^3)(1+x^4)(1+x^5)\\
&amp;=c_0+c_1x+c_2x^2+c_3x^3+c_4x^4+c_5x^5+\cdots
\end{aligned}
\end{equation}
\]</span></p>
<p>如果我们代入<span class="math inline">\(x=0\)</span>，可以求得<span
class="math inline">\(f(0)=1\)</span>；如果代入<span
class="math inline">\(x=1\)</span>，可以求得<span
class="math inline">\(f(1)=2^5\)</span>；再代入<span
class="math inline">\(x=-1\)</span>，有<span
class="math inline">\(f(-1)=0\)</span>。用展开式表示结果：</p>
<p><span class="math display">\[
\begin{aligned}
    c_0&amp;=1\\
    c_0+c_1+c_2+c_3+c_4+c_5+\cdots &amp;=2^5\\
    c_0-c_1+c_2-c_3+c_4-c_5+\cdots &amp;=0
\end{aligned}
\]</span></p>
<p>通过后面两式，不难得到：</p>
<p><span
class="math display">\[c_1+c_3+c_5+\cdots=\frac{1}{2}2^5=2^4\]</span></p>
<p>我们找到了所有奇数项系数之和，但是我们的目标是所有<span
class="math inline">\(5\)</span>的倍数的项系数之和。但这个过程可以给我们一个启发：<strong>是否可以通过代入某些值到生成函数中，通过加减运算消去我们不关心的项，得到最终的结果</strong>。</p>
<p>分析我们把<span class="math inline">\(-1\)</span>代入到<span
class="math inline">\(f(x)\)</span>中每一项的过程，所有的偶数项<span
class="math inline">\(x^{2k}\)</span>结果都是<span
class="math inline">\(1\)</span>，所有的奇数项<span
class="math inline">\(x^{2k-1}\)</span>结果都是<span
class="math inline">\(-1\)</span>。换句话说：<span
class="math inline">\(-1\)</span>这个值对函数<span
class="math inline">\(f(x)\)</span>的未知项<span
class="math inline">\(x^i\)</span>的循环次数为<span
class="math inline">\(2\)</span>，或者，每两项<span
class="math inline">\(-1\)</span>代入的结果都相同。同理，对<span
class="math inline">\(1\)</span>来说，循环次数是<span
class="math inline">\(1\)</span>。</p>
<p>那么，什么时候循环次数是<span
class="math inline">\(5\)</span>呢？也就是，代入哪个数<span
class="math inline">\(\xi\)</span>，会使得<span
class="math inline">\(\xi=\xi^6\)</span>，或者<span
class="math inline">\(\xi^5=1\)</span>。显然，在复空间中，这个数就是<span
class="math inline">\((\mathrm{e}^{\mathrm{i}\frac{2\pi}{5}})^t
(t=1,2,3,4,5)\)</span>。也就是说，如果令<span
class="math inline">\(\xi=\mathrm{e}^{\mathrm{i}\frac{2\pi}{5}}\)</span>，则有<span
class="math inline">\(5\)</span>个数<span
class="math inline">\(\xi,\xi^2,\xi^3,\xi^4,\xi^5\)</span>满足我们的要求，其中<span
class="math inline">\(\xi^5=1\)</span>就是我们熟知的实根。</p>
<p>更关键的是，这几个数的和是<span
class="math inline">\(0\)</span>：</p>
<p><span
class="math display">\[\xi+\xi^2+\xi^3+\xi^4+\xi^5=\frac{\xi(1-\xi^5)}{1-\xi}=0\]</span></p>
<p>现在，分别把这五个值代入到展开的生成函数中，有：</p>
<p><span class="math display">\[
\begin{aligned}
f(\xi)=c_0+c_1\xi+c_2\xi^2+c_3\xi^3+c_4\xi^4+c_5\xi^5+\cdots\\
f(\xi^2)=c_0+c_1\xi^2+c_2\xi^4+c_3\xi^1+c_4\xi^3+c_5\xi^5+\cdots\\
f(\xi^3)=c_0+c_1\xi^3+c_2\xi^1+c_3\xi^4+c_4\xi^2+c_5\xi^5+\cdots\\
f(\xi^4)=c_0+c_1\xi^4+c_2\xi^3+c_3\xi^2+c_4\xi^1+c_5\xi^5+\cdots\\
f(\xi^5)=c_0+c_1\xi^5+c_2\xi^5+c_3\xi^5+c_4\xi^5+c_5\xi^5+\cdots
\end{aligned}
\]</span></p>
<p>注意<span
class="math inline">\(c_1,c_2,c_3,c_4\)</span>对应的项，正好都有<span
class="math inline">\(\xi,\xi^2,\xi^3,\xi^4,\xi^5\)</span>，把它们加起来，有：</p>
<p><span class="math display">\[
\begin{aligned}
f(\xi)+f(\xi^2)+f(\xi^3)+f(\xi^4)+f(\xi^5)&amp;=5c_0+5c_5\xi^5+5c_{10}\xi^5+5c_{15}\xi^5\\
&amp;=5c_0+5c_5+5c_{10}+5c_{15}
\end{aligned}
\]</span></p>
<p><span
class="math inline">\(c_0=1\)</span>是已知的，所以上面的结果就变成了：</p>
<p><span
class="math display">\[f(\xi)+f(\xi^2)+f(\xi^3)+f(\xi^4)+f(\xi^5)=5+5c_5+5c_{10}+5c_{15}\]</span></p>
<p>现在整个式子右边只留下常数和<span
class="math inline">\(5\)</span>的倍数的项！</p>
<p>唯一遗留的问题就是式子左侧的<span
class="math inline">\(f(\xi)+f(\xi^2)+f(\xi^3)+f(\xi^4)+f(\xi^5)\)</span>是多少，或者说<span
class="math inline">\(f(\xi)=(1+\xi)(1+\xi^2)(1+\xi^3)(1+\xi^4)(1+\xi^5)\)</span>是多少，因为只要知道了<span
class="math inline">\(f(\xi)\)</span>，<span
class="math inline">\(f(\xi^2),f(\xi^3),f(\xi^4)\)</span>的值也就知道了。</p>
<p>这里的技巧是，因为<span
class="math inline">\(\xi,\xi^2,\xi^3,\xi^4,\xi^5\)</span>是方程<span
class="math inline">\(z^5-1=0\)</span>的五个根，所以可以把它们表示成：</p>
<p><span class="math display">\[
\begin{equation}
  z^5-1=(z-\xi)(z-\xi^2)(z-\xi^3)(z-\xi^4)(z-\xi^5)
\end{equation}
\]</span></p>
<p>把<span class="math inline">\(z=-1\)</span>代入：</p>
<p><span class="math display">\[
\begin{equation}
  2=(1+\xi)(1+\xi^2)(1+\xi^3)(1+\xi^4)(1+\xi^5)=f(\xi)
\end{equation}
\]</span></p>
<p>从而，我们也就有<span
class="math inline">\(f(\xi^2)=f(\xi^3)=f(\xi^4)=2\)</span>，而<span
class="math inline">\(f(\xi^5)=2^5\)</span>。所以，我们就得到了：</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
  5+5c_5+5c_{10}+5c_{15}&amp;=4\times 2+2^5\\
  1+c_5+c_{10}+c_{15}&amp;=\frac{1}{5}(4\times 2+2^5)\\
  c_5+c_{10}+c_{15}&amp;=\frac{1}{5}(4\times 2+2^5)-1
\end{aligned}
\end{equation}
\]</span></p>
<p>这样一来我们考虑的简化版问题就得到了解决！</p>
<p>按照这个思路，我们同样可以得到原始问题的解决，分为几步。</p>
<p><strong>第一步</strong>：设<span
class="math inline">\(\xi,\xi^2,\xi^3,\xi^4,\xi^5\)</span>是方程<span
class="math inline">\(z^5-1=0\)</span>的五个根，把它们分别代入生成函数<span
class="math inline">\(f(x)\)</span>中，相加，就得到：</p>
<p><span
class="math display">\[c_0+c_5+c_{10}+\cdots=\frac{1}{5}(f(\xi)+f(\xi^2)+f(\xi^3)+f(\xi^4)+f(\xi^5))\]</span></p>
<p><strong>第二步</strong>：把<span
class="math inline">\(\xi,\xi^2,\xi^3,\xi^4,\xi^5\)</span>表示为<span
class="math inline">\(z^5-1=(z-\xi)(z-\xi^2)(z-\xi^3)(z-\xi^4)(z-\xi^5)\)</span>，通过代入<span
class="math inline">\(z=-1\)</span>解出<span
class="math inline">\((1+\xi)(1+\xi^2)(1+\xi^3)(1+\xi^4)(1+\xi^5)=2\)</span>。</p>
<p><strong>第三步</strong>：把<span
class="math inline">\(\xi\)</span>代入到生成函数<span
class="math inline">\(f(x)\)</span>中，可以得到<span
class="math inline">\(f(\xi)=2^{400}\)</span>，同理有<span
class="math inline">\(f(\xi^2)=f(\xi^3)=f(\xi^4)=2^{400}\)</span>，同时有<span
class="math inline">\(f(\xi^5)=2^{2000}\)</span>。</p>
<p><strong>第四步</strong>：把所有值代回第一步中的结果，得到最终答案<span
class="math inline">\(c_5+c_{10}=\frac{1}{5}(4\times
2^{400}+2^{2000})-1\)</span>。</p>
<h1 id="总结">总结</h1>
<p>本题背后蕴藏着较为深刻的数学思想，一方面是巧用生成函数把一个计数问题转化为一个分析问题，另一方面是使用复数消去某些项，直接求出想要的结果。通过本题，我们可以充分了解到复数所蕴含的关于周期和频率的思想，从而也就能理解为什么傅里叶变换用复数表征。</p>
<p>把本题稍微进行推广：对集合<span
class="math inline">\(\mathcal{A}=\{1,2,3,\cdots,N\}\)</span>和正整数<span
class="math inline">\(k\)</span>，其中<span
class="math inline">\(k|N\)</span>。设<span
class="math inline">\(\mathcal{A}\)</span>中满足元素之和为<span
class="math inline">\(k\)</span>的倍数的子集个数为<span
class="math inline">\(\mathfrak{P}_k\)</span>，你能求出<span
class="math inline">\(\mathfrak{P}_k\)</span>的表达式吗？</p>
]]></content>
      <categories>
        <category>数学 - 分析</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>电影《误杀》短评</title>
    <url>/2020/09/08/16/18/</url>
    <content><![CDATA[<p>《误杀》是一部不失水准的悬疑片。实际上，在看完电影得知这是一部翻拍（翻拍自2015年的印度电影《误杀瞒天记》。实际上，它还有更早的来源）后，我竟然有些失落：要是这是我们自己的剧本该多好。但无论如何，本片从剧情、人物、节奏、立意、表现手法等方法，都是在水准线之上的作品，其中的若干不足完全是瑕不掩瑜的。8分是我对本片的总体评价。
之后我将围绕本片进行，而不讨论有关其原版《误杀瞒天记》的内容。</p>
<span id="more"></span>
<h1 id="剧情与讲述">剧情与讲述</h1>
<p>一言蔽之，本片讲述了一个关于“误杀”的故事。但看到最后，观众会发现，实际上，“误杀”并不成立，称之为“谋杀”，也是不为过的。本片没有直接点明这一点，是为了进一步突出电影的戏剧化效果。</p>
<p>在剧情方面，电影是成功的。除了讲述男主制造不在场证据和他与局长的博弈之外，男主与家人的心理刻画，两位母亲形象的表现，都是相当具有感染力的。值得一提的是，本片大量致敬了以往的经典电影：《肖申克的救赎》，《活埋》，《蒙太奇》，《控方证人》，
《天才枪手》，《猫鼠游戏》，《杀人回忆》等。在这里面，需要重点介绍一下《活埋》、《蒙太奇》和《杀人回忆》三部电影在本片中的作用。</p>
<p>就讲述手段来看，本片仍然有比较显著的缺点，这重点体现了电影的开头和结尾两个部分。如果说本片一开头就致敬《活埋》并且将其作为一个伏笔的话，也未免太过着急或显眼。这段回忆式的致敬，也即对《肖申克的救赎》和《活埋》场景的再现，让观众在看完本片之后，难免会产生着墨过多的冗余感。这导致了两个问题：（1）电影的引入太过生硬；（2）电影的节奏难以统一。在电影结尾部分，导演显然致敬了韩国电影《杀人回忆》，以此将话语权交换给观众，让观众发声。这样的处理自然没有问题，然而，在国产电影标注Happy
Ending的设定下，影片的结尾部分显然出现了导演表现力上的断裂：一方面，导演想让观众自我评判电影及男主的行为，另一方面，受制于各种不可描述的环境，导演又不得不以“坏人自白”和“好人自首”来草草收尾，这必然导致电影中期紧张的节奏和后期好人齐唱社会好的慢节奏形成冲突，导演再次致敬《杀人回忆》的结尾，就有狗尾续貂之嫌。</p>
<p>抛开这两点显著的不足来看，本片在故事的讲述上无疑是成功的。中期影片节奏把控得相当精准，既能保持较快的节奏，时刻抓住观众想要知道后续的心，又能娓娓道来，不遗漏重要细节。譬如影片中间，男主到现场看新警察局装修情况的桥段，就在短短几分钟的情节内告诉了观众几个重要的细节：（1）男主仔细观察了地上的坑，再联系最后说尸体埋藏地点不方便透露，观众可以很简单地猜测到埋藏地点；（2）被子弹射死的山羊，是成为“替罪羊”的关键之物；（3）警官公报私仇，与李维杰进一步结怨，成为后面他引发众怒的导火索。</p>
<p>另外一个值得注意的细节是，本片多次出现白色山羊，这显然是导演有意为之。在此，我引用豆瓣上的一篇影评对此的分析（
https://movie.douban.com/review/12076729/ ），摘录如下：</p>
<p>电影中羊的四次出现：第一次在湖边看到男主抛车（知道男主有罪），第二次被警察打死（代替男主受罚），第三次开棺验尸（作为替罪羊，帮男主掩埋真相），第四次男主决定认罪后，活羊重新出现，寺庙响起钟声（都预示着男主释然，已经放下心结，决心认罪接受惩罚）。</p>
<h1 id="画面与音乐">画面与音乐</h1>
<p>导演非常擅长使用电影中画面和音乐的技巧。电影中的音乐是烘托气氛和人物内心活动的重要工具，而画面则直接决定了观众的视觉体验。由于笔者缺乏视听的专业知识，难以用简洁明了的话语概括，故在此引用豆瓣另一篇影评对此的分析（
https://movie.douban.com/review/12090128/ ），摘录如下：</p>
<h2 id="交叉蒙太奇">交叉蒙太奇</h2>
<p>这版《误杀》将“听经”改为“泰拳”，在电影前半段，就有一段很精彩的拳赛段落，这段拳赛是和素察上门交叉剪辑在一起的。</p>
<p>李维杰之所以利用看拳赛为全家制造不在场证明，是因为“误杀”这件事发生的同时，也就是2号晚上，他就在看拳赛。</p>
<p>李维杰2号出差给罗统的酒店维修网络，晚上完工后看到酒店房间塞的小卡片，决定去看泰拳休闲娱乐。同时，官二代素察来到灿班镇李维杰家里调戏大女儿，并与察觉不对劲的妈妈阿玉产生冲突。</p>
<p>在这同一时间，不同空间，李维杰在看泰拳纠打，阿玉和大女儿在和素察纠打。导演对这两段戏采用了交叉蒙太奇的手法。</p>
<p>一边是泰拳拳手踢到肚子，一边素察踢到阿玉，一边拳手倒地，一边素察倒地……而且“拳赛”和“误杀”两边的镜头时长越来越短，镜头切换越来越快，节奏也越来越紧张。</p>
<p>通过这一手段，导演将李维杰完全不知情的状态，与官二代对妻女的欺凌和误杀剪辑在一起，观众在这段观影过程中是全知视角，神经逐渐被绷紧。</p>
<p>这段交叉蒙太奇，既完成了误杀官二代的过程，又给后知后觉的李维杰出了一个难题。观众在紧张过后，心理继续被剧情调动：接下来李维杰和全家该怎么办？</p>
<h2 id="慢镜头">慢镜头</h2>
<p>《误杀》中的“慢镜头”大概有10次以上。</p>
<p>尤其是最后在大雨里开棺启尸那场终极对决，几乎整段都使用了慢动作镜头。</p>
<p>使用慢镜头的目的大概分为“制造滑稽效果”、“强调心理对时间的感受”或“凸显某一重要时刻”等，这部电影多次使用慢镜头的目的肯定是后两个。</p>
<p>比如李维杰销毁素察的车这段戏，当时人物心理非常紧张。李维杰看到高速路上警察设卡和牧羊人路过时，都用慢镜头来强化李维杰当时紧张的心情。</p>
<p>最后大雨是全片的高潮。慢镜头配上暴雨的场面调度，雨滴的速度也被放慢，不仅制造出震撼的视觉效果，也通过刻意放慢速度，主观上加长寻找尸体的时间，提升李维杰最后一击的震惊感。</p>
<h2 id="布光">布光</h2>
<p>《误杀》中利用布光塑造人物和烘托氛围最明显的，就是陈冲饰演的女警察局长。</p>
<p>女警察局长这个角色非常复杂，她既要在下属面前树威，又迟迟攻破不了李维杰的手段，还要忍受母亲失去儿子的巨大痛苦，同时还得顾忌丈夫竞选市长。</p>
<p>所以，导演对陈冲出场戏份的布光特别丰富。有一个镜头是陈冲在灿班镇警察局，脸上是百叶窗投下的如钢锯般的光影。这种非常特殊的光影投射在人物脸上，体现出当时人物内心巨大的痛苦和矛盾。</p>
<p>除了陈冲，导演对主角李维杰和阿玉的布光也做了精心安排。</p>
<p>比如李维杰从罗统回到家后，得知大女儿被侮辱，妻女又把素察误杀，从此全片的影调全部变成低调光（low
key）。</p>
<p>李维杰在得知这一痛心+震惊的消息时，脸上几乎没有打光。这样处理，非常鲜明地表现了李维杰和一家人的生活从此陷入黑暗。他们要在一点点微光中，找寻希望。</p>
<p>观影时可以注意，电影仅仅在前15分钟和后15分钟有比较明亮的打光，从误杀案后就再无亮光，全片影调变得非常暗。</p>
<h2 id="特殊音效">特殊音效</h2>
<p>如果仔细听，电影在很多重要时刻都加入了特殊音效来渲染气氛。比如电影最后开棺，当镜头中显示的尸体不是素察而是一只羊时，背景音给了一声巨响，用来增强观众此时的心理感受。</p>
<h1 id="主题与立意">主题与立意</h1>
<p>关于本片的主题与立意，不同的观众自然有不同的想法。在这里，我认为有以下三点是比较明显的，即“法律正义”、“子女教育”与“选择冲突”。</p>
<h2 id="法律正义">法律正义</h2>
<p>法律是不是代表了正义？这是一个没有答案的问题。如果法律保证了正义，那么为什么还会有如此多不正义的事情发生？李维杰一家是受害者，但却不得不背负着杀人偿命的罪煞费心机制造一系列不在场证明（尽管杀人的事实客观成立）；但如果说法律不是正义，那么从客观来讲，它的确是保障社会稳定的最有效方法。警长的公报私仇最终还是遭到了愤怒民众的惩罚，滥用私权的局长拉韫也被撤职，正义还是到了。然而，在这正义之下，我们看到的，只有一个双输的局面：局长方全面溃败，李维杰方全家也将面临牢狱之灾。在这种法律正义的庇护之下，没有任何一方的权益得到了满足，也没有任何一个人获得了切实的好处。</p>
<p>追根到底，这还是法律正义性的缺陷导致的必然结果。如果素察不是局长的儿子，李维杰一家人会得到应有的正义吗？如果李维杰没有看过那么多电影，或者一开始就束手就擒，平平被侮辱的真相能得到审判吗？尽管我们想要去解决这个问题，但现实是，人性的复杂根本无法用简单的“正义”得以阐释。法律无法接纳家长对子女的爱与纵容，也无法兼容“理性的公义”与“感性的迁就”的平衡。</p>
<h2 id="子女教育">子女教育</h2>
<p>子女教育是本片第二个十分明确的立意。小女儿安安目睹了母亲和姐姐杀人埋尸的全过程，然而却在父亲的指导下学会了如何撒谎。这在本片结尾她篡改分数体现得淋漓尽致。本来应该是天真无邪的女儿，却因为自己做的这个事情熟练地学会了如何撒谎、如何欺骗，相比“误杀”，这让男主是更难以接受的。注意到在这个时候，此刻男主一家已经完全不会被追查了：拉韫一家无权无势，所有证据烟消云散，没有人证、没有物证，他完全可以选择逍遥法外。然而，男主最后竟然选择了自首，这岂不是让他之前做的一切都白费了吗？如此说不通的逻辑，是在两件事之后得到的转变：（1）女儿修改成绩的试卷：身为父亲却言传身教教会了女儿最不能学会的恶习，这在男主心中是难以承担的。通过路人的口，我们知道男主自幼丧亲，如何做人是他立身之本，他可以为了家人背叛他的原则（在影片开头，他向僧人布施的情节可以体现他是一个对自身要求很高的人），也可以为了家人（女儿）重拾他的原则；（2）寺庙里的醒悟：寺庙是男主最后的救赎。当他第二次向僧人布施遭到拒绝的时候，他实际上内心是煎熬的。但在最后，为了暴乱不再延续，为了子女成长，他选择了“挡在最前面”，得到内心的自由。</p>
<p>在素察方面，由于其父亲的疏于管教，母亲的溺爱，其最终的结局无非是“大快人心”的。和现实结合的同时，观众也能感受到父母对子女教育的重要性。身为警长的母亲，掌握着执法权而选择了包庇有过错的儿子；身为政客的父亲，只能责打自己的儿子来管教他。无法用公平的武器制裁亲人的犯罪，无法用有效的裁断约束亲人的叛逆，这样的警官，这样的政客，你们敢信任吗？正如在影片最后，男主在囚车中的自白一样，最后他竟然以这样的方式取得女儿的信任，这是荒诞而遗憾的。无论他之前在教育中出现了如何的问题，至少在现在，他用自己的行为证明了，他是一个伟大的父亲。</p>
<h2 id="选择冲突">选择冲突</h2>
<p>另外一个值得注意的点是，男主的选择奠定了本片的基调。本片有一个重复提及的细节：一开始，素察被平平击昏时，并没有当场死去。理由如下：（1）女主推车出去时，镜头给了素察一个手部特写；（2）男主多次凝视棺材；（3）男主第二次向僧人布施时遭到了拒绝，并且镜头显示了男主十分惊慌的表情；（4）影片高潮，揭开棺材时，棺材板上血淋淋的抓痕（这是最直接的证据，这表明素察是活活被憋死，或者被男主直接杀害的）；（5）影片最后，男主对局长夫妇致歉；（6）男主最后自首。结合这些或明或暗的事实，我们不难推出：在仓库素察只是被击昏，而真正导致素察死亡的原因是男主，为了“不让自己的家人受到伤害”，所以他选择了杀死素察，或见死不救。这个地方影片也有充分的暗示，一是影片开头致敬电影《活埋》的桥段，可以认为素察是被“活埋”致死；二是镜头给了被子弹射死的山羊的特写。</p>
<p>以男主的标准来看，他在救与不救之间是经过了痛苦的煎熬的：小女儿安安用叉子划桌子的声音和素察在棺材里绝望地用手划棺材盖的声音是相似的。但最终，他选择了保护家人，直接或间接地杀死了素察。在影片结尾，他选择自首这点上，他没有欺骗，只是除了他自己之外，任何人都不知道，他只能用这种方式，对局长夫妇、对无辜的被他利用的路人、对自己的家人，表达愧疚，与忏悔。</p>
<p>男主是纯粹的，而往往纯粹的人最容易陷入万劫不复的矛盾之中。</p>
]]></content>
      <categories>
        <category>电影 - 国产电影</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>矫正透视投影插值及属性插值详解</title>
    <url>/2021/08/14/23/31/</url>
    <content><![CDATA[<p>三角形是图形学的基本几何形状，空间中的三角形<span
class="math inline">\(ABC\)</span>投射到屏幕空间中为<span
class="math inline">\(A&#39;B&#39;C&#39;\)</span>。在<span
class="math inline">\(A&#39;B&#39;C&#39;\)</span>内存在一点<span
class="math inline">\(P&#39;\)</span>，它的某个属性<span
class="math inline">\(S_{P&#39;}\)</span>常常用三个顶点的属性<span
class="math inline">\(S_{A&#39;}, S_{B&#39;},
S_{C&#39;}\)</span>的插值表示，即<strong>重心坐标</strong>（Barycentric
coordinates）。然而，在屏幕空间中计算得出的<span
class="math inline">\(P&#39;\)</span>点在三角形<span
class="math inline">\(A&#39;B&#39;C&#39;\)</span>内的重心坐标<span
class="math inline">\((x_{P&#39;},y_{P&#39;},z_{P&#39;})\)</span>却不一定等于投影前三维空间内<span
class="math inline">\(P&#39;\)</span>对应点<span
class="math inline">\(P\)</span>在三角形<span
class="math inline">\(ABC\)</span>内的重心坐标<span
class="math inline">\((x_{P},y_{P},z_{P})\)</span>。这是因为从三维空间到屏幕空间需要执行<strong>透视投影</strong>（Perspective
Projection），这个投影是非线性的，因此变换前的重心坐标并不能和变换后的重心坐标保持线性关系，从而对三角形顶点的属性插值也不是线性关系。这就需要对透视投影下的重心坐标插值进行修正。本文从透视投影本身出发，说明其非线性性，并根据论文《Perspective-Correct
Interpolation》<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> 给出修正插值。</p>
<span id="more"></span>
<h1 id="透视投影的非线性性">透视投影的非线性性</h1>
<h2 id="三维空间点和向量的表示">三维空间点和向量的表示</h2>
<p>图形学一般关心三维空间，或者三维空间中的点<span
class="math inline">\((x,y,z)\)</span>。在数学中，<span
class="math inline">\((x,y,z)\)</span>既可以表示一个点，也可以表示一个向量，但是在图形学中，我们希望能够将二者区分开来，一个优雅的做法是，增加一个“第四维”，将<span
class="math inline">\((x,y,z)\)</span>变为<span
class="math inline">\((x,y,z,w)\)</span>。当<span
class="math inline">\(w=1\)</span>时，原来的<span
class="math inline">\((x,y,z)\)</span>就表示点，当<span
class="math inline">\(w=0\)</span>时，<span
class="math inline">\((x,y,z)\)</span>就表示一个向量。这样做的好处是，两个点相减可以正好得到一个向量：</p>
<p><span
class="math display">\[(x_1,y_1,z_1,1)-(x_2,y_2,z_2,1)=(x_1-x_2,y_1-y_2,z_1-z_2,0)\]</span></p>
<p>以此类推，向量+点=点（可以理解为某个点沿着向量移动到了另一个点），向量+向量=向量，点+点则无定义。</p>
<p>对点<span
class="math inline">\((x,y,z,1)\)</span>来说，我们可以把每个元素都乘以系数<span
class="math inline">\(k\)</span>，成为<span
class="math inline">\((kx,ky,kz,k)\)</span>，尽管这时候<span
class="math inline">\(w=k\neq 1\)</span>，但我们依然认为点<span
class="math inline">\((kx,ky,kz,k)\)</span>和点<span
class="math inline">\((x,y,z,1)\)</span>是同一个点，这是因为当把<span
class="math inline">\((kx,ky,kz,k)\)</span>中的每个元素都除以<span
class="math inline">\(k\)</span>之后，它就是<span
class="math inline">\((x,y,z,1)\)</span>。</p>
<p>这里需要注意的是，“等价”不代表“应然”，在实际使用点的时候（即用点的坐标进行运算的时候），我们仍然要用<span
class="math inline">\(w=1\)</span>的版本，也就是<span
class="math inline">\((x,y,z,1)\)</span>，而不是<span
class="math inline">\((kx,ky,kz,k)\)</span>，后者只是为了在一些情况下方便计算。所以在确定好点的空间坐标之后，就要立刻对点进行归一化，把<span
class="math inline">\(w\)</span>变成1，其他元素都要同样除以<span
class="math inline">\(w\)</span>。这一点实际上就是透视投影矩阵非线性的根源，下面详细介绍。</p>
<h2 id="透视投影矩阵">透视投影矩阵</h2>
<p>（注：以下内容整理、改编自《GAMES101-现代计算机图形学入门-闫令琪》Lecture
4的内容。<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>）</p>
<p>上面我们已经介绍了三维空间中的点<span
class="math inline">\(A=(x,y,z,1)\)</span>，这个点要投影到屏幕空间中形成2D效果，就要经过一系列变换。最简单的变换就是把<span
class="math inline">\(z\)</span>扔掉，只保留<span
class="math inline">\((x,y)\)</span>，这个二维向量就是点<span
class="math inline">\(A\)</span>在屏幕空间<span
class="math inline">\(xOy\)</span>中对应的位置<span
class="math inline">\(A&#39;=(x,y)\)</span>。</p>
<p>但是我们人眼在看的时候具有“透视”效果，也就是远处的物体看起来更小，近处的物体看起来更大，而直接用上述做法会让远处的物体和近处的物体看起来一样大。因此在图形学中，我们还需要对点<span
class="math inline">\(A=(x,y,z,1)\)</span>做<strong>透视投影</strong>，让它呈现出“近大远小”的效果。</p>
<p>如果用一个矩阵表示这个透视投影，那么这个“从三维空间变换为屏幕空间”的过程，就可以描述为：</p>
<p><span class="math display">\[A&#39;=\mathbf{M}A\]</span></p>
<p>其中<span class="math inline">\(\mathbf{M}\in\mathbb{R}^{4\times
4}\)</span>就是我们要求的透视投影矩阵。<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>下面的目标就是如何求出这<span
class="math inline">\(4\times 4=16\)</span>个矩阵内的元素。</p>
<p>以下图为例。</p>
<figure>
<img data-src="/images/correct-interpolation/1.png"
alt="三维空间中一个点的x坐标和y坐标满足一定的相似性关系，因此可以直接得出相应的透视投影变换关系。点击图片查看高清原图。" />
<figcaption
aria-hidden="true">三维空间中一个点的x坐标和y坐标满足一定的相似性关系，因此可以直接得出相应的透视投影变换关系。点击图片查看高清原图。</figcaption>
</figure>
<p>从平面<span
class="math inline">\(yOZ\)</span>看去，三维空间中的点<span
class="math inline">\(A=(x,y,z,1)\)</span>经过透视投影后的点，在近平面上的位置是屏幕空间（近平面）中的点<span
class="math inline">\(A&#39;=(x&#39;,y&#39;,n)\)</span>，这个时候就可以利用相似三角形法则，得到：</p>
<p><span class="math display">\[\frac{z}{n}=\frac{y}{y&#39;}\Rightarrow
y&#39;=\frac{n}{z}y\]</span></p>
<p>同样地，对于<span
class="math inline">\(xOZ\)</span>平面，也可以得到：</p>
<p><span class="math display">\[\frac{z}{n}=\frac{x}{x&#39;}\Rightarrow
x&#39;=\frac{n}{z}x\]</span></p>
<p>这就是说，透视投影实际上做了下述的变换：</p>
<p><span
class="math display">\[(x,y,z,1)\Rightarrow(\frac{nx}{z},\frac{ny}{z},?,1)\]</span></p>
<p>现在把每个元素都乘以<span class="math inline">\(z\)</span>，得到<span
class="math inline">\((nx,ny,?,z)\)</span>。这时候，就有下述方程：</p>
<p><span
class="math display">\[\mathbf{M}(x,y,z,1)^\text{T}=(nx,ny,?,z)^\text{T}
\]</span></p>
<p>所以可以解得矩阵<span
class="math inline">\(\mathbf{M}\)</span>是：</p>
<p><span class="math display">\[\mathbf{M}=\begin{pmatrix}
  n &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; n &amp; 0 &amp; 0\\
  ? &amp; ? &amp; ? &amp; ?\\
  0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]</span></p>
<p>为什么这里的第三维<span
class="math inline">\(z\)</span>不是刚才说的近平面<span
class="math inline">\(n\)</span>呢？这是因为经过透视投影，也就是把点左乘矩阵<span
class="math inline">\(\mathbf{M}\)</span>之后，<span
class="math inline">\(z\)</span>不一定就是<span
class="math inline">\(n\)</span>，只是说，我们在保持<span
class="math inline">\(x,y\)</span>不变的情况下，把<span
class="math inline">\(z\)</span>平移到近平面<span
class="math inline">\(n\)</span>之后，有上述的相似关系。又或者说，当我们从原点往近平面方向看，把近平面当成一个二维空间的时候，在屏幕空间上显示出来的投影后的点<span
class="math inline">\(A&#39;\)</span>是<span
class="math inline">\((x&#39;,y&#39;,n)\)</span>。</p>
<p>比如下面的图二，点<span
class="math inline">\(A\)</span>经过透视投影之后真正的位置在蓝色虚线上的某一点，它的<span
class="math inline">\(z&#39;\)</span>我们目前是不知道的，但是它的<span
class="math inline">\(x&#39;,y&#39;\)</span>我们可以通过上面的相似关系确定下来。</p>
<figure>
<img data-src="/images/correct-interpolation/2.png"
alt="三维空间中点，如果它在近平面或者或平面上，则它的z坐标不变。可以利用这个性质解出最终的透视投影矩阵\mathbf{M}。点击图片查看高清原图。" />
<figcaption
aria-hidden="true">三维空间中点，如果它在近平面或者或平面上，则它的z坐标不变。可以利用这个性质解出最终的透视投影矩阵<span
class="math inline">\(\mathbf{M}\)</span>。点击图片查看高清原图。</figcaption>
</figure>
<p>那么真正的<span
class="math inline">\(z&#39;\)</span>是什么呢？这就要利用透视投影的两个性质：
- 如果一个点在近平面<span
class="math inline">\(z=n\)</span>上，那么经过透视投影之后它的位置不变：
<span
class="math display">\[(x,y,n,1)\Rightarrow(x,y,n,1)\Rightarrow(nx,ny,n^2,n)\]</span>
- 如果一个点在远平面<span
class="math inline">\(z=f\)</span>上，那么经过透视投影之后它的<span
class="math inline">\(z\)</span>不变： <span
class="math display">\[(x,y,f,1)\Rightarrow(x&#39;,y&#39;,f,1)\Rightarrow(fx&#39;,fy&#39;,f^2,f)\]</span>
特殊地，当<span class="math inline">\(x=y=0\)</span>时有<span
class="math inline">\((0,0,f,1)\Rightarrow(0,0,f,1)\Rightarrow(0,0,f^2,f)\)</span>。</p>
<p>如果把矩阵<span
class="math inline">\(\mathbf{M}\)</span>未知的四个量分别设为<span
class="math inline">\(a,b,c,d\)</span>，那么通过<span
class="math inline">\(\mathbf{M}(x,y,n,1)^\text{T}=(nx,ny,n^2,n)\)</span>我们有：</p>
<p><span class="math display">\[ax+by+cn+d=n^2\]</span></p>
<p>因为右式不包含<span class="math inline">\(x,y\)</span>，所以<span
class="math inline">\(a=b=0\)</span>且<span
class="math inline">\(cn+d=n^2\)</span>。</p>
<p>同时，由<span
class="math inline">\(\mathbf{M}(0,0,f,1)^\text{T}=(0,0,f^2,f)\)</span>得到：</p>
<p><span class="math display">\[cf+d=f^2\]</span></p>
<p>与<span class="math inline">\(cn+d=n^2\)</span>联立求解，就得到<span
class="math inline">\(c=n+f,d=-nf\)</span>。</p>
<p>所以，最终就解得透视投影矩阵<span
class="math inline">\(\mathbf{M}\)</span>为：</p>
<p><span class="math display">\[\mathbf{M}=\begin{pmatrix}
  n &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; n &amp; 0 &amp; 0\\
  0 &amp; 0 &amp; n+f &amp; -nf\\
  0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]</span></p>
<p>这是一个典型的线性变换，把三维空间中的一个点<span
class="math inline">\(A\)</span>变换到了透视投影之后的某个位置<span
class="math inline">\(\mathbf{M}A\)</span>。</p>
<p>现在有个有趣的小问题：透视投影之后的新点<span
class="math inline">\(A&#39;\)</span>（注意不是平移到近平面上的点）的<span
class="math inline">\(z&#39;\)</span>值和原来的<span
class="math inline">\(z\)</span>相比，谁大？我们只需要计算一下即可：</p>
<p><span
class="math display">\[z&#39;=\frac{(n+f)z-nf}{z}&gt;z\Rightarrow
z^2-(n+f)z+nf&gt;0\]</span></p>
<p>分子的<span class="math inline">\((n+f)z-nf\)</span>就是将矩阵<span
class="math inline">\(\mathbf{M}\)</span>的第三行与三维空间中的点<span
class="math inline">\(A=(x,y,z,1)\)</span>点乘后的结果，除以<span
class="math inline">\(z\)</span>是因为矩阵<span
class="math inline">\(\mathbf{M}\)</span>的实际上是把每个维度都乘了<span
class="math inline">\(z\)</span>的结果，所以还需要除以<span
class="math inline">\(z\)</span>还原<strong>真实</strong>的<span
class="math inline">\(z&#39;\)</span>值（回忆一下我们开始讲的要用真实的值参与计算）。</p>
<p>把<span
class="math inline">\(z\)</span>乘到右侧之后符号改变，因为这里的坐标轴默认使用的是朝向<span
class="math inline">\(-z\)</span>方向，这可以从上面两个图看出，其中<span
class="math inline">\(f&lt;n&lt;0\)</span>。</p>
<p>解上面的一元二次方程，就得到：</p>
<p><span
class="math display">\[z_{1,2}=\frac{(n+f)\pm\sqrt{(n+f)^2-4nf}}{2}=n~~\text{and}~~f\]</span></p>
<p>所以，只要当<span class="math inline">\(z&gt;n\)</span>或者<span
class="math inline">\(z&lt;f\)</span>的时候，变换后的<span
class="math inline">\(z\)</span>才比原来的<span
class="math inline">\(z\)</span>大，然而<span
class="math inline">\(z\)</span>本身就被限制在了<span
class="math inline">\([f,n]\)</span>内，所以，透视投影后的<span
class="math inline">\(z&#39;\)</span><strong>永远</strong>比变换前的<span
class="math inline">\(z\)</span>小。换句话说，透视投影把一个点“拉得离屏幕更远”了。</p>
<h2
id="属性插值与透视投影矩阵的非线性性">属性插值与透视投影矩阵的非线性性</h2>
<p>也许你可能会问了，矩阵<span
class="math inline">\(\mathbf{M}\)</span>不是个线性变换吗，你怎么说透视投影是非线性的。的确，计算出来的矩阵<span
class="math inline">\(\mathbf{M}\)</span>只涉及常数，包括<span
class="math inline">\(0, 1, n,
f\)</span>，但是别忘了，它计算出来的结果，是把向量的每一维度都乘以<span
class="math inline">\(z\)</span>之后得到的结果。真正的经过透视投影后得到的点，还要把每个元素除以<span
class="math inline">\(z\)</span>才行。正是这个“除以<span
class="math inline">\(z\)</span>”的操作，决定了整个透视投影是非线性的。</p>
<p>下图是一个例子。三维空间中的线段<span
class="math inline">\(AB\)</span>，经过透视投影之后，在屏幕空间是<span
class="math inline">\(A&#39;B&#39;\)</span>（始终注意屏幕空间中点的位置和点的真实位置的区别，它们的<span
class="math inline">\(z&#39;\)</span>坐标是不同的）。这时候，直接在屏幕空间中计算重心坐标，得到了<span
class="math inline">\(C&#39;\)</span>点，它正好位于<span
class="math inline">\(A&#39;B&#39;\)</span>的中间位置，所以，它的属性就应该是<span
class="math inline">\(A&#39;\)</span>和<span
class="math inline">\(B&#39;\)</span>属性的简单平均，也就是<span
class="math inline">\((0.5+1)/2=0.75\)</span>。</p>
<figure>
<img data-src="/images/correct-interpolation/3.png"
alt="屏幕空间的插值不一定与原三维空间的插值保持线性关系。在该图中，A&#39;C&#39;=B&#39;C&#39;，因此C&#39;点的属性就是A&#39;点和B&#39;点的平均，为(0.5+1.0)/2=0.75。但是在原三维空间中，AC的长度不等于BC的长度，因此C点的属性必然不为0.75。然而我们真正关心的是在三维空间中的真实插值，所以需要对屏幕空间中的插值进行修正。" />
<figcaption
aria-hidden="true">屏幕空间的插值不一定与原三维空间的插值保持线性关系。在该图中，A'C'=B'C'，因此C'点的属性就是A'点和B'点的平均，为<span
class="math inline">\((0.5+1.0)/2=0.75\)</span>。但是在原三维空间中，AC的长度不等于BC的长度，因此C点的属性必然不为0.75。然而我们真正关心的是在三维空间中的真实插值，所以需要对屏幕空间中的插值进行修正。</figcaption>
</figure>
<p>但是，我们真正关心的不是在屏幕空间中插值，而是在透视投影之前，真正的点<span
class="math inline">\(C\)</span>它位于线段<span
class="math inline">\(AB\)</span>的什么位置，在这个位置的基础上插值，才是点<span
class="math inline">\(C\)</span>，或者点<span
class="math inline">\(C&#39;\)</span>的属性。这里的属性也包括点<span
class="math inline">\(C&#39;\)</span>的深度值<span
class="math inline">\(z&#39;\)</span>。</p>
<p>从图中可以看到，尽管在屏幕空间中<span
class="math inline">\(C&#39;\)</span>位于<span
class="math inline">\(A&#39;B&#39;\)</span>的正中间，但是在原来的线段<span
class="math inline">\(AB\)</span>中，点<span
class="math inline">\(C\)</span>却不是在正中间位置，这正是由透视投影的非线性性导致的，或者说，是由“除以<span
class="math inline">\(z\)</span>”这个操作导致的。</p>
<h1 id="插值修正">插值修正</h1>
<p>那么点<span class="math inline">\(C\)</span>，或者点<span
class="math inline">\(C&#39;\)</span>真正的属性值是多少呢？显然，我们不能再直接用屏幕空间内的插值结果了。</p>
<p>我们以下图为例说明如何对插值进行修正。设屏幕空间的点<span
class="math inline">\(A&#39;=(y&#39;_1,n),B&#39;=(y&#39;_2,n)\)</span>以及它们中间的某个点<span
class="math inline">\(C&#39;=(y&#39;_s,n)\)</span>，其中<span
class="math inline">\(C&#39;\)</span>离<span
class="math inline">\(A&#39;\)</span>和<span
class="math inline">\(B&#39;\)</span>的距离分别是<span
class="math inline">\(s\)</span>和<span
class="math inline">\(1-s\)</span>。同理，在三维空间的点<span
class="math inline">\(A=(y_1,z_1),B=(y_2,z_2)\)</span>，以及它们中的某个点<span
class="math inline">\(C=(y_t,z_t)\)</span>。<span
class="math inline">\(C\)</span>离<span
class="math inline">\(A,B\)</span>的距离分别是<span
class="math inline">\(t\)</span>和<span
class="math inline">\(1-t\)</span>。点<span
class="math inline">\(A,B,C\)</span>的属性分别记为<span
class="math inline">\(I_A,I_B\)</span>和<span
class="math inline">\(I_t\)</span>。现在给定<span
class="math inline">\(t,I_t\)</span>和点<span
class="math inline">\(C\)</span>之外的值，要求出<span
class="math inline">\(I_t\)</span>。</p>
<p>进一步，因为我们知道<span
class="math inline">\(I_t=t(I_B-I_A)+I_A\)</span>，而<span
class="math inline">\(I_A,I_B\)</span>又是已知的，所以这里的关键就是求出<span
class="math inline">\(t\)</span>。</p>
<figure>
<img data-src="/images/correct-interpolation/4.png"
alt="设屏幕空间的点A&#39;=(y&#39;_1,n),B&#39;=(y&#39;_2,n)以及它们中间的某个点C&#39;=(y&#39;_s,n)，其中C&#39;离A&#39;和B&#39;的距离分别是s和1-s。同理，在三维空间的点A=(y_1,z_1),B=(y_2,z_2)，以及它们中的某个点C=(y_t,z_t)。C离A,B的距离分别是t和1-t。点A,B,C的属性分别记为I_A,I_B和I_t。现在给定t,I_t和点C之外的值，要求出I_t。" />
<figcaption aria-hidden="true">设屏幕空间的点<span
class="math inline">\(A&#39;=(y&#39;_1,n),B&#39;=(y&#39;_2,n)\)</span>以及它们中间的某个点<span
class="math inline">\(C&#39;=(y&#39;_s,n)\)</span>，其中<span
class="math inline">\(C&#39;\)</span>离<span
class="math inline">\(A&#39;\)</span>和<span
class="math inline">\(B&#39;\)</span>的距离分别是<span
class="math inline">\(s\)</span>和<span
class="math inline">\(1-s\)</span>。同理，在三维空间的点<span
class="math inline">\(A=(y_1,z_1),B=(y_2,z_2)\)</span>，以及它们中的某个点<span
class="math inline">\(C=(y_t,z_t)\)</span>。<span
class="math inline">\(C\)</span>离<span
class="math inline">\(A,B\)</span>的距离分别是<span
class="math inline">\(t\)</span>和<span
class="math inline">\(1-t\)</span>。点<span
class="math inline">\(A,B,C\)</span>的属性分别记为<span
class="math inline">\(I_A,I_B\)</span>和<span
class="math inline">\(I_t\)</span>。现在给定<span
class="math inline">\(t,I_t\)</span>和点<span
class="math inline">\(C\)</span>之外的值，要求出<span
class="math inline">\(I_t\)</span>。</figcaption>
</figure>
<p>根据上图，我们可以利用相似三角形得到下述三个方程：</p>
<p><span class="math display">\[
\frac{y_1}{y&#39;_1}=\frac{z_1}{n}\Rightarrow
y_1=\frac{z_1y_1&#39;}{n}\tag{1}
\]</span></p>
<p><span class="math display">\[
\frac{y_t}{y&#39;_s}=\frac{z_t}{n}=z_t=\frac{ny_t}{y_s&#39;}\tag{2}
\]</span></p>
<p><span class="math display">\[
\frac{y_2}{y&#39;_2}=\frac{z_2}{n}\Rightarrow
y_2=\frac{z_2y_2&#39;}{n}\tag{3}
\]</span></p>
<p>同时，根据插值的性质，我们还有下述三个方程：</p>
<p><span class="math display">\[
y&#39;_s=s(y&#39;_2-y&#39;_1)+y&#39;_1\tag{4}
\]</span></p>
<p><span class="math display">\[
y_t=t(y_2-y_1)+y_1\tag{5}
\]</span></p>
<p><span class="math display">\[
z_t=t(z_2-z_1)+z_1\tag{6}
\]</span></p>
<p>现在，把公式(4)(5)带入公式(2)中，得到：</p>
<p><span class="math display">\[
z_t=\frac{n[t(y_2-y_1)+y_1]}{s(y&#39;_2-y&#39;_1)+y&#39;_1}\tag{7}
\]</span></p>
<p>再把公式(1)(3)带入公式(7)中，得到：</p>
<p><span class="math display">\[
z_t=\frac{t(z_2y_2&#39;-z_1y_1&#39;)+z_1y_1&#39;}{s(y&#39;_2-y&#39;_1)+y&#39;_1}\tag{8}
\]</span></p>
<p>再把公式(6)带入公式(8)：</p>
<p><span class="math display">\[
t(z_2-z_1)+z_1=\frac{t(z_2y_2&#39;-z_1y_1&#39;)+z_1y_1&#39;}{s(y&#39;_2-y&#39;_1)+y&#39;_1}\tag{9}
\]</span></p>
<p>把公式(9)化简，就得到了关于<span
class="math inline">\(t\)</span>的表达式：</p>
<p><span class="math display">\[
t=\frac{sz_1}{sz_1+(1-s)z_2}\tag{10}
\]</span></p>
<p>式(10)非常重要，它告诉了我们，使用屏幕空间中的插值<span
class="math inline">\(s\)</span>与三维空间中的深度值<span
class="math inline">\(z_1,z_2\)</span>可以得到三维空间中的真实插值<span
class="math inline">\(t\)</span>。</p>
<p>由于深度值<span
class="math inline">\(z_t\)</span>本身就是一种属性，所以自然可以使用插值计算。把式(10)带入式(6)，得到：</p>
<p><span class="math display">\[
z_t=z_1+\frac{sz_1}{sz_1+(1-s)z_2}(z_2-z_1)=\frac{1}{\frac{1}{z_1}+s(\frac{1}{z_2}-\frac{1}{z_1})}\tag{11}
\]</span></p>
<p>式(11)告诉我们，三维空间中真实的深度值<span
class="math inline">\(z_t\)</span>的计算方法。那么，真实的深度值，也式(11)，和直接在屏幕空间中插值出来的“虚假”的深度值<span
class="math inline">\(z&#39;_t=z_1+s(z_2-z_1)\)</span>哪个更大？下面直接令<span
class="math inline">\(z_t\le z&#39;_t\)</span>:</p>
<p><span class="math display">\[z_t\le z&#39;_t\Rightarrow
\frac{1}{\frac{1}{z_1}+s(\frac{1}{z_2}-\frac{1}{z_1})}\le z_1+s(z_2-z_1)
\Rightarrow s(1-s)(z_1-z_2)^2\le 0\tag{12}\]</span></p>
<p>当<span class="math inline">\(s=0\)</span>或<span
class="math inline">\(1\)</span>，即点<span
class="math inline">\(C\)</span>与点<span
class="math inline">\(A\)</span>或点<span
class="math inline">\(B\)</span>重合时，真实的深度值和虚假的深度值相等；否则，真实的深度值永远<strong>大于</strong>虚假的深度值（注意朝向的是<span
class="math inline">\(-z\)</span>方向，因此在把分母乘到右侧的时候需要变号）。换句话说，<strong>通过屏幕空间插值出来的深度值，比真实的值要偏小，或更远离屏幕</strong>。</p>
<p>为了得到<span class="math inline">\(I_t\)</span>，把式(10)带入到<span
class="math inline">\(I_t=t(I_B-I_A)+I_A\)</span>中，就有：</p>
<p><span class="math display">\[
I_t=I_A+\frac{sz_1}{sz_1+(1-s)z_2}(I_B-I_A)=\left(\frac{I_A}{z_1}+s\left(\frac{I_B}{z_2}-\frac{I_A}{z_1}\right)\right)\Big/\frac{1}{z_t}\tag{13}
\]</span></p>
<p>公式(13)就是要求的真实的插值结果。</p>
<p>上面是对线段的插值，那么对图形学中更常见的三角形如何插值呢？假定三维空间中三角形三个顶点的属性分别是<span
class="math inline">\(I_A,I_B,I_C\)</span>，它们的深度值分别是<span
class="math inline">\(z_A,z_B,z_C\)</span>。三角形内有一点<span
class="math inline">\(P\)</span>，属性值<span
class="math inline">\(I_P\)</span>和深度值<span
class="math inline">\(z_P\)</span>都未知，但是它在屏幕空间的重心坐标（在屏幕空间中<span
class="math inline">\(P&#39;\)</span>对点<span
class="math inline">\(A&#39;,B&#39;,C&#39;\)</span>的插值）是<span
class="math inline">\(a,b,c\)</span>。那么，根据式(11)，点<span
class="math inline">\(P\)</span>的真实深度值<span
class="math inline">\(z_P\)</span>就是：</p>
<p><span
class="math display">\[z_P=\frac{1}{\frac{a}{z_A}+\frac{b}{z_B}+\frac{c}{z_C}}\]</span></p>
<p>再根据式(13)，点<span
class="math inline">\(P\)</span>的真实属性值<span
class="math inline">\(I_P\)</span>是:</p>
<p><span
class="math display">\[I_P=\left(a\frac{I_A}{z_A}+b\frac{I_B}{z_B}+c\frac{I_C}{z_C}\right)\Big/\frac{1}{z_P}\]</span></p>
<p>这样，就用三维空间中三角形<span
class="math inline">\(ABC\)</span>的已知量和屏幕空间的重心坐标<span
class="math inline">\(a,b,c\)</span>求出了点<span
class="math inline">\(P\)</span>在三维空间中真实的深度值和属性值。</p>
<h1 id="结论">结论</h1>
<p>本文从透视投影的概念和推导出发，探究了透视投影的非线性性，进而引出对线段内部和三角形内部点的插值修正。我们真正关心的是在三维空间中对点的插值，而非直接在屏幕空间插值。本文的最后两个公式非常重要，希望读者能够记忆：</p>
<p><span
class="math display">\[z_P=\frac{1}{\frac{a}{z_A}+\frac{b}{z_B}+\frac{c}{z_C}}\]</span></p>
<p><span
class="math display">\[I_P=\left(a\frac{I_A}{z_A}+b\frac{I_B}{z_B}+c\frac{I_C}{z_C}\right)\Big/\frac{1}{z_P}\]</span></p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Low K L. Perspective-correct
interpolation[J]. Technical writing, Department of Computer Science,
University of North Carolina at Chapel Hill, 2002.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"
role="doc-endnote"><p>https://www.bilibili.com/video/BV1X7411F744?p=4<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"
role="doc-endnote"><p>实际上，在透视投影变换之后，还需要有<strong>正交投影</strong>变换进一步把点压缩到一个规定好的范围里。但因为正交投影仅仅涉及伸缩和平移操作，不涉及这里要讲的核心内容，故在此略去。有兴趣的读者可以参考GAMES101课程。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>西湖夜歌</title>
    <url>/2021/07/09/22/55/</url>
    <content><![CDATA[<p>霓光半遮影<br />
湖波轻颤合韵起<br />
半句寻谁去</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
        <tag>打油诗</tag>
      </tags>
  </entry>
  <entry>
    <title>Bump Mapping, Normal Mapping and Displacement Mapping</title>
    <url>/2022/10/12/18/39/</url>
    <content><![CDATA[<p>凹凸贴图（Bump
mapping）是图形学中一种常用的用于改变物体视觉凹凸性的方法，但是网上很多介绍对它的原理和变体都非常模糊，甚至包含一些关键概念的错误。本文将详细介绍凹凸贴图及其变体（Normal
Mapping和Displacement
Mapping）的原理，并在代码上加以实现，以便让读者更好地理解这项技术。</p>
<span id="more"></span>
<h1 id="凹凸贴图bump-mapping">凹凸贴图（Bump Mapping）</h1>
<p>现实中有很多物体表面都凹凸不平，比如橘子、砖墙等等，那么我们要如何用图形学的方法去渲染它们呢？最直接的方法就是把这些物体的表面细化为非常微小的三角形，然后走通用渲染流程。但是，由于凹凸分布过于密集，全部按实际模型渲染会导致不可接受的性能开销。</p>
<p>为此，我们能不能假设这种细微凹凸表面是一层贴在光滑物体表面的<strong>高度图</strong>，每个点都表示了高度的增量。比如我们想得到一个凹凸的橘子，我们可以假想这个橘子本来是一个光滑的球体（尽管橘子不是球体，但这里可以做一个简便的假设），这个球体上的每一点都对应到一个高度图上的一点，记录了当前点的相对高度，比如0.1cm，-0.05cm等等，然后再把这个相对高度应用到球体这一点的实际高度上，就形成该点的凹凸。对所有的点都去计算高度增量，就可以让整个球体变得凹凸不平了。</p>
<p>但是上面的方法还是实际上改变了球体上每个点的位置，而我们计算着色时，实际上只关心这个点的<strong>法线</strong>，有没有一种方法，可以不去实际改变点的位置，而是计算出<strong>改变这个点之后它的法线是怎么变化的</strong>，从而从视觉上营造出凹凸感（此时物体本身并没有任何变化）。这就是凹凸贴图做的事情。</p>
<h2 id="纹理空间中的法线">纹理空间中的法线</h2>
<p>前面已经说到了，我们可以用一张贴图<span
class="math inline">\(\mathcal{M}\)</span>去记录对应点的相对于它法线的高度变化。比如真实空间中的某个点<span
class="math inline">\(P\)</span>对应纹理坐标为<span
class="math inline">\((u,v)\)</span>，而<span
class="math inline">\(h(u,v)=0.5\)</span>，这就说明我们需要把点<span
class="math inline">\(P\)</span><strong>沿着它的法线方向</strong><span
class="math inline">\(\mathbf{n}\)</span>增高<span
class="math inline">\(0.5\)</span>。然而我们并不想实际改变点<span
class="math inline">\(P\)</span>，而只需要知道改变后的法线<span
class="math inline">\(\mathbf{n}&#39;\)</span>就行了。</p>
<p>那么怎么得到<span
class="math inline">\(\mathbf{n}&#39;\)</span>呢？首先来看一下在纹理中怎么表示法线。如果我们把纹理的<span
class="math inline">\(U\)</span>方向视为横轴，<span
class="math inline">\(V\)</span>方向视为纵轴，再以<span
class="math inline">\(W=U\times
V\)</span>为竖轴，那么我们就建立起一个以<span
class="math inline">\(UVW\)</span>为三轴的<strong>纹理空间</strong>。每个真实空间中点<span
class="math inline">\(P\)</span>的法向量<span
class="math inline">\(\mathbf{n}_P\)</span>都能对应到纹理空间中的向量<span
class="math inline">\(\mathbf{w}_P=(0,0,1)\)</span>，但是这个向量的起点在<span
class="math inline">\((u_P,v_P)\)</span>，其中<span
class="math inline">\(u_P,v_P\)</span>是点<span
class="math inline">\(P\)</span>的纹理坐标。换句话说，点<span
class="math inline">\(P\)</span>首先对应了一个纹理坐标<span
class="math inline">\((u_P,v_P)\)</span>，这个纹理坐标上有一个恒定的向量<span
class="math inline">\(\mathbf{w}_P=(0,0,1)\)</span>，这个向量和坐标<span
class="math inline">\((u_P,v_P)\)</span>一起，就对应了真实空间中<span
class="math inline">\(P\)</span>的法向量<span
class="math inline">\(\mathbf{n}_P\)</span>和<span
class="math inline">\(P\)</span>本身。</p>
<p>还记得我们上面强调了每个点高度的改变都是沿着它法线方向改变的吗？正是因为这样，我们才要把纹理空间中的每个点<span
class="math inline">\((u,v)\)</span>处的法向量定义为垂直向上的<span
class="math inline">\((0,0,1)\)</span>，这相当于是<strong>在纹理空间中模拟真实空间中的法向量，以及沿着法向量改变高度后的法向量如何变化</strong>。</p>
<p>这个纹理空间的三轴分别是<span
class="math inline">\(U,V,W\)</span>，每个<span
class="math inline">\((u,v)\)</span>都定义了一个朝上的法线向量<span
class="math inline">\(\mathbf{w}_{u,v}=(0,0,1)\)</span>。此外，这个空间还定义了每个点的相对高度<span
class="math inline">\(h(u,v)\)</span>。我们关心的是，<strong>在这个空间中，点<span
class="math inline">\((u,v)\)</span>在改变了相对高度<span
class="math inline">\(h(u,v)\)</span>之后它新的法线向量<span
class="math inline">\(\mathbf{w}&#39;_{u,v}\)</span>是什么</strong>。把这个新的法线<span
class="math inline">\(\mathbf{w}&#39;_{u,v}\)</span>应用到真实空间中点<span
class="math inline">\(P\)</span>的法线上，就是改变后的法线。</p>
<p>下图表现了这个过程，注意我们先从<span
class="math inline">\(UW\)</span>平面看去。点<span
class="math inline">\(u\)</span>（先不管<span
class="math inline">\(v\)</span>）原来的法线是<span
class="math inline">\(\mathbf{w}\)</span>（绿色向量），在应用该点的相对高度<span
class="math inline">\(h(u)\)</span>之后，新的法线是<span
class="math inline">\(\mathbf{w}&#39;\)</span>（红色向量）。
理论上来说，要准确地求出<span
class="math inline">\(\mathbf{w}&#39;\)</span>需要知道该点的切线（红色虚线），但这比较困难。我们可以用相邻点<span
class="math inline">\(u+1\)</span>去求近似切线，这是很容易办到的。</p>
<p>具体来说，相邻点的高度我们知道是<span
class="math inline">\(h(u+1)\)</span>，这样我们就能求出它在<span
class="math inline">\(W\)</span>方向上的差，值为<span
class="math inline">\(\Delta h(u)=h(u+1)-h(u)\)</span>，而<span
class="math inline">\(U\)</span>方向上的差值就是<span
class="math inline">\(1\)</span>，如此一来，我们就得到了一个近似的切线<span
class="math inline">\((1,c\cdot\Delta h(u))\)</span>，这里的<span
class="math inline">\(c\)</span>是一个系数用于调整斜率。知道了切线，我们就知道了法向量为<span
class="math inline">\(\mathbf{w}&#39;=\text{normalize}(-c\cdot\Delta
h(u),1)\)</span>。</p>
<p>对于真正的三维纹理空间也是一样的，对于平面<span
class="math inline">\(UW\)</span>，<span
class="math inline">\(W\)</span>方向的差值为<span
class="math inline">\(\Delta h(u)=h(u+1)-h(u)\)</span>，对于平面<span
class="math inline">\(VW\)</span>，<span
class="math inline">\(W\)</span>方向的插值为<span
class="math inline">\(\Delta
h(v)=h(v+1)-h(v)\)</span>。这样一来，近似法线就是<span
class="math inline">\(\mathbf{w}&#39;=\text{normalize}(-c_1\Delta
h(u),-c_2\Delta
h(v),1)\)</span>。这就是纹理空间中变换相对高度后的法线。</p>
<p><img data-src="/images/bump-map/1-1.png" /></p>
<h2 id="纹理空间世界空间与tbn矩阵">纹理空间，世界空间与TBN矩阵</h2>
<p>下面的问题是，既然我已经知道了<strong>纹理空间</strong>中变换高度后的法线<span
class="math inline">\(\mathbf{w}&#39;\)</span>，同时也知道了世界空间中原本的法线<span
class="math inline">\(\mathbf{n}\)</span>和纹理空间中原本的法线<span
class="math inline">\(\mathbf{w}\)</span>，怎么才能得到世界空间中变换高度后的法线<span
class="math inline">\(\mathbf{n}&#39;\)</span>。</p>
<p>现在我们再捋一下世界空间和纹理空间这两个空间。在世界空间中，所有的向量都是一个<strong>绝对值</strong>。比如现在三角形上的一个顶点<span
class="math inline">\(P\)</span>，它当前的法线是<span
class="math inline">\((0,1,0)\)</span>，如果此时把三角形连同点<span
class="math inline">\(P\)</span>任意旋转，那么<span
class="math inline">\(P\)</span>的法向量也会随之改变，比如到了<span
class="math inline">\((1,0,0)\)</span>。然而，在纹理空间中点<span
class="math inline">\(P\)</span>对应的纹理坐标<span
class="math inline">\((u,v)\)</span>和其之上的法向量<span
class="math inline">\(\mathbf{w}_{u,v}\)</span>是没有改变的！同时，使用上述过程计算出来的纹理空间中新的法向量<span
class="math inline">\(\mathbf{w}&#39;_{u,v}\)</span>也是没有改变的！这也就意味着纹理空间中的向量是一个<strong>相对值</strong>。无论世界空间中的点<span
class="math inline">\(P\)</span>如何运动，纹理空间中变化前和变化后的法向量都不会随之运动，纹理空间中的法向量和世界空间中法向量始终保持了一致的相对位置关系！</p>
<p>所以，我们现在的目标，就是要求出一个变换<span
class="math inline">\(f\)</span>，<strong>对每个特定的点<span
class="math inline">\(P\)</span></strong>，它能将世界空间中的法向量<span
class="math inline">\(\mathbf{n}\)</span>变换为纹理空间中的一个法向量；那么它的逆变换<span
class="math inline">\(f^{-1}\)</span>，就能把纹理空间中的法向量<span
class="math inline">\(\mathbf{w}\)</span>映射为世界空间中的法向量。我们想要的，就是<span
class="math inline">\(f^{-1}(\mathbf{w}&#39;)\)</span>。</p>
<p>我们不妨先考虑逆变换<span
class="math inline">\(f^{-1}\)</span>，它可以用一个矩阵<span
class="math inline">\(F^{-1}=\begin{bmatrix}\mathbf{a}&amp;\mathbf{b}&amp;\mathbf{c}\end{bmatrix}\)</span>表示。我们实际上很容易知道<span
class="math inline">\(\mathbf{c}=\mathbf{n}\)</span>，这是因为纹理空间中改变前的法向量<span
class="math inline">\(\mathbf{w}\)</span>需要和世界空间中改变前的法向量<span
class="math inline">\(\mathbf{n}\)</span>相对应：<span
class="math inline">\(F^{-1}\mathbf{w}=\mathbf{n}\
(\mathbf{w}=(0,0,1)^\top)\)</span>。我们还需要另外两个方程才能解出<span
class="math inline">\(\mathbf{a},
\mathbf{b}\)</span>。为此，我们可以通过点<span
class="math inline">\(P\)</span>所在的三角形<span
class="math inline">\(ABC\)</span>求解。</p>
<p>为此，假设三角形<span class="math inline">\(ABC\)</span>的边<span
class="math inline">\(AB\)</span>向量为<span
class="math inline">\(\mathbf{e}_1\)</span>，边<span
class="math inline">\(AC\)</span>向量为<span
class="math inline">\(\mathbf{e}_2\)</span>；在纹理空间中，<span
class="math inline">\(\mathbf{e}_1\)</span>对应的向量为<span
class="math inline">\(\mathbf{g}_1\)</span>，<span
class="math inline">\(\mathbf{e}_2\)</span>对应的向量为<span
class="math inline">\(\mathbf{g}_2\)</span>。其中<span
class="math inline">\(\mathbf{g}_1=(u_B-u_A,v_B-v_A,0)^\top\)</span>，<span
class="math inline">\(\mathbf{g}_2=(u_C-u_A,v_C-v_A,0)^\top\)</span>。那么根据我们的定义，显然有下述方程成立：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{e}_1&amp;=F^{-1}\mathbf{g}_1=\Delta u_1\mathbf{a}+\Delta
v_1\mathbf{b}\\
  \mathbf{e}_2&amp;=F^{-1}\mathbf{g}_2=\Delta u_2\mathbf{a}+\Delta
v_2\mathbf{b}
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(\Delta u_1=u_B-u_A,\Delta
v_1=v_B-v_A,\Delta u_2=u_C-u_A,\Delta v_2=v_C-v_A\)</span>。</p>
<p>整理成矩阵相乘，就有：</p>
<p><span class="math display">\[
\begin{aligned}
  \begin{bmatrix}
    \mathbf{e}_1\\\mathbf{e}_2
  \end{bmatrix}&amp;=\begin{bmatrix}
    \Delta u_1 &amp; \Delta v_1\\
    \Delta u_2 &amp; \Delta v_2
  \end{bmatrix}\begin{bmatrix}
    \mathbf{a}\\
    \mathbf{b}
  \end{bmatrix}\Rightarrow\\
  \begin{bmatrix}
    \mathbf{a}\\
    \mathbf{b}
  \end{bmatrix}&amp;=\begin{bmatrix}
    \Delta u_1 &amp; \Delta v_1\\
    \Delta u_2 &amp; \Delta v_2
  \end{bmatrix}^{-1}\begin{bmatrix}
    \mathbf{e}_1\\\mathbf{e}_2
  \end{bmatrix}=\frac{1}{\Delta u_1\Delta v_2-\Delta u_2\Delta
v_1}\begin{bmatrix}
    \Delta v_2 &amp; -\Delta v_1\\
    -\Delta u_2 &amp; \Delta u_1
  \end{bmatrix}\begin{bmatrix}
    \mathbf{e}_1\\\mathbf{e}_2
  \end{bmatrix}
\end{aligned}
\]</span></p>
<p>上式需要保证逆矩阵存在，即<span class="math inline">\(\Delta
u_1\Delta v_2\not=\Delta u_2\Delta v_1\)</span>。</p>
<p>但现在得到的<span
class="math inline">\(\mathbf{a},\mathbf{b},\mathbf{c}\)</span>两两之间并不保证互相垂直，这是因为从上面的式子我们不难发现<span
class="math inline">\(\mathbf{a}\)</span>和<span
class="math inline">\(\mathbf{b}\)</span>是关于<span
class="math inline">\(\mathbf{e}_1,\mathbf{e}_2\)</span>的线性组合，所以这两个基仍然在三角形<span
class="math inline">\(ABC\)</span>所在的平面上，而这个平面不一定和向量<span
class="math inline">\(\mathbf{n}\)</span>正交，而且<span
class="math inline">\(\mathbf{a}\)</span>和<span
class="math inline">\(\mathbf{b}\)</span>本身也不一定正交。</p>
<p>所以作为求解<span
class="math inline">\(F^{-1}\)</span>的最后一步，我们还要把这三个基正交化，我们可以使用Schmidt正交化：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{t}&amp;=\text{normalize}(\mathbf{a}-(\mathbf{a}\cdot\mathbf{n})\mathbf{n})\\
  \mathbf{b}&amp;=\mathbf{n}\times\mathbf{t}
\end{aligned}
\]</span></p>
<p>这样一来，<span
class="math inline">\(\mathbf{t},\mathbf{b},\mathbf{n}\)</span>就是两两正交的单位向量了，从而就得到了逆变换<span
class="math inline">\(F^{-1}=\begin{bmatrix}\mathbf{t}&amp;\mathbf{b}&amp;\mathbf{n}\end{bmatrix}\)</span>。由上面的过程可知，我们其实不用真正解出<span
class="math inline">\(\mathbf{b}\)</span>，因为它可以通过<span
class="math inline">\(\mathbf{n}\)</span>与<span
class="math inline">\(\mathbf{t}\)</span>的叉乘求得。</p>
<p>你也许会问，上面的推导过程我们为什么不直接用三角形的三个顶点，而要去用它的边呢？这是因为，<strong>向量</strong>和<strong>点</strong>本质上是不同的，尽管它们都可以用一个三维坐标表示。比如三维空间中的一个物体，它某个点的法向量是<span
class="math inline">\((0,0,1)\)</span>，把物体整体平移了之后，这个点的坐标发生了变化，但是它的法向量还是<span
class="math inline">\((0,0,1)\)</span>。既然我们只是向量感兴趣，那么所有的操作都是基于向量进行的。这一点务必理解。</p>
<p>现在，<span
class="math inline">\(F^{-1}\)</span>定义的空间就是以<span
class="math inline">\(\mathbf{t},\mathbf{b},\mathbf{n}\)</span>为基的空间，这个空间的“<span
class="math inline">\(Z\)</span>轴”就是<span
class="math inline">\(\mathbf{n}\)</span>，正好与<strong>世界空间</strong>中点<span
class="math inline">\(P\)</span>的原始法向量重合，而<span
class="math inline">\(\mathbf{t},\mathbf{b}\)</span>则定义了<span
class="math inline">\(\mathbf{n}\)</span>的切平面。对纹理空间中任意的<strong>法向量</strong><span
class="math inline">\(\mathbf{w}\)</span>，都可以左乘这个矩阵得到对应的世界空间中的法向量<span
class="math inline">\(\mathbf{n}&#39;=F^{-1}\mathbf{w}&#39;\)</span>。它定义的空间就称为<strong>切线空间</strong>，而矩阵<span
class="math inline">\(F^{-1}\)</span>就是所谓的TBN矩阵。</p>
<p>如果你还不理解，就这么思考。现在在纹理空间中有一个法向量<span
class="math inline">\(\mathbf{w}&#39;\)</span>，它的坐标是基于<span
class="math inline">\((1,0,0),(0,1,0),(0,0,1)\)</span>这三个标准正交基表示的。现在，需要把这个标准正交基“旋转”到世界空间中，让<span
class="math inline">\((0,0,1)\)</span>和原来的法向量<span
class="math inline">\(\mathbf{n}\)</span>对齐，再让另外两个轴旋转到某一个方向，这个方向能够反应三角形两条边的纹理变化方向。这样一来，<span
class="math inline">\(\mathcal{w}&#39;\)</span>就能表示在这个新的基上的线性组合，得到的就是真实世界中变换后的法向量<span
class="math inline">\(\mathbf{n}&#39;\)</span>。这个过程如下图所示（<span
class="math inline">\(n(S_q,t_q)\)</span>就是这里的<span
class="math inline">\(\mathbf{n}&#39;\)</span>，<span
class="math inline">\(z=n_q\)</span>就是这里的<span
class="math inline">\(\mathbf{n}\)</span>，<span
class="math inline">\(xyz\)</span>定义的空间就是<strong>切线空间</strong>，它位于真实空间内）：</p>
<p><img data-src="/images/bump-map/1-2.png" /></p>
<p>如果你认真思考，就会问出下面两个问题：</p>
<ol type="1">
<li>为什么需要正交化？不是我们直接出了<span
class="math inline">\(\mathbf{a},\mathbf{b},\mathbf{c}\)</span>了吗？为什么不能直接用它作为<span
class="math inline">\(F^{-1}\)</span>呢？</li>
<li>正交化之后的基<span
class="math inline">\(\mathbf{t},\mathbf{b},\mathbf{n}\)</span>和原始纹理空间的关系是如何的？能保证映射到真实空间中的法向量<span
class="math inline">\(\mathbf{n}&#39;\)</span>和原始法向量<span
class="math inline">\(\mathbf{n}\)</span>的相对位置关系正确吗？</li>
</ol>
<p>下面我们来依次回答这两个问题。</p>
<h3 id="为什么要正交化">为什么要正交化</h3>
<p>这个问题的答案很简单：<strong>因为计算改变后的法向量<span
class="math inline">\(\mathbf{w}&#39;\)</span>时是基于纹理空间进行的，而纹理空间一般来说（暂不考虑畸变的情况）就是由三个标准的正交基<span
class="math inline">\(UVW\)</span>组成的。</strong></p>
<p>举个例子，某点<span class="math inline">\(P\)</span>的法向量是<span
class="math inline">\(\mathbf{n}\)</span>，是个可以任意改变的向量，它在纹理空间中对应了点<span
class="math inline">\((u,v)\)</span>的一个向量<span
class="math inline">\((0,0,1)\)</span>，这个我们之前已经明确了。现在，假设我们计算出来的改变后的法向量<span
class="math inline">\(\mathbf{w}&#39;=(u&#39;,v&#39;,0)\)</span>正好在UV平面上，也就是与<span
class="math inline">\((0,0,1)\)</span>垂直，那么此时，如果我们直接用<span
class="math inline">\(\mathbf{a},\mathbf{b},\mathbf{c}\)</span>把<span
class="math inline">\(\mathbf{w}&#39;\)</span>映射回真实空间，我们会得到一个在三角形<span
class="math inline">\(ABC\)</span>所定义的平面上的一个法向量<span
class="math inline">\(\mathbf{n}&#39;=u&#39;\mathbf{a}+v&#39;\mathbf{b}\)</span>，这个法向量<strong>不一定</strong>和原来的法向量<span
class="math inline">\(\mathbf{n}\)</span>垂直，因为三角形<span
class="math inline">\(ABC\)</span>不一定和<span
class="math inline">\(\mathbf{n}\)</span>垂直。显然，<span
class="math inline">\(\mathbf{n}&#39;\)</span>与<span
class="math inline">\(\mathbf{n}\)</span>就没能保持在纹理空间中<span
class="math inline">\(\mathbf{w}\)</span>与<span
class="math inline">\(\mathbf{w}&#39;\)</span>一致的相对关系，即垂直关系。</p>
<p>所以，为了得到正确的相对关系，我们必须让求得的<span
class="math inline">\(\mathbf{a},\mathbf{b},\mathbf{c}\)</span>保持正交关系，正如在纹理空间中一样，这样才能让纹理空间中变换前后的法向量与真实空间中变换前后的法向量保持一致的相对关系。</p>
<p>那这样一来，<span
class="math inline">\(\mathbf{g}_1\)</span>不就不能映射回<span
class="math inline">\(\mathbf{e}_1\)</span>了吗？对的，但是我们实际上真正关心的是<strong>法向量</strong>而不是三角形的某个边，它只是用来帮助我们构造TBN矩阵的工具，所以映射不回去也没有关系了。</p>
<h3 id="法向量的方向">法向量的方向</h3>
<p>紧接着就会有另一个问题：正交基，也就是切线空间有了，但是你怎么保证向量<span
class="math inline">\(\mathbf{t},\mathbf{b}\)</span>的方向是正确的呢？或者说，经过变换后的真实空间的法向量<span
class="math inline">\(\mathbf{n}&#39;=F^{-1}\mathbf{w}&#39;\)</span>的<strong>反向</strong>是否是正确的。你可以想象变换后的法向量<span
class="math inline">\(\mathbf{n}&#39;\)</span>在绕着原来的法向量<span
class="math inline">\(\mathbf{n}\)</span>以相同的夹角旋转（它们的起点相同），从而可以形成一个锥形，那么到底哪个方向才是真正的<span
class="math inline">\(\mathbf{n}&#39;\)</span>呢？</p>
<p>答案是：<strong>在凹凸贴图中不能保证方向的正确性，但误差是可以接受的</strong>。回想一下，我们在求解<span
class="math inline">\(\mathbf{a},\mathbf{b},\mathbf{c}\)</span>时，让纹理空间中的<span
class="math inline">\((0,0,1)\)</span>对应到真实空间的法向量<span
class="math inline">\(\mathbf{n}\)</span>，这是没有问题的。然后把三角形的边和它在纹理空间中的纹理坐标向量进行对齐，进而求得<span
class="math inline">\(\mathbf{a},\mathbf{b}\)</span>。这里其实做了一个假设，三角形内部的点的纹理坐标是可以通过三角形三个顶点的纹理坐标进行<strong>线性插值</strong>得到的。当然严格来讲，这不一定成立，因为任何一个点的纹理坐标都是可以任意指定的，但是一般来说，我们在制作纹理贴图的时候，会把模型作为一个整体制作，这基本上也就是一个线性关系。</p>
<p>因为我们是把<span
class="math inline">\(\mathbf{g}_1\)</span>映射到<span
class="math inline">\(\mathbf{e}_1\)</span>、把<span
class="math inline">\(\mathbf{g}_2\)</span>映射到<span
class="math inline">\(\mathbf{e}_2\)</span>的，只要纹理贴图制作得比较规范，即便正交化了<span
class="math inline">\(\mathbf{a},\mathbf{b}\)</span>，经过TBN矩阵转换后的世界空间的法向量<span
class="math inline">\(\mathbf{w}&#39;\)</span>也不会偏离真实的法向量太远。这里可以顺便回答为什么在进行正交化的时候是<span
class="math inline">\(\mathbf{n}\times \mathbf{t}\)</span>而不是<span
class="math inline">\(\mathbf{t}\times
\mathbf{n}\)</span>，这是因为在纹理空间中，<span
class="math inline">\(\mathbf{n}\)</span>对应了<span
class="math inline">\(\mathbf{w}=(0,0,1)\)</span>，<span
class="math inline">\(\mathbf{t}\)</span>对应了<span
class="math inline">\(\mathbf{u}=(1,0,0)\)</span>，如果要得到<span
class="math inline">\(\mathbf{v}=(0,1,0)\)</span>，就只能是<span
class="math inline">\(\mathbf{w}\times\mathbf{u}\)</span>。这对应到真实空间中，就是<span
class="math inline">\(\mathbf{n}\times \mathbf{t}\)</span>。</p>
<p>值得一提的是，在<strong>法线贴图</strong>中是可以保证变换后的法线<span
class="math inline">\(\mathbf{n}&#39;\)</span>的方向是正确的，这个我们下面讲到法线贴图的时候稍加解释。</p>
<p>上面说了这么多，切线空间带来的最大好处是，它和真实空间是一种相对关系，这意味着我们不需要为模型在每个不同的位置都制作贴图，极大减少了工作的复杂度，也更加灵活。</p>
<h1 id="法线贴图normal-mapping">法线贴图（Normal Mapping）</h1>
<p>在了解了凹凸贴图之后，法线贴图就很自然了。在凹凸贴图中，纹理空间中变换后的法线<span
class="math inline">\(\mathbf{w}&#39;\)</span>是要手动去计算的，那为什么我们不直接把法线存储在这个点呢，就像一张RGB纹理图一样。</p>
<p>在RGB纹理图中，每个点的RGB值都在<span
class="math inline">\([0,1]\)</span>中，但是法线的每个元素都在<span
class="math inline">\([-1,1]\)</span>中。所以要用RGB的贴图存储法线，就要对法线先加一，再除以二，就能把值的范围规约到<span
class="math inline">\([0,1]\)</span>中。那么为什么我们看到一般的法线贴图都偏蓝色呢？这是因为法线的<span
class="math inline">\(z\)</span>值比较大，就对应到RGB的蓝色值偏大，所以使得整个图呈现偏蓝的颜色。</p>
<p>下图左侧是凹凸贴图，用灰度值表示每个点的高度；右侧是法线贴图，每个点都是一个RGB值。</p>
<p><img data-src="/images/bump-map/2-1.png" /></p>
<p>在从法线贴图中获取了变换后的法线之后，仍然需要像凹凸贴图一样，首先计算得到<span
class="math inline">\(\mathbf{a},\mathbf{b},\mathbf{c}\)</span>，然后再正交化得到TBN矩阵，最后左乘TBN矩阵就了得到世界空间中变换后的法线。</p>
<p>现在可以回答之前的一个问题：为什么使用法线贴图得到的变换后的法向量<span
class="math inline">\(\mathbf{n}&#39;\)</span>就能保证它和<span
class="math inline">\(\mathbf{n}\)</span>的相对关系是正确的？这是因为，<span
class="math inline">\(F^{-1}=\begin{bmatrix}\mathbf{t}&amp;\mathbf{b}&amp;\mathbf{n}\end{bmatrix}\)</span>是一个正交矩阵，它代表的是把纹理空间中的法向量转换到世界空间中的法向量；那么它的逆（也就是它的转置，因为是正交矩阵）<span
class="math inline">\(F\)</span>，就能够把世界空间中的法向量变换到纹理空间中的法向量。所以，给定一个模型（或者三角形），在制作它对应的法线贴图的时候，只要按照<span
class="math inline">\(F\mathbf{n}&#39;\)</span>的方式在纹理空间中存储法线（<span
class="math inline">\(\mathbf{n}&#39;\)</span>是艺术家制作决定的），就能通过逆变换<span
class="math inline">\(F^{-1}\)</span>还原真实空间的法线。也就是说，只要存储和调用都用这样的<strong>同一套变换矩阵</strong>，得到的法线就一定是正确的。</p>
<p>光线、观察方向等实际上也都是一种法向量，它自然也能被映射到纹理空间中，直接和<span
class="math inline">\(\mathbf{w}&#39;\)</span>进行计算，而不需要把所有点都经过TBN矩阵变换到世界空间中再做Shading，这样一来就降低了计算量。</p>
<h1 id="games-101-作业三中的bump-mapping">GAMES 101 作业三中的Bump
Mapping</h1>
<p>GAMES101的作业三也让我们实现了一个简单的Bump
Mapping，下面是代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">bump_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">sqrt</span>(n.<span class="built_in">x</span>() * n.<span class="built_in">x</span>() + n.<span class="built_in">z</span>() * n.<span class="built_in">z</span>());</span><br><span class="line">    <span class="function">Vector3f <span class="title">t</span> <span class="params">(-n.x() * n.y() / d, d, -n.z() * n.y() / d)</span></span>;</span><br><span class="line">    Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"></span><br><span class="line">    Matrix3f TBN;</span><br><span class="line">    TBN.<span class="built_in">col</span>(<span class="number">0</span>) = t, TBN.<span class="built_in">col</span>(<span class="number">1</span>) = b, TBN.<span class="built_in">col</span>(<span class="number">2</span>) = n;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>(), v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u + <span class="number">1.0f</span> / w, v).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line">    <span class="type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v + <span class="number">1.0f</span> / h).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">ln</span> <span class="params">(-dU, -dV, <span class="number">1</span>)</span></span>;</span><br><span class="line">    normal = TBN * ln;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = normal.<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了环境光、漫反射和镜面反射的系数，然后定义了光线和观察位置，之后求出了TBN矩阵与纹理空间中的法向量，最后转换到了世界空间中进行着色。</p>
<p>这里通过<code>dU</code>和<code>dV</code>得到的就是我们一开始讲的纹理空间中变换后的法向量<span
class="math inline">\((-c_1\Delta h(u),-c_2\Delta
h(v),1)^\top\)</span>，只不过这里是在乘了TBN矩阵之后再进行的归一化。</p>
<p>但是这里的TBN计算方式，和我们上面提到的完全不一样。<span
class="math inline">\(\mathbf{n}\)</span>倒是正确的，它直接用了当前的法向量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector3f n = normal.<span class="built_in">normalized</span>();</span><br></pre></td></tr></table></figure>
<p>但是计算<span
class="math inline">\(\mathbf{t}\)</span>就完全让人摸不着头脑了（<span
class="math inline">\(\mathbf{b}\)</span>可以通过叉乘实现）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> d = <span class="built_in">sqrt</span>(n.<span class="built_in">x</span>() * n.<span class="built_in">x</span>() + n.<span class="built_in">z</span>() * n.<span class="built_in">z</span>());</span><br><span class="line"><span class="function">Vector3f <span class="title">t</span> <span class="params">(-n.x() * n.y() / d, d, -n.z() * n.y() / d)</span></span>;</span><br></pre></td></tr></table></figure>
<p>翻译成数学公式就是：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{t} &amp;= \left(\frac{-xy}{\sqrt{x^2+z^2}}, \sqrt{x^2+z^2},
\frac{-zy}{\sqrt{x^2+z^2}}\right)^\top
\end{aligned}
\]</span></p>
<p>可以验证这是一个与<span
class="math inline">\(\mathbf{n}=(x,y,z)^\top\)</span>垂直的单位向量。</p>
<p>这两行代码是什么意思呢？其实，这里这里是对向量进行了旋转操作。如下图所示，先把<span
class="math inline">\(\mathbf{n}\)</span>拆成它在XZ平面和Y轴上的分量<span
class="math inline">\(\mathbf{n}_{xz}\)</span>和<span
class="math inline">\(\mathbf{n}_y\)</span>。现在我们的目标就是在由<span
class="math inline">\(\mathbf{n}_{xz}\)</span>和<span
class="math inline">\(\mathbf{n}_y\)</span>所定义的平面上的任意一个向量，都得到它在同一个平面上的垂直向量。对<span
class="math inline">\(\mathbf{n}_{xz}\)</span>来说，这个向量就是<span
class="math inline">\(\mathbf{n}_y\)</span>；对<span
class="math inline">\(\mathbf{n}\)</span>来说，这个向量就是<span
class="math inline">\(\mathbf{t}\)</span>。所以本质上我们是要求一个旋转矩阵，它可以得到该平面上与一个向量垂直的向量。</p>
<p><img data-src="/images/bump-map/2-2.png" /></p>
<p>这个变换很简单，就是先将它绕着Y轴旋转<span
class="math inline">\(\theta\)</span>°，这里的<span
class="math inline">\(\theta\)</span>是<span
class="math inline">\(\mathbf{n}_{xz}\)</span>与X轴形成的夹角，得到的向量会在平面XY上；然后绕着Z轴旋转90°；最后绕Y轴旋转<span
class="math inline">\(-\theta\)</span>°，得到的向量就是与给定向量在平面内垂直的向量。这三个连续操作可以写成三个矩阵的乘积：</p>
<p><span class="math display">\[
\begin{bmatrix}
  \cos(\theta) &amp; 0 &amp; -\sin(\theta)\\
  0 &amp; 1 &amp; 0\\
  \sin(\theta) &amp; 0 &amp; \cos(\theta)
\end{bmatrix}
\begin{bmatrix}
  0 &amp; -1 &amp; 0\\
  1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1\\
\end{bmatrix}
\begin{bmatrix}
  \cos(\theta) &amp; 0 &amp; \sin(\theta)\\
  0 &amp; 1 &amp; 0\\
  -\sin(\theta) &amp; 0 &amp; \cos(\theta)
\end{bmatrix}=
\begin{bmatrix}
  \sin^2(\theta) &amp; -\cos(\theta) &amp; -\sin(\theta)\cos(\theta)\\
  \cos(\theta) &amp; 0 &amp; \sin(\theta)\\
  -\sin(\theta)\cos(\theta) &amp; -\sin(\theta) &amp; \cos^2(\theta)
\end{bmatrix}
\]</span></p>
<p>再由<span
class="math inline">\(\cos(\theta)=\frac{x}{\sqrt{x^2+z^2}},\sin(\theta)=\frac{z}{\sqrt{x^2+z^2}}\)</span>，可知，变换矩阵为：</p>
<p><span class="math display">\[
\begin{bmatrix}
  \frac{z^2}{x^2+z^2} &amp; -\frac{x}{\sqrt{x^2+z^2}} &amp;
-\frac{xz}{x^2+z^2}\\
  \frac{x}{\sqrt{x^2+z^2}} &amp; 0 &amp; \frac{z}{\sqrt{x^2+z^2}}\\
  -\frac{xz}{x^2+z^2} &amp; -\frac{z}{\sqrt{x^2+z^2}} &amp;
\frac{x^2}{x^2+z^2}
\end{bmatrix}
\]</span></p>
<p>所以，<span
class="math inline">\((x,y,z)^\top\)</span>变换后的结果就是<span
class="math inline">\(\mathbf{t}=\left(\frac{-xy}{\sqrt{x^2+z^2}},
\sqrt{x^2+z^2}, \frac{-zy}{\sqrt{x^2+z^2}}\right)^\top\)</span>。</p>
<p>所以，从根本上讲，切线空间除了<span
class="math inline">\(\mathbf{n}\)</span>需要被作为Z轴是明确的之外，剩下的两个轴（实际上是一个轴，也就是所谓的Tangents，另一个轴可以通过叉积求得）都是可以手动定义的。只要在制作存储法线贴图和使用法线贴图时保持一致即可。</p>
<h1 id="位移贴图displacement-mapping">位移贴图（Displacement
Mapping）</h1>
<p>分析Bump mapping和Normal
mapping不难发现，它们实际上是通过改变法线制造一种假象，这时候物体本身没有丝毫变化。这种方法难以处理由凹凸表面带来的自阴影，并且物体的边界会露馅。</p>
<p>Displacement
mapping真的去改变每个点在空间的位置，从而得到更加真实的结果。</p>
<p>下面是GAMES101 作业三中关于displacement mapping的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">displacement_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">sqrt</span>(n.<span class="built_in">x</span>() * n.<span class="built_in">x</span>() + n.<span class="built_in">z</span>() * n.<span class="built_in">z</span>());</span><br><span class="line">    <span class="function">Vector3f <span class="title">t</span> <span class="params">(n.x() * n.y() / d, d, n.z() * n.y() / d)</span></span>;</span><br><span class="line">    Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"></span><br><span class="line">    Matrix3f TBN;</span><br><span class="line">    TBN.<span class="built_in">col</span>(<span class="number">0</span>) = t, TBN.<span class="built_in">col</span>(<span class="number">1</span>) = b, TBN.<span class="built_in">col</span>(<span class="number">2</span>) = n;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>(), v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u + <span class="number">1.0f</span> / w, v).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line">    <span class="type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v + <span class="number">1.0f</span> / h).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">ln</span> <span class="params">(-dU, -dV, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    point += (kn * normal * payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v).<span class="built_in">norm</span>()); <span class="comment">// Core code</span></span><br><span class="line">    normal = (TBN * ln).<span class="built_in">normalized</span>();</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the square distance r^2</span></span><br><span class="line">        <span class="type">float</span> square_distance = (light.position - point).<span class="built_in">squaredNorm</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the light direction, view direction, normal, and half vector</span></span><br><span class="line">        Vector3f l = (light.position - point).<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f v = (eye_pos - point).<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f h = (l + v).<span class="built_in">normalized</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// The light intensity</span></span><br><span class="line">        Vector3f I = light.intensity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the ambient light, diffuse light and specular light</span></span><br><span class="line">        Vector3f ambient_light = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line">        Vector3f diffuse_light = kd.<span class="built_in">cwiseProduct</span>(I / square_distance) * std::<span class="built_in">max</span>(<span class="number">0.0f</span>, n.<span class="built_in">dot</span>(l));</span><br><span class="line">        Vector3f specular_light = ks.<span class="built_in">cwiseProduct</span>(I / square_distance) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, n.<span class="built_in">dot</span>(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient_light + diffuse_light + specular_light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察代码，不难发现它最核心的代码就一行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">point += (kn * normal * payload.texture-&gt;<span class="built_in">getColorBilinear</span>(u, v).<span class="built_in">norm</span>());</span><br></pre></td></tr></table></figure>
<p>这一行代码的意思是点在空间中的位置实际地被改变了。这会影响下面光照距离、观察方向、光照方向的计算，从而改变着色结果。</p>
<h1 id="参考文献">参考文献</h1>
<p><a
href="https://blog.matrixs.site/post/2022-01-07-%E8%A8%88%E7%AE%97%E6%A9%9F%E5%9C%96%E5%BD%A2%E5%AD%B8-games101%E4%BD%9C%E6%A5%AD3%E8%A3%9C%E5%85%85/%E5%9C%96%E5%BD%A2%E5%AD%B8%E7%B3%BB%E5%88%97_games101-homework3-normalmaps_and_bumpmaps_and_displacementmaps.html">圖形學系列
Games101-Homework3-NormalMaps and BumpMaps and
DisplacementMaps</a><br />
<a href="https://zhuanlan.zhihu.com/p/139593847">切线空间（Tangent
Space）完全解析</a><br />
<a
href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/#_1">LearnOpenGL
CN法线贴图</a><br />
<a
href="https://www.cnblogs.com/tiancaiwrk/p/11132437.html">深入浅出之切空间</a></p>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>《电脑游戏：文本、叙事与游戏》纪要</title>
    <url>/2021/08/14/18/08/</url>
    <content><![CDATA[<p>本文是《电脑游戏：文本、叙事与游戏》的简单纪要，在此备份。</p>
<span id="more"></span>
<h1 id="游戏与叙事">游戏与叙事</h1>
<h2 id="叙事理论">叙事理论</h2>
<ul>
<li>每一个叙事都有两个部分：一个是故事，指事件的内容或串联（动作、发生的事），再加上所谓的存在物（角色、场景中的事物等）；二是话语，即内容赖以传达的方法。</li>
<li>故事的事件在时间和空间上都是按照一定的顺序排列的，这就是所谓的<strong>情节设计</strong>。</li>
<li>叙事事实的三个方面：故事（内容）、叙事（话语）、叙述。
<ul>
<li>童话《灰姑娘》中包含了一系列故事的事件，可以通过很多种不同的方式被呈现出来。</li>
<li>叙事的关键要素：<strong>对事件加以安排</strong>，使之在话语当中凸显出来，对它们的时间长度、发生频率和次序予以控制。</li>
</ul></li>
<li>隐含作者与隐含读者。</li>
</ul>
<h2 id="叙事理论与博德之门">叙事理论与《博德之门》</h2>
<ul>
<li>游戏包含了一系列由玩家所触发的新事件，允许玩家实时行动；也包含了过去的事件，已经被安排好的。</li>
<li>事件被提前预制好，玩家是做出情节安排的人。</li>
<li>同步叙事：向玩家传达屏幕上的行动、事件、得分和对话。</li>
</ul>
<h2 id="叙事的限度">叙事的限度</h2>
<ul>
<li>叙事理论追问的是：故事情节是从何种角度被描述的，我们是通过谁的眼睛了解叙事当中的事件的，又是谁的声音在传递信息，是谁在策动事件，谁来决定事件的持续时间、发生频率和次序。</li>
<li>《博德之门》以一种玩家无法操纵的形式讲述事件，以过场动画、NPC的对白和角色简介的方式被编织在一起，并与玩家发生联系。</li>
<li><strong>已然事件</strong>与<strong>实时事件</strong>。</li>
</ul>
<h1 id="游戏与快感">游戏与快感</h1>
<ul>
<li>电脑游戏究竟要驱使玩家去做什么。</li>
</ul>
<h2 id="角色的生成">角色的生成</h2>
<ul>
<li>选择外观、种族、职业、阵营、声音、名字。通过这些选择，让玩家了解游戏玩法与背景，同时限定了一系列数值。</li>
</ul>
<h2 id="角色特征和游戏">角色、特征和游戏</h2>
<ul>
<li>角色既包含了审美层面和故事层面的偏好，也涉及战略方面的考虑。人物的特征会影响（约束）其行为。</li>
<li>但是玩家的风格和喜好决定了角色内在的可能性以怎样的形式表达出来，或怎样被压抑。【如果想要增强角色自身的特征，应该限制玩家的可操作性，如从数值、剧情、环境、探索度等层面。】</li>
<li>在电脑游戏中，玩家的input和游戏所提供的特征描述之间的互动可能引发不可预测的行为，与某个角色表面的扁平性发生矛盾。因此，仅仅按照设定的属性和特征去描述一个游戏化身或角色是错误的。【可以通过“如果不这么做，游戏就难以进行下去”的思路引导玩家进行特定的操作。】</li>
</ul>
<h2 id="沉浸卷入与心流体验">沉浸、卷入与“心流”体验</h2>
<ul>
<li>玩家将游戏系统看做一个整体，但是在这一游戏系统中，玩家还必须关注一系列次级系统，那就是角色的行动、武器、物品和技能。</li>
<li>在文学研究中，<strong>沉浸感</strong>是指读者所享受到的放弃批判思考的全神贯注。认知心理学的<strong>图式理论</strong>使我们能够感知周遭的事物并进行有效的处理，这一能力有赖于此前通过阅读、个人经验和别人的建议而建立起来的对类似事件的已有知识储备。【也就是说，沉浸感实际上是一种<strong>记忆唤醒机制</strong>？】</li>
<li>只要故事、背景和界面保持统一的图式，玩家的审美体验就能在很大程度上保持沉浸感。</li>
<li><strong>卷入</strong>，是一种经过更多思考的批判式的参与方式。
<ul>
<li>当读者面临不熟悉的题材，或者文本很难左右其反应时，他们被驱使着一再重读或反复斟酌其中的信息。</li>
</ul></li>
<li>沉浸的快感来源于我们伴随某种熟悉图式的退潮和涌动而完全专注其中。卷入的快感则来自我们从<strong>文本之外的视点</strong>去识别一件作品如何将<strong>互相矛盾</strong>的图式翻转、连接。【“相互矛盾”可以是新的情节、新的人物、新的动作，总之与既有的图式产生了区别之处。】
<ul>
<li>当屏幕上的场景要求即时的、固定的反应时——比如思考、凝视、阅读、击打、探索、行走——就促使玩家进入沉浸状态。</li>
<li>当玩家不得不与屏幕上的行为逐渐拉开距离时，就进入卷入的状态。可能是由于角色的特性、一条迷失的小路、一个强大的敌人等。这时候就要寻求解决之道：重复行为——&gt;重新经历——&gt;查找攻略。</li>
<li>沉浸和卷入相互依赖，玩家在流动性和安逸心情之间切换，游戏世界由此塑造体验。【战神的战斗、探索、叙事是一种沉浸，而其中的解密、情节、道具、新的敌人又是卷入。<strong>不断创造卷入，然后将卷入转化为沉浸，再创造新的卷入。</strong>】</li>
</ul></li>
<li>随着游戏难度的提高，玩家的应对能力也在进步，游戏需要与玩家的水准相匹配。这时候玩家总说自己“处于巅峰状态”。【战神。】</li>
</ul>
<h1 id="空间导航与情绪反应">空间、导航与情绪反应</h1>
<h2 id="异域镇魂曲与寂静岭">《异域镇魂曲》与《寂静岭》</h2>
<ul>
<li>《寂静岭》的音效使之恐怖感上升。</li>
<li>《寂静岭》的<strong>线性结构能让游戏始终保持一定的节奏和紧张感</strong>。</li>
</ul>
<h2 id="导航迷阵根茎与迷宫">导航：迷阵、根茎与迷宫</h2>
<ul>
<li>空间导航有两种模式：迷阵与根茎。
<ul>
<li>迷阵意味着在向唯一的出口有条件地前进，缺点是玩家只能被引导到预先设定的唯一出口。</li>
<li>根茎并没有特定的方向比其他方向更有利，缺点是结构的缺失。</li>
<li>游戏当中的迷宫应当处于二者之间：要实现的目标应足够强大，引导玩家前进；同时设定开放式结局，令玩家可自由探索。【巫师三和BOTW的一大共性（实际上Sekiro也是）：<strong>主线分支化</strong>，鼓励玩家自主选择、探索。核心要点是：<strong>自由地引导</strong>。】</li>
</ul></li>
<li>恐怖效果地生成总是基于“一个简单而明显地基本公式：<strong>怪物使常态遭到威胁</strong>。”
<ul>
<li>《寂静岭》中，常态被怪异之物威胁并摧毁。</li>
<li>《异域镇魂曲》中，怪物本身就是常态。</li>
</ul></li>
</ul>
<h2 id="游戏文本与遍历函数">游戏文本与遍历函数</h2>
<ul>
<li>呈现于受众面前的称为“脚本单元”：是不同玩家将游戏中的信息“玩出来”的。</li>
<li>存在于文本之中的称为“文本单元”：是游戏提供的所有潜在信息。</li>
<li>使脚本单元自文本单元中显露或生成并呈现于玩家面前的机制，叫做“<strong>遍历函数</strong>”。</li>
<li>遍历函数的几种变体：活跃性、可确定性、可访性、连接性。
<ul>
<li>活跃性（与文本单元和脚本单元的数量与稳定性有关）：《异域镇魂曲》比《寂静岭》更加活跃少停滞，因为前者任务更多，且一部分是强制性的，而且文本单元更丰富，玩家选择和组建的脚本单元的可能性也都更多。</li>
<li>可确定性（给定状况相同反应是否总是导致相同的结果）：《异域镇魂曲》比《寂静岭》更加不确定。</li>
<li>可访性（玩家是否能在游戏中任意一点进入游戏文本）：《异域镇魂曲》比《寂静岭》可访性更强。</li>
<li>连接性（文本单元间时空的连接）：《异域镇魂曲》比《寂静岭》连接性更强。</li>
</ul></li>
<li>《寂静岭》更加稳定、有节制、更具确定性的特点塑造了它迷阵般的结构。《异域镇魂曲》较富于开放性的遍历模式则表现出如根茎般的扩张趋势。</li>
</ul>
<h3 id="替身">替身</h3>
<ul>
<li>沉浸分为感知层面的沉浸和心理层面的沉浸。
<ul>
<li>感知层面：游戏体验垄断了玩家的感觉，如听觉、视觉。</li>
<li>心理层面：玩家全神贯注地投入到想象中的游戏世界去。</li>
</ul></li>
<li>《异域镇魂曲》的等距视角和游戏主角本质上的复合性在感知和行为两方面都大大消解了玩家与化身的同一感（削弱了感知层面的沉浸）。但游戏以另一种方式令玩家沉浸其中：大量描述性文本的阅读，以及关于玩家对游戏主角、其作战团队及其物品的巧妙运用的细节信息的缓慢积累。【古剑三】</li>
<li>《寂静岭》是感知层面的沉浸，各种即时状态。</li>
<li>《异域镇魂曲》拒绝被匆忙对待，而《寂静岭》催促着玩家从一个地方到另一个地方，抵达终点。</li>
</ul>
<p>（更多细节，侧重代入感，带来感知沉浸）小&lt;---------视距---------&gt;大（更多信息，侧重策略性）</p>
<h1 id="角色扮演">角色扮演</h1>
<h2 id="社会符号学视角">社会符号学视角</h2>
<ul>
<li>图像语法：再现性（再现这个世界）、互动性（允许文本的作者和读者之间的沟通，以及文本中虚构人物与读者之间的沟通）、组织性（使文本各要素连贯一致，由此组合起来以进一步实现它们承载的含义）。</li>
<li>多模态理论：文本如何将不同的符号模态——如讲话、书写、声音和图像——组合在一起，游戏是多模态的文本，因此应该思考，动画、视觉设计、音乐、文字文本和声效等多种沟通模态的联合是如何实现前述三个主要功能。</li>
</ul>
<h2 id="克劳德大英雄">克劳德——大英雄</h2>
<ul>
<li>克劳德这样的角色在相当大的程度上利用了民间文化、口头叙事和罗曼司等传统形式，通过精心构建的寓言故事，为日常生活中的过渡仪式和苦难提供了情感慰藉、道德争论和心灵拷问。</li>
<li>电脑游戏是被翁称为高科技社会“次级口述”的案例之一，它是口述文化这种思维模式的进化，基础是文学和以技术为媒介的文化。</li>
</ul>
<h2 id="克劳德数码傀儡">克劳德——数码傀儡？</h2>
<ul>
<li>将克劳德这样的文本建构视为一种固定的对象却可能导致我们忽视玩家—化身这一重联系，甚至是忽略普遍意义上的文本的含义。</li>
<li>玩家同时也是一种文化资源，是阐释者，也是粉丝艺术和粉丝写作当中对游戏资源进行改编的人。</li>
</ul>
<h2 id="化身的操纵">化身的操纵</h2>
<ul>
<li>玩家既是化身，又不是化身，这是游戏体验的核心。</li>
<li>文化研究强调能动性（agency）这一概念，这是读者主动阅读时所具备的积极素质，因此我们可以认为对化身行动的操纵程度可以等同于更为广泛意义上的掌握文化权力的程度。
<ul>
<li>我们是自主有力的社会行为者：可以选择为玩家可以参与文本的程度达到前所未有的地步而欢呼。</li>
<li>我们仅仅是他者的再现：玩家只能接受并操纵由公司设定的游戏文本决定提供给他们的角色。</li>
</ul></li>
<li>随着游戏在不同时刻在给予性结构或需求性结构上的转变，玩家的参与方式也将发生变化。战斗可能是最为偏向需求性结构的情况，此时游戏系统似乎称为游戏的全部。</li>
</ul>
<h2 id="多模态的给予与需求">多模态的给予与需求</h2>
<ul>
<li>文本产生的需求由文本当中的不同模态通过相互组合以不同方式实现。
<ul>
<li>如音乐节奏的变化暗示着游戏文本变化。</li>
<li>如图像的变换预示着危险的迫近。</li>
<li>此时玩家具有双重身份：一方面，玩家与化身融为一体，二者皆为行动者；另一方面，玩家又像是一个操纵木偶的人，拉着化身的线，甚至是某种类型的作者，作为建立在规则之上的因果结构的一部分，以一种受限语言进行书写。</li>
</ul></li>
<li>镜头元素同样有助于文本互动。
<ul>
<li>置于较低处，好像和角色并肩作战，去除了需求性结构所产生的木偶操纵般的感觉。如果我们被赋予了操纵能力，同时视角又较高，则操纵的感觉会相当强烈。在需求性结构处于最紧张的时刻，将镜头拉低和拉近能够使玩家不失时机地与角色接近。【战神4】</li>
<li>镜头通常置于角色上方固定的位置，以提供操纵感，让玩家像对待、培养宠物一样对待化身，提供了给予性结构，并提供一定的稳定性。</li>
</ul></li>
<li>对游戏世界的探索感得自一种更弱的需求形式——诱导而非命令。【只能在有强烈需求的时候才能给予玩家强烈的暗示，或命令；而在一般情况下，需求更多给予微弱的引导。这一方面战神做得很好。】</li>
<li>【游戏需要不断地、交叉地提供需求性结构和给予性结构。】</li>
</ul>
<h1 id="文本再创作网络上的粉丝文化">文本再创作：网络上的粉丝文化</h1>
<ul>
<li>在游戏的需求性结构（搅动因果链条，推动你跨越失事列车或迷宫实验室的解密关卡，使你陷入紧张情绪之中，让你迷路和让你在面临众多敌人的时候产生焦虑感）和给予性结构（安排前后语境、风景、背景故事、动机和心理，将读者-受众拉入文本的移情网络和想象性延展空间中，和传统叙事中的运作方式一样）之间存在一种辩证关系，正是二者的结合提供了快感，而在以游戏为核心的粉丝创作中，二者将以相当不同的方式结合在一起。</li>
<li>粉丝是如何使用游戏系统的？游戏攻略、创意性写作、漫画。</li>
</ul>
<h2 id="游戏攻略作者">游戏攻略作者</h2>
<ul>
<li>这是一种探索游戏系统本身的快感。</li>
<li>他们用祈使句（第二人称）控制彼此的游戏行为——这是游戏攻略的特征。</li>
</ul>
<h2 id="虚构文学写作者">虚构文学写作者</h2>
<ul>
<li>过场动画属于给予性结构——它们只作叙事性陈述，并无互动性。过场动画可能表现出作为核心的游戏和外层叙事之间的分离。</li>
</ul>
<h2 id="诗人">诗人</h2>
<ul>
<li>直接阐释了游戏主角的情感，这是游戏文本无法做到的。【现代游戏在有面捕和动捕之后是可以实现的。】</li>
</ul>
<h2 id="三无漫画家">“三无”漫画家</h2>
<h2 id="结论">结论</h2>
<ul>
<li>在围绕《FF7》的粉丝创作当中，再现系统和游戏系统是彼此分离的。</li>
<li>以再现系统复制对玩家与化身的第一人称认同是可能的，但更为常见的还是借助游戏再现系统所提供的可能性，生产出第三人称的视角、叙事和形象创造，并为了自己获得快乐而对其进行挑选、放大或转换。【采用第一人称就限制了创作空间，而第三人称视角提供了无限大的创作空间，不仅仅限于游戏文本所提供的现有信息。】</li>
</ul>
<h1 id="动机与网络游戏">动机与网络游戏</h1>
<h2 id="再现动机欢迎来到鲁比卡世界">再现动机：欢迎来到鲁比卡世界</h2>
<ul>
<li>《混乱在线》以科幻小说为基础进行设定，在游戏网站上，鲁比卡世界的故事片段以各种形式呈现。</li>
<li>我们借以创建化身的个人标准，远比我们最初所能意识到的更能暴露自身经历及偏好。</li>
</ul>
<h2 id="娱乐动机游戏目标与策略">娱乐动机：游戏、目标与策略</h2>
<ul>
<li>娱乐动机相关的要素：战略、目标、即时事件、机遇、规则、技能、探险、升级、数值。</li>
<li>娱乐动机更强调玩家所操纵的游戏中的那个化身作为游戏的一个元素存在，是一个具有战略价值的符号单元，而非一个角色。</li>
</ul>
<h2 id="公共动机共享鲁比卡世界">公共动机：共享鲁比卡世界</h2>
<ul>
<li>公共动机包括一个游戏和其他游戏之间的关系、玩家由游戏之外带入游戏的期待，以及游戏本身的共享属性。</li>
</ul>
<h2 id="结论-1">结论</h2>
<ul>
<li>游戏动机的三种类型：再现动机（戏剧性的、表演性的、修饰性的、图像化的、叙事的）、娱乐动机（指向游戏层面的：数值、升级等）和公共动机（共有的期待、广泛的网络文化、游戏所分享的外部世界）。</li>
</ul>
<h1 id="社交性的游戏与学习">社交性的游戏与学习</h1>
<h2 id="探究游戏的社交性">探究游戏的社交性</h2>
<ul>
<li>游戏较之更为传统的、只能独自体验的媒介，比如书籍，可能是更适合儿童的娱乐形式。</li>
<li>游戏文化可以被认为视为这样的一个竞技场：它创建了等级制度，并且欺凌群体当中的弱者。</li>
</ul>
<h2 id="观察玩家">观察玩家</h2>
<ul>
<li>游戏过程当中与其他玩家之间的互动似乎已经成为游戏乐趣的一个重要部分。</li>
</ul>
<h2 id="游戏">游戏</h2>
<ul>
<li>《凯恩的遗产：噬魂者》。</li>
</ul>
<h2 id="玩游戏">玩游戏</h2>
<ul>
<li>玩家与游戏机之间的联系可以在同伴的指导和建议下构成，这产生了一种有效的“中介性合作”。</li>
<li>无论小组中的不同成员扮演什么角色，我们从男孩们的游戏失败的同步反应中，可以进一步证实合作游戏的集体性本质是显而易见的。</li>
</ul>
<h2 id="叙事与游戏">叙事与游戏</h2>
<ul>
<li>如何处理游戏角色的死亡对动作冒险游戏而言十分重要。《噬魂者》的处理方式是：死亡不会导致重新开始，而是进入阴间，这使得玩家在相似环境下继续游戏，且包括了许多之前不存在的道路。</li>
<li>“管控调整”语言明显见于游戏和玩家之间以及玩家和玩家之间所交换的各种问题和命令中，“高手”完全关注于游戏系统以及对操作的指导。</li>
<li>电脑游戏的试听魅力明显降低了在游戏过程中当面讨论的需要，如果故事已经展现在你眼前，描述故事甚至事无巨细地加以讨论就显得多余。</li>
<li>“玩后叙事”可以更多地展示出游戏地叙事魅力。</li>
</ul>
<h2 id="结论-2">结论</h2>
<ul>
<li>作为一种指导性活动，合作性游戏比明确地尝试指导更为有效。</li>
<li>电脑游戏嵌入了“社交外壳”，单人游戏可以转变为包含有效指导与沟通的社交活动。游戏都是那种可以形成社群和身份认同感的学习形式的绝佳例证。</li>
<li>互动不仅指玩家和游戏之间的关系，也应包括很多玩游戏这一活动所固有的社会语境和社交关系。</li>
</ul>
<h1 id="游戏内外的能动性">游戏内外的能动性</h1>
<ul>
<li>“互动性”一次常用以解释电脑游戏的魅力。三种类型的交流模式：声明式交流、反应式交流和互动式交流。从这个角度来看动作冒险游戏，它更像式“反应式交流”而非“互动式交流”。</li>
</ul>
<h2 id="进入奇异世界">进入奇异世界</h2>
<ul>
<li>“奇异世界”的创造者和设计者表示，他想将生态困境注入作为整体的游戏，让玩家可以与之互动，并最终战胜困境。</li>
</ul>
<h2 id="对玩家能动性的研究">对玩家能动性的研究</h2>
<ul>
<li>论坛的集体性质还表现在以下事实中：论坛成员对论坛环境负有管理职责，他们鼓励参与者以相互支持而非破坏性的方式参与讨论。</li>
</ul>
<h2 id="个人能动性">个人能动性</h2>
<ul>
<li>玩家可以以多种方式参与游戏，尽管游戏具有强烈的叙事目标，但它仍可以被从视觉、情感和主题等多个层次加以解读。</li>
</ul>
<h2 id="代理能动性">代理能动性</h2>
<ul>
<li>代理能动性：人们努力以某种手段争取那些拥有资源或技能的人按照他们的意图行动，，以协助他们获得期望的结果。
<ul>
<li>游戏攻略。</li>
<li>论坛讨论。</li>
</ul></li>
</ul>
<h2 id="集体能动性粉丝作品">集体能动性：粉丝作品</h2>
<ul>
<li>文本在粉丝中被认为式一个可以被集体改变、改编和重写的过程，一个未竟的事业，而非静态对象。</li>
<li>在粉丝艺术家的创作过程中，我们能够看到所有的能动性形式。在某种层次上，帖子表现出个人发挥其能动性和培养个人能力时所带有的焦虑、压力和挑战。粉丝们在对彼此的反馈、建议和专业技能表示支持和学习的过程中，利用了代理能动性。</li>
</ul>
<h2 id="结论-3">结论</h2>
<ul>
<li>游戏在某种程度上要求甚至依赖玩家能动性的积极发挥。对玩家能动性的关注将引导我们重新评估对以下问题的常规臆断：游戏是什么？谁在生产它？怎样生产？</li>
</ul>
<h1 id="电影改编与电脑游戏">电影、改编与电脑游戏</h1>
<h2 id="恐怖类型从电影到游戏">恐怖类型——从电影到游戏</h2>
<ul>
<li>恐怖类型携带者“所有口头叙事的印记：主题和母题的自由转换、原型人物和背景设置，以及不断累积的续集、翻拍和模仿。某种意义上，在这个领域当中，没有原创，没有真实的或正确的文本，而只有变体。”</li>
</ul>
<h2 id="改编与突变怪物">改编与《突变怪物》</h2>
<ul>
<li>不可预知的威胁乃至有时无法辨识的敌人及其带来的焦虑，正是为玩家提供的挑战，玩过经过训练即可将之战胜。在从电影到游戏的移植中，其功能和意义均发生了改变。</li>
<li><strong>游戏设计中最为重要的，是对空间和空间当中物品的设置与安排。</strong></li>
<li>为已经开发出来的游戏增加一个额外关卡是一回事，而尝试去想象一个尚不存在的游戏的某个关卡是另一回事，后者要困难得多。</li>
</ul>
<h2 id="人物塑造与过场动画">人物塑造与过场动画</h2>
<ul>
<li>一款好的游戏需要为玩家提供有意义的选择，以及相应可觉察的成果。《突变怪物》的叙事性元素给游戏的目标、任务和障碍提供了背景。</li>
<li>恐怖游戏的操作应当足够简单，因为这会在相当程度上将玩家限制在其所处的环境中，增加游戏的悬念。</li>
<li>过场动画分为两种：预制的和实时的。必须对带有预制过场动画的游戏进行周密计划，以避免其对游戏世界的真实感造成破坏。</li>
</ul>
<h2 id="改编从游戏到游戏">改编——从游戏到游戏</h2>
<ul>
<li>目标是开发一个具有足够普适性的游戏引擎。</li>
</ul>
<h1 id="游戏与性别">游戏与性别</h1>
<h2 id="作为再现的游戏">作为再现的游戏</h2>
<ul>
<li>有研究者认为，女性对电脑游戏的疏离主要是因为其再现性因素——游戏中女性化身的外形。</li>
<li>在很多游戏中，被特别标志的或被边缘化以至于缺席的性别，都是女性。</li>
<li>如果将电脑游戏视为一种文本，那么将玩家定义为一种性别主体并不可行。</li>
</ul>
<h2 id="娱乐性与再现性">娱乐性与再现性</h2>
<ul>
<li>一些游戏强调视觉呈现和故事讲述方式——它们在引人入胜的细节中呈现游戏的场景和角色，我们将之称为游戏的再现层面。</li>
</ul>
<h2 id="性别游戏与语境">性别、游戏与语境</h2>
<ul>
<li>游戏开发商或其发行商如果要争取更多的女性玩家，就要面临失去现有男性玩家的危险。</li>
<li>那种认为女性对电脑游戏不感兴趣的想法和剥夺女性玩游戏权利的做法已经过时了，尽管某些社会因素和文化因素还将因用户的性别而持续对其产生影响。</li>
</ul>
<h1 id="游戏分析的实践">游戏分析的实践</h1>
<h2 id="定义游戏">定义游戏</h2>
<ul>
<li>目标、障碍、资源、奖赏和惩罚等是电脑游戏的一些重要元素，同时还有一些可获得的不同种类的信息——不管是对于所有玩家，还是对于个别玩家，抑或对于游戏本身——以及这些信息逐渐显露的诸多方式。</li>
<li>我们也关注到其他有助于探索游戏要素多样性的理论研究方法，
<ul>
<li>例如，可以探究游戏当中的<strong>奖赏与惩罚</strong>（游戏的“经济体系”）或游戏当中玩家可控因素与不可控因素之间的制衡关系。</li>
<li>同样，也可以探索游戏中不同类型的<strong>障碍物</strong>。</li>
<li>还可以分析不同类型的<strong>游戏规则</strong>。</li>
<li>它们为我们发现一款游戏的与众不同之处，并促使我们继续思考这种差异是有意义的创新还是对规范的偏离。</li>
</ul></li>
<li>所有的定义都聚焦于被我们所称的游戏的<strong>娱乐层面</strong>或“<strong>游戏系统</strong>”，是它们决定一款游戏是不是可玩，以及游戏活动所遵循的限制。【游戏系统决定了游戏的定义。】</li>
<li>对电脑游戏的分析既要关注“娱乐性”，也要关注“再现性”，以及二者之间的关系。</li>
</ul>
<h2 id="游戏类型">游戏类型</h2>
<ul>
<li>在一个典型的动作冒险游戏中，我们通过扮演游戏内设定的化身来进行游戏，该化身通常会依循特定的游戏顺序克服已被设定的的重重困难。游戏目标通常相当明确，其经济体系一般与可量化的特征相关，比如生命值和弹药。游戏玩法中最核心的是速度和精确性。玩家会在游戏过程中学习一些技巧，但化身却不会成长。【游戏路线是既定的，游戏目标是明确的，游戏玩法是速度和精确度。】</li>
<li>与之相反，RPG游戏的主角可能是玩家通过一系列选择构建出来的，而且围绕该角色通常会有一个具有特定技能的辅助性团队。玩家可以自由地在游戏中探险，展开各种探索，并且可以不用遵照预设地步骤战胜游戏中的各种障碍。虽然游戏最终目标可能非常明确，但通常会有一些与最终目标未必相关的支线目标。以经验值和物品清单呈现出来的经济体系十分重要，但它更倾向于随玩家的表现而浮动。玩游戏的关键在于策略而非速度，而游戏体验往往具有更多反思性。【游戏路线是未定的，游戏目标是多样的，游戏玩法核心是策略。】</li>
<li>这两者之间的关键性差异与游戏系统有关，而非在再现层面。</li>
</ul>
<h2 id="叙事与游戏-1">叙事与游戏</h2>
<ul>
<li>沉浸分为<strong>感知</strong>上的沉浸与<strong>心理</strong>上的沉浸，卷入则是玩家被迫在游戏中采用一种更为审慎和具有反思性的态度。</li>
<li>沉浸和卷入并不互相排斥，二者间的摆动在游戏“心流”体验的产生中处于核心地位。所谓心流体验，就是玩家感到自己此刻“<strong>处在巅峰状态</strong>”，这种及其满足和欲罢不能的感觉部分由玩家在沉浸和卷入之间的转换所触发。</li>
</ul>
<h2 id="穿越游戏空间">穿越游戏空间</h2>
<ul>
<li>等距视角的RPG游戏更多依赖<strong>心理</strong>上的沉浸，而《寂静岭》中的移动视角和3D效果唤起玩家<strong>感知</strong>沉浸。</li>
</ul>
<h2 id="游戏动力学">游戏动力学</h2>
<ul>
<li>为什么游戏攻略大多采用第二人称祈使语气？因为游戏攻略大都紧密围绕游戏系统撰写，几乎不会注意<strong>再现层面</strong>，攻略是冷静的和技术性的。粉丝撰写的小说和诗歌都着墨于游戏的再现层面，倾向于借鉴游戏的过场动画，而非游戏本身的互动性元素。</li>
</ul>
<h2 id="走向线上">走向线上</h2>
<ul>
<li>玩家玩在线游戏的动机与游戏的娱乐层面和再现层面都有关系。
<ul>
<li><strong>再现层面</strong>的动机包括操纵视觉形象、创建角色和生成叙事。玩家构建化身的方式将折射出其现实生活的某些方面，或其内在愿望和幻想，而参与游戏的模式反映出不同的社会动机。</li>
<li><strong>娱乐层面</strong>的动机则更多和游戏活动本身直接相关，涉及竞争、规则和游戏目标。</li>
<li>此外还有<strong>公共动机</strong>，即玩家之间的互动，这是一种多模态呈现的现象。</li>
</ul></li>
</ul>
<h2 id="游戏中的社会生活">游戏中的社会生活</h2>
<ul>
<li>在团队协作中，游戏的<strong>娱乐层面</strong>是主要的。</li>
<li>游戏具有三个能动性：个人能动性、代理能动性、集体能动性。</li>
</ul>
<h2 id="生产游戏生产意义">生产游戏、生产意义</h2>
<ul>
<li>游戏设计者最为关心的问题，正是游戏的娱乐性和再现性之间的相关性和互联性。比如，角色具有再现性和娱乐性，过场动画也有娱乐性从（提供了战略上必不可少的信息）。</li>
</ul>
]]></content>
      <categories>
        <category>游戏 - 游戏理论</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>巫师三：一个告诉你原来游戏可以是艺术品的神作</title>
    <url>/2020/10/09/19/34/</url>
    <content><![CDATA[<p>巫师三是一款已经被时间证明的，当之无愧的神作。巫师三没有波澜壮阔气势浩天的景致，却有风格迥异人文色彩浓厚的地区特色。威伦的破败荒凉贫穷凄苦，为了一双鞋可以连父母都能出卖；诺威格瑞的大城风范，有日进斗金的土豪乡绅，也有困守城中的穷困百姓，女巫猎人穿梭其中，种族矛盾暗流涌动；史凯利杰群岛的剽悍民风，对外来者的敌视，对入侵者的抵御，捍卫土地的决心让诸多岛屿团结在一起；凯尔莫罕的静谧安详，森林环抱狼堡，猎魔人镇守故乡，仿佛出世的仙境，危机四伏但又简单质朴；陶森特的梦幻美丽，人们自得其乐，生活在这宛若仙境的城都中。不仅仅是景色，巫师三更是以它的剧情和对人物的刻画出名，抛开难以入流的战斗系统，单凭巫师三对剧情的把控、对人物的描写和对画面的雕琢，就足以令这部游戏称为艺术品。在经历了完整的主线和DLC流程后，几乎没有玩家会给巫师三一个低分，尽管它有瑕疵，但是它在剧情、人物和画面上已经到达巅峰造极的水平了，更难能可贵的是，这三者完美融合，在体验游戏的同时，给予玩家美的享受、身心的震撼。这是奥德赛无法比拟的，也是大多数游戏难以企及的高度。</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>由于巫师三的世界观过于宏大，一篇未经雕琢的读后感不能道尽巫师三的所有优点，故本文旨在从宏观上呈现巫师三是如何完美统一任务、节奏与剧情这三者的。至于其他的，我们有机会留在以后再说。我相信，通关巫师三的玩家，一定会承认巫师三在任务的组织和剧情的展开上非常连贯丝滑，而且剧情上的节奏递进、叙述上的跌宕起伏都让人回味无穷。游戏本质是在讲故事，但是巫师三成功地给予了玩家沉浸式的体验，也就是，我们从观众的角色深入到了主角的角色，从游戏外的世界走进了游戏内的世界，仿佛每个人都是真实可及的，都是有血有肉的，都是有情有义的。那么，如何讲好这个故事，把观众代入到游戏中，就是巫师三不同于其他游戏的关键所在，这也是这篇玩后感的主要内容。</p>
<figure>
<img data-src="/images/witcher-impression/4.jpg"
alt="被附身的Geralt帅中泄露出一丝痞气" />
<figcaption
aria-hidden="true">被附身的Geralt帅中泄露出一丝痞气</figcaption>
</figure>
<h1 id="主线为林支线为溪">主线为林，支线为溪</h1>
<p>巫师三的一大特色就是它的任务系统非常丰富，从表层看，巫师三的主线只有一个——寻找女儿，但是，在每个地区，都会有非常多的支线为主线提供背景。就好比一个建筑，主线是骨架，支撑起整个游戏的大致轮廓，而支线是钢筋水泥，垒起了整个建筑的最终格局。当然玩家可以只做主线不做支线，但我相信如果不做支线，这个游戏的乐趣就会少一半。</p>
<figure>
<img data-src="/images/witcher-impression/5.jpg" alt="父女之间的亲昵" />
<figcaption aria-hidden="true">父女之间的亲昵</figcaption>
</figure>
<p>说到支线繁多，一个典型的对比就是刺客信条奥德赛。同样有非常多的支线，但是从我个人的游玩体验来说，我宁愿无视奥德赛的90%的支线，直接一条路走完主线，但是巫师三的支线不然，玩家会有强烈的意愿去做大部分支线，在做支线的过程中解锁问号，发掘游戏中隐藏的剧情，是巫师三最为亮眼的一大特色。如果要对比巫师三和奥德赛的任务系统，可以从下面几个方面评价：</p>
<ul>
<li>支线多样化：巫师三的支线是多样的，支线之间没有重复，猎魔人委托可能会更无聊一点，但生意人的事情嘛，不寒碜。除了猎魔人委托之外，寻宝任务有解密探险要素，区域日常支线有搞笑奇葩要素，重要支线甚至会改变整个巫师三世界格局。然而，奥德赛的支线是单调的，支线的选择不会影响主线的进程，支线品类非常单一，并且缺乏逻辑。巫师三支线给玩家的动力是充分的：委托赚钱，寻宝得装备，日常支线放松一下，重要支线扣人心弦；而奥德赛不是的，除了几个从头到尾都有的支线之外（类似于巫师三的寻宝任务），其他的支线毫无意义，既对主线没有补益，而且也缺乏特色。</li>
<li>支线重要化：当然，支线多样丰富是一方面，更重要的是，支线是需要起到作用的，有时候甚至是决定性的作用。巫师三的主线和支线的分工相当明确：主线用来推进整个游戏进程，而支线则负责主线缺失的娱乐性与严肃性。这大大补充了单主线的贫乏，让玩家在游戏的时候不会觉得推进主线是无聊的，因为在同时还有大量丰富有趣的支线在支撑游戏的饱满度。而且，巫师三的支线并不是其他游戏中如过往云烟般的支线，而是不同的支线会在主线的不同时间点产生决定性的影响。比如，迪胖的支线会决定整个游戏最终的政治格局，这是从大了讲。从小了讲，如果细心留意，就会发现很多很多支线都涉及到游戏中不同人物的命运，即使是路人，我们也能够感到他们是真实的，而不仅仅是一堆数据。这些都是支线带来的重要积极影响。巫师三赋予了支线游戏的精神内核，并令其成为承载游戏厚度的“实力担当”。</li>
</ul>
<figure>
<img data-src="/images/witcher-impression/13.png"
alt="这样有趣的小支线在巫师三里不胜枚举" />
<figcaption
aria-hidden="true">这样有趣的小支线在巫师三里不胜枚举</figcaption>
</figure>
<ul>
<li>支线惊奇化。巫师三的支线时常给人一种惊奇的感觉，无论是之前无意之中做的支线会在后来的某一天发现原来会产生这样的影响，还是后来做到的支线会发现是之前剧情的关键结果，这种突如其来的“因果”呈现都带给玩家游戏体验上的冲击。重点是，正所谓大音希声，这样的惊奇化支线完全不需要漫长的铺垫，而只需要一个小小的“接口”，把因果串联起来就可以达到这样震撼的效果。一个典型的例子就是在DLC石之心里，拍卖行里的一个小支线展现了维瑟米尔的不为人知的一面，不但极大丰富了人物形象，而且还带给玩家无尽的唏嘘。此类四两拨千斤的支线在巫师三里比比皆是，</li>
</ul>
<figure>
<img data-src="/images/witcher-impression/2.jpg"
alt="一个非常小的细节，但是却折射出了两个饱满的人物形象" />
<figcaption
aria-hidden="true">一个非常小的细节，但是却折射出了两个饱满的人物形象</figcaption>
</figure>
<figure>
<img data-src="/images/witcher-impression/3.jpg"
alt="一个非常小的细节，但是却折射出了两个饱满的人物形象" />
<figcaption
aria-hidden="true">一个非常小的细节，但是却折射出了两个饱满的人物形象</figcaption>
</figure>
<p>所以，巫师三成功的一大关键因素就在于他巧思的任务系统，尤以支线为代表，主线与支线的交织，主线推动整个剧情的发展。支线却承载了多样化、重要化和惊奇化的具体内容，让人家流连忘返，深陷其中。</p>
<h1 id="选择困境人生模拟">选择困境，人生模拟</h1>
<p>当然，除了巫师三之外，还有很多游戏的支线也很丰富，主线支线的组织也很巧妙，那凭什么巫师三这么牛逼呢？这就是巫师三的第二个牛逼之处：通过合逻辑的选择带给你极尽真实的人生体验。</p>
<p>巫师三的任务绝大多数都是需要玩家做出选择的，无论主线还是支线，这在从威伦到诺威格瑞之后尤为突出。不同于很多游戏可有可无的“可选项”，巫师三的每一个选项都是经过反复斟酌的，不存在无意义的选项。威伦雷索的选择直接决定了他之后会不会在凯尔莫罕的时候来帮你；凯拉的连续选项直接决定了她的命运，也决定了兰伯特的命运（这个有些小伙伴可能还不知道）；威伦有个狼人的支线直接决定了这个悲惨爱情故事的结局；诺威格瑞迪胖的支线决定了游戏最终的政治格局。对主线来说，这样的决定性选项无处不在：血腥男爵的选项，特莉丝和椰奶的选项，Ciri的一系列选项等等。在巫师三中，选项的重要性直接以前后的因果关系体现出来，也许你的不经意的一个选择，就很有可能在未来决定了不同的世界线，其中的很多选项，你甚至都意识不到是由自己的决定造成的，这是不是有《命运石之门》的感觉了。</p>
<figure>
<img data-src="/images/witcher-impression/10.jpg" alt="Ciri猎魔人结局片段" />
<figcaption aria-hidden="true">Ciri猎魔人结局片段</figcaption>
</figure>
<figure>
<img data-src="/images/witcher-impression/11.jpg" alt="Ciri猎魔人结局" />
<figcaption aria-hidden="true">Ciri猎魔人结局</figcaption>
</figure>
<p>我们之前说了，巫师三带给玩家的是沉浸式的体验，那实现这一点的关键就在“真实”。这里的真实，大部分是成年人的部分：我们会遇到各种各样的决策，尽管有句话是说“小孩子才做选择，成年人全都要”，但实际上，只有小孩子才能全都要，成年人的世界不能兼得鱼和熊掌。有些选择比较简单，但也有很多选择，可以说是直接决定了往后人生的整个发展方向。世界上没有后悔药，所以我们常常看到成年人的无奈与悔恨。但是游戏不一样，我们可以回档，可以重来，可以把现实中无法完成的夙愿转移到游戏中，体味人生抉择的无奈，尝尽人生起伏的精彩，但最爽的，还是能够重来，再走一遭。</p>
<p>巫师三是在真正意义上模拟了人生： -
首先，它的选项逻辑是合理的。很多游戏，包括奥德赛在内，它们所谓给出的选项很多都是不合理的。我为什么要这么做？为什么只有这几个选择？策划是不是脑子有坑？正常人会这么做？在选择的时候，不合理、不充分的选项不但不能产生真实的沉浸感，而且还会极大破坏游戏剧情推进的合理性。巫师三不然，它给出的每一个选项都是合理的，都是玩家真的可能在现实生活中面对的两难困境，从而不会让玩家产生“这个选项好弱智”的疑惑。真实的选项才能获得真实的体验，为选择而选择的设置只能适得其反。
-
其次，它的选项是有反馈的。所谓反馈，就是无论你选了什么选项，都能在游戏的过程中获得该选择的结果，而且在看到这个结果的时候，玩家是可以或多或少发现它的起源就是那个选项。巫师三的选项就是有始有终的，它可能在有意无意间唤起你的决定，或最近，或久远，那个时候，玩家就会惊叹：原来如此！这是很重要的，因为在现实中，人们会感到“后悔”或者“幸好”，就是这样的“记忆唤醒”在作祟。人是健忘的，但这不是说记忆会消失，而是会被暂时隐藏，所以必须要有一个触发点（Trigger）才能重新唤醒这段记忆，而记忆一旦唤醒，就会有首尾呼应的触动，进而给玩家带来震撼感。这也是巫师三能带来真实体验的一个重要因素。</p>
<figure>
<img data-src="/images/witcher-impression/1.jpg" alt="Geralt和夏妮" />
<figcaption aria-hidden="true">Geralt和夏妮</figcaption>
</figure>
<ul>
<li>最后，它的选项是关键的。所谓关键，就是一些选项会产生极其重大的影响，此类选项在主线中最多，但也不乏一些支线。为什么说一些选项需要具备关键性？其实这就像欣赏任何一个文学作品一样，无论是小说，还是电影，剧情总是需要跌宕起伏。一平到底，或者过于波折，都会给观众造成审美疲劳。这在游戏里也是一样的。如果所有的支线都是做了就做了的那种，那么就不会给人留下深刻印象，反之，只有平淡与冲突交错的支线才会充分勾起玩家的兴趣。上面我们说了巫师三的支线都是有反馈，那么反馈对后续游戏造成的影响就可以定义为该支线的“关键度”。一个比较合理的关键度分布，应该需要满足5:3:2或者6:3:1的比例的，也就是大部分任务都是比较平淡的，立马能得到反馈的，而且对主要剧情没有影响的；少部分任务会在游戏后续呈现出比较重要的影响；而极少的任务会产生决定性的影响。举例来说，委托任务，城中任务，基本上都可以归为第一类，像凯拉、雷索这样的任务可以归为第二类，最后像迪胖、希里这样的就可以归为第三类。可以看到，巫师三的选项是非常有层次的，这样的层次感不会让玩家感到枯燥疲倦，从而更好地代入到游戏中。这也是巫师三让人停不下来的一个原因之一。</li>
</ul>
<figure>
<img data-src="/images/witcher-impression/7.jpg" alt="Geralt的回忆" />
<figcaption aria-hidden="true">Geralt的回忆</figcaption>
</figure>
<h1 id="有条不紊循序渐进">有条不紊，循序渐进</h1>
<p>在前面的两节中，我们说了很多支线的内容，包括支线的特性、选项的特性，但是在游戏里，决定玩家游戏体验是否“丝滑”的决定因素是主线的推进节奏。巫师三的主线的推进非常顺滑，玩家不会感到节奏上的拖沓或者赶工，从百草园，到威伦，到诺威格瑞，再到Skellig、凯尔莫罕，每个地方的风土人情都在剧情中得以充分展开，每个地方，从开始到结尾，都有明显的渐变，不会造成突兀感。这就是主线承接上的无缝性。</p>
<p>从整体上来看，巫师三的剧情推进呈现出前期平缓，后期陡峭上升，在最后达到高潮之后迅速下降收尾的趋势，尤其是在最后经过高潮后的突然结束，让玩家回味无穷。从百草园到是Skellig是整个游戏的平缓期，在这个时期，玩家更多地是在品味一个新地点的独有风格，所以游戏没有安排太波折的剧情，只是一点一点让玩家代入到整个游戏的剧情中。之后从凯尔莫罕开始，剧情开始迅速推进，寻找Ciri——&gt;找到Ciri——&gt;凯尔莫罕保卫战——&gt;决战狂猎——&gt;真相浮出——&gt;Ciri献身，这一系列重要剧情节点被安排地非常紧凑，这是因为经过前中期长时间的铺垫，玩家已经全然进入到角色，当前最期待的是一波快节奏的剧情轰炸。笔者在出Skellig之后，就有预感剧情一定会出现巨大转折，从乌马开始，到狂猎结束，整个线非常完整，发展也非常迅速。但在这样的快节奏下，游戏不是混乱的，而是始终围绕着一个线索在有序地推进（找Ciri——&gt;干狂猎），这样一来，即使游戏的节奏突然加快，玩家也没有不适感。</p>
<figure>
<img data-src="/images/witcher-impression/8.jpg" alt="老爷子战逝" />
<figcaption aria-hidden="true">老爷子战逝</figcaption>
</figure>
<figure>
<img data-src="/images/witcher-impression/6.jpg" alt="老爷子死去Ciri流泪" />
<figcaption aria-hidden="true">老爷子死去Ciri流泪</figcaption>
</figure>
<p>巫师三的三个时期“平缓——上升——下降”是处理得很好的。平缓期大概占了整个游戏进度的50%左右，在这个期间，游戏的主要内容缓慢推进。注意，不是没有推进，而是以叙述的方式娓娓道来，逐渐营造引人入胜的氛围。上升期大概占了45%的内容，在这个阶段内，游戏的剧情迅速发展，剧情节点迅速变化，游戏状态迅速切换，然而玩家没有任何的不适应，反而更加乐在其中，停不下来。这是因为前50%的铺垫已经将玩家去完全代入到游戏中，仿佛你就是Geralt，你的使命就在眼前。在上升期的末尾，游戏戛然而止，来到下降期。巫师三的下降期非常短暂，我认为大致可以从Ciri献身开始算做下降期，在这个节点，玩家之前所有的选择都会体现在不同的结局上，突然结尾更加凸显了玩家之前决策带来的种种后果。显然，CDPR没有采取让游戏慢慢结束，而且一下子就关闭了游戏主线剧情，带来了一种“惊愕感”：“这游戏结束了！？”这样的设计是很巧妙的，但也是建立在之前的平缓期与上升期的铺垫之上的。可以说，巫师三这种有条不紊、循序渐进的三阶段推进方式，是它能够取得沉浸式体验的另一大重要原因。</p>
<figure>
<img data-src="/images/witcher-impression/12.jpg"
alt="通关主线，从空荡的凯尔莫罕重新出发，寂寥涌上心头" />
<figcaption
aria-hidden="true">通关主线，从空荡的凯尔莫罕重新出发，寂寥涌上心头</figcaption>
</figure>
<h1 id="写在最后">写在最后</h1>
<p>尽管本文的目的在于从任务系统上简要感受一下巫师三为什么能带给人沉浸式的体验，但是对于巫师三来说，画面、人物、音乐等等其他方面都是促成巫师三能成为神作的重要因素，尤其是巫师三的音乐，直击人心，给人带来的沉浸感不亚于剧情，在此强烈推荐。</p>
<figure>
<img data-src="/images/witcher-impression/9.jpg" alt="Geralt太可爱了吧" />
<figcaption aria-hidden="true">Geralt太可爱了吧</figcaption>
</figure>
<p>之后我会介绍一下英灵殿和12月份的赛博朋克2077，到时候再来看看，巫师三这款5年前的游戏是否仍有一战之力。</p>
<figure>
<img data-src="/images/witcher-impression/14.png" alt="陶森特美丽的风光" />
<figcaption aria-hidden="true">陶森特美丽的风光</figcaption>
</figure>
]]></content>
      <categories>
        <category>游戏 - 玩后感</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>生活</tag>
        <tag>巫师三</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Hades最终BOSS的AI设计</title>
    <url>/2021/09/22/08/52/</url>
    <content><![CDATA[<p>作为一个典型的ROUGE-like
ACT游戏，BOSS在Hades的游戏体验中占据非常重要的地位。一次完整的游戏流程需要经历四个BOSS：复仇三姐妹中的一个，九头蛇，装逼双雄和最终BOSS
Hades。每个BOSS的设计都很有特色，</p>
<span id="more"></span>
<h1 id="核心技能与玩家体验">核心技能与玩家体验</h1>
<p>Hades分为两个阶段，第二阶段在第一阶段的基础上删减/增加了若干技能。下面介绍两个阶段的核心技能与对应的玩家体验。这里暂时没有逐帧拆解动作，之后有时间了会更新。</p>
<h2 id="第一阶段">第一阶段</h2>
<ul>
<li><p>站立（Idle）
站在原地不动，一般是在释放技能后。该技能的作用有三：（1）成为其他伤害型技能释放的中继点，避免一直释放技能造成难度较大，带给玩家不好的游戏体验；（2）木桩模式为玩家提供free
attack的时间窗口，是得到输出正反馈的最佳时间段；（3）等待恢复技能CD或Counter。
<img data-src="/images/hades-AI/idle.png" /></p></li>
<li><p>移动冲刺（Move）
向前移动一段距离。作用有二：（1）等待恢复技能CD或Counter；（2）缩小与玩家之间的距离（该技能只出现在与玩家距离过远时），提升BOSS战的压迫与紧张感。
<img data-src="/images/hades-AI/move.png" /></p></li>
<li><p>回旋击
以自身为圆心挥舞两圈武器，范围较大，发动后不会改变前进方向。大范围AOE，并且有连续两次连击，因此如果玩家在两次攻击的范围内，用闪避不能全部躲过去，至少吃一发，换句话说，“回旋击的攻击时间&gt;闪避的无敌时间”。但该技能的特性在于，在较长的技能前摇，在前摇期内BOSS会锁定当前玩家的方向，然后两次攻击都会向着那个方向前进。所以躲避这个技能的关键在于：较快地判断BOSS攻击的方向并朝着反方向闪避移动。这实际上考验了玩家的观察能力和反应能力，并且由于该技能攻击范围较大，所以又提高了对玩家的要求。除了这一点玩家体验之外，这个技能还有一个作用：逼迫玩家拉远与BOSS的距离，避免长时间与BOSS肉搏（当然这个还与武器有关），形成较好的攻防节奏。
<img data-src="/images/hades-AI/spin.png" /></p></li>
<li><p>突刺击
向前突刺，距离较短，普通的伤害技能。该技能要求玩家有一定的闪避技巧，但难度不大。
<img data-src="/images/hades-AI/spike.png" /></p></li>
<li><p>突刺击-Ex 距离较远的突刺击。同上，对闪避有一定要求，但难度不大。
<img data-src="/images/hades-AI/spike-Ex.png" /></p></li>
<li><p>遁形
进入隐身状态持续一段时间，之后在雪地上连续出现两次脚印，标志着BOSS的移动轨迹，最后将在角色附近突然出现并执行单次大范围回旋击。该主要考核了玩家观察BOSS行为轨迹并进行预判的能力，需要提前使用闪避快速远离可能的目标地点。注意这个技能最后的回旋击范围是所有技能中最大的，如果不幸BOSS就闪现在身边，单次闪避是没有办法逃离AOE范围的，除非是连续多次闪避或提前预判位置走开。这个技能的作用有：（1）长时间BOSS的无攻击期方便BOSS重置技能CD或Counter；（2）方便玩家清理场上的小怪或者Bomb；（3）形成一个较长时间的Combat
break，缓解了一下紧张的战斗节奏。 <img
src="/images/hades-AI/escape-1.png" /> <img
src="/images/hades-AI/escape-2.png" /></p></li>
<li><p>发射Bomb
向前发射一个Bomb，如果直接撞到主角会产生伤害并附带“沸腾之血”Debuff，否则经过一段时间的滑行或撞到墙之后停下，并开始5秒倒计时。如果没在倒计时结束前打破Bomb，则Bomb会爆炸产生超大范围的缓慢全屏光圈攻击，需要闪避躲过去或远离Bomb。该技能和前面的纯粹伤害型技能都不同，它产生了一个额外的敌人，而在已知该敌人会造成较大威胁的前提下，驱使玩家转而攻击Bomb，当然玩家如果对自己的技术有信心，也可以无视它继续攻击Boss，这就增强了游戏的策略性：如果自己当前状态不健康，上策必然是打掉Bomb；否则攻击BOSS会更快结束战斗。这个技能还有一个比较特殊的地方在于，它往往是连续多次出现的，这就进一步增强了玩家临时的决策要求：多个Bomb存在时会指数级地增大游戏的风险，这时候即使自己状态比较健康也会更加慎重地进行选择。该技能的另外一个好处在于，它将单纯的BOSS
combat转为了Battlefield
clear模式，即优先清理小怪。两种战斗模式的切换也能增强游戏的多样性。 <img
src="/images/hades-AI/bomb.png" /></p></li>
<li><p>发射Bomb-Ex
发射前向高速移动的Bomb，撞到墙才会停止，其他机制与发射Bomb相同。该技能的作用同上，但是由于该技能伤害更高，更难躲避，因此更加考验玩家的反应和观察力。
<img data-src="/images/hades-AI/bomb-Ex.png" /></p></li>
<li><p>召唤
在第一阶段2/3和1/3血量处时使用召唤技能，进入短暂无敌状态并随机召唤几个较为强力的小怪。每一次召唤之后上述所有技能的使用频率都会发生变化。<strong>假设为三个子阶段，在第一个子阶段，回旋击、突刺击和突刺击-Ex使用较多，遁形、发射Bomb和发射Bomb-Ex使用较少，且整体的攻击频率很低（也即一个连续的攻击集合中包含的攻击技能较少，一般只有1~2个，集合之间通过Idle、遁形实现暂停）。在第二个子阶段，依旧以回旋击、突刺击和突刺击-Ex为主，但是发射Bomb和发射Bomb-Ex频率开始增加，整体攻击频率开始增加（一个攻击集合中的技能数量增加，为2~4个，集合之间的Idle持续时间开始缩短）。在第三个子阶段，所有技能的使用频率基本相同，变得更有节奏感，即使用一套技能之后进行遁形，然后再使用一套技能（此时一个攻击集合中的技能数量变为2~5个，集合之间的Idle持续时间进一步缩短）</strong>。该技能的作用本质和发射Bomb是一致的，但是Battlefield
clear的意图更加明显，玩家这时候不得不优先清理小怪而不是像对待Bomb那样可选可不选，因为小怪非常强力并且极具干扰。在Battlefield
clear期间，BOSS也会照常攻击玩家，这个时候是最紧张刺激的阶段，直到清理完所有小怪。
<img data-src="/images/hades-AI/summon.png" /></p></li>
</ul>
<h2 id="第一阶段总结">第一阶段总结</h2>
<p>总的来说，BOSS的第一阶段攻击招式非常多样，不但有直接伤害型技能，还有召唤型技能，不但有持续的攻击输出，还有间或出现的木桩模式、Attack
break模式，给持续紧张的战斗带来一点点休息的空隙。即使在同一个技能模板下，也有两个不同的强弱版本，这当然不是制作组偷懒（或许也有这个因素），更多的是同一套技能模板下的不同变体既能帮助玩家辨识该技能的前摇、释放、后摇是怎样的，又能增强玩家在游戏体验上的丰富度，何乐而不为呢。</p>
<p>BOSS的第一阶段尤其值得注意的是，所有技能都对玩家使用“闪避”的能力提出了较高的要求，无论是直截了当的突刺击、突刺击-Ex，还是遁形后的回旋击、发射Bomb、发射Bomb-Ex，都要求玩家能在极短时间内做出闪避这个动作。并且随着BOSS第一阶段的血量降低，BOSS发动上述技能的频率会显著增加，即木桩模式的持续时间几乎趋于零，更多地是以遁形代替，这样的设计充满了游戏开发者的恶意：“想靠遁形休息一下？没门儿！接着闪避吧。”</p>
<h2 id="第二阶段">第二阶段</h2>
<p>第二阶段没有第一阶段“遁形”、
“召唤”、“突刺击”、“发射Bomb”这四个技能，其他技能都有。除了第一阶段的技能之外，第二阶段增加了四个新技能（不算初始爆发），介绍如下：</p>
<ul>
<li><p>初始爆发
在第二阶段一开始会以自身为圆心创造缓慢全屏光圈攻击，需要闪避躲过去。这个不多说了，只是一个阶段变化的标志而已。
<img data-src="/images/hades-AI/init.png" /></p></li>
<li><p>局部光束
在面朝的方向发射三个光束，缓慢旋转，幅度大约为90度。该技能前摇非常明显，主要考察玩家的观察能力，甚至不太考察玩家的反应、闪避能力。
<img data-src="/images/hades-AI/local.png" /></p></li>
<li><p>全局光束
发射全屏光束。该技能前摇时间较长，约为2秒左右，因此玩家在看到前摇动作的时候，需要快速找到掩体进行防御，因此考察了玩家的反应能力。该技能的另外一个作用和遁形类似：创造一段时间的Combat
break，缓解高强度战斗节奏。 <img
src="/images/hades-AI/global.png" /></p></li>
<li><p>阴间柱子
在地图上随机生成9个绿色阴间柱子，打破后会有地狱之手将角色控制，持续约2秒。在打掉所有柱子之前不会再产生新的阴间柱子。在产生柱子之后，会有一定的时间间隔释放基本技能，之后会释放局部光束或全局光束。然后继续释放基本技能，直到下次阴间柱子的产生，循环此过程。光束和阴间柱子这两个技能是BOSS第二阶段的核心，在下面的总结部分进行详细介绍。
<img data-src="/images/hades-AI/pillar-1.png" /> <img
src="/images/hades-AI/pillar-2.png" /></p></li>
<li><p>斩击
向前发动两次较大范围的斩击。该技能和“回旋击”基本是一致的，只不过每次斩击的范围只局限在前半身而不是360度范围。该技能同样考察了玩家的闪避和反应能力，但难度较低。
<img data-src="/images/hades-AI/slash.png" /></p></li>
</ul>
<h2 id="第二阶段总结">第二阶段总结</h2>
<p>如果是BOSS第一阶段重点考察了玩家的闪避能力，那么BOSS第二阶段就考察了玩家的综合能力：观察、反应、策略，当然还有要求更高的闪避。这是因为，第二阶段取消的技能非常有代表性，除了“召唤”之外，“遁形”“突刺击”“发射Bomb”都是在考察玩家的基本闪避能力，这时候只需要使用它们的Ex版本就好了。取而代之的技能有“局部光束”“全局光束”“阴间柱子”“斩击”。“斩击”相当于是另一个版本的“回旋击”，同样考察了玩家的观察、反应和闪避能力，实际上这个技能我个人认为做的比较失败，因为在定位上和回旋击是基本一致的。接下来就是很关键的“局部光束”“全局光束”“阴间柱子”，这三个技能，或者说两个，往往是搭配出现的，这就是第二阶段重策略和反应的核心。</p>
<p>BOSS的释放逻辑是：（1）首先召唤9个阴间柱子；（2）上来对玩家进行一套技能；（3）突然释放“局部光束”或者“全局光束”。这一套逻辑的点在于：（1）召唤的9个阴间柱子不能马上打掉，一是因为数量比较多，二是BOSS在骚扰；（2）BOSS的骚扰会被迫让玩家进入与BOSS的战斗节奏而没有及时清理周围的阴间柱子；（3）BOSS突然释放伤害极高的光束，会让玩家迅速寻找掩体，但是由于玩家之前被BOSS拖住没有及时清理柱子，所以就有相当的概率会在寻找掩体的过程中失误，被阴间柱子缠住，这时候BOSS的光束打中玩家，造成大量伤害甚至秒杀。</p>
<p>可以发现，上面的一套逻辑下来，目的就是要让玩家“第一时间打掉阴间柱子”，即使这个BOSS在骚扰，也要尽可能无视它优先尽快清理柱子，否则之后BOSS释放光束会非常棘手。如果玩家没有意识到这一点，就一定会被BOSS屡试不爽，这也就考察了玩家的反应和决策能力。当然阴间柱子怎么清理呢，如果是远程武器就很简单了，但是如果是拳套，就可以通过丢标或者闪避伤害去清理，当然也可以引导BOSS去打掉柱子。选择很多，关键还是要临场反应。其他剩下的技能就是在更多地考察进阶的闪避能力了，本质上和BOSS第一阶段是一样的。
<img data-src="/images/hades-AI/summary.png" /></p>
<h1 id="实现逻辑">实现逻辑</h1>
<p>通过观察可以猜测下面的（可能的）AI设计逻辑。 ## 第一阶段
整体的技能AI涉及到几个参数：技能集合大小随机数randomSetSize，每个技能出现在技能集合中的概率p[i]（i=回旋击、突刺击、突刺击-Ex、发射Bomb、发射Bomb-Ex）及对应的最大出现次数t[i]，Idle持续时间idleTime，技能集合之间的过渡选择概率p[move]、p[Idle]和p[escape]，分别表示用“冲刺移动”、“站立”和“遁形”承接两个相邻的技能集合。</p>
<p>具体的AI逻辑如下：</p>
<ul>
<li>血量判断：当分别为2/3,
1/3血量的时候，释放技能“召唤”并进入下一个子阶段。每个子阶段上述的所有参数都会有所变动。</li>
<li>距离判断：当玩家和BOSS的距离超过一定距离的时候，会依据p[move]来接近玩家。</li>
<li>第一个子阶段：在满足血量和距离的前提下，生成随机数randomSetSize
∈[1,2]，并根据p[i]和t[i]的限制选择技能集合中的技能，然后执行该技能集合。之后，根据idleTime执行站立动作（此时没有用到p[Idle]，因为这个阶段idle是一定执行的）。然后根据p[escape]选择是否执行“遁形”技能。最后回到距离判断。</li>
<li>第二个子阶段：在满足血量和距离的前提下，生成随机数randomSetSize
∈[2,4]，并根据p[i]和t[i]的限制选择技能集合中的技能，然后执行该技能集合。注意这个时候p[i]应该有所调整，具体来说，是将发射Bomb和发射Bomb-Ex的概率增大，突刺击和突刺击-Ex的概率降低，回旋击不变或适度增大。之后，根据idleTime执行站立动作（此时没有用到p[Idle]，因为这个阶段idle是一定执行的，同时相比第一个子阶段，idleTime适当减小）。然后根据p[escape]选择是否执行“遁形”技能，p[escape]此时相比上一个子阶段适当增大。最后回到距离判断。</li>
<li>第三个子阶段：在满足血量和距离的前提下，生成随机数randomSetSize
∈[2,5]，并根据p[i]和t[i]的限制选择技能集合中的技能，然后执行该技能集合。注意这个时候p[i]应该相比上一个子阶段进一步调整，具体来说，是将发射Bomb和发射Bomb-Ex的概率进一步增大，突刺击和突刺击-Ex的概率进一步降低，回旋击不变或适度增大，最终效果应以Bomb为主，回旋击次之，突刺击为辅。之后，根据p[Idle]决定是否执行站立动作，站立时间为idleTime，相比上一个子阶段时间再次适当缩短。p[Idle]原则上应该比较大(&gt;=80%)。之后，执行“遁形”技能。最后回到距离判断。</li>
</ul>
<h2 id="第二阶段-1">第二阶段</h2>
<p>由于第二阶段内部只包含一个子阶段，因此AI逻辑相比第一阶段更加简单。</p>
<p>整体的技能AI涉及几个参数：技能集合大小随机数randomSetSize，每个技能出现在技能集合中的概率p[i]（i=回旋击、突刺击-Ex、发射Bomb-Ex、斩击）及对应的最大出现次数t[i]，发射局部光束的概率p[local]，发射全局光束的概率p[global]，发动阴间柱子的概率p[hell]，站立的概率p[Idle]，移动的概率p[move]，站立的持续时间idleTime。</p>
<p>具体的AI逻辑如下（不考虑进入第二阶段开始的初始爆发）：</p>
<ul>
<li>距离判断：当玩家和BOSS的距离超过一定距离的时候，会依据p[move]来接近玩家。</li>
<li>根据p[hell]决定是否释放阴间柱子。如果释放，则进入“阴间模式”，否则为“普通模式”。
<ul>
<li>在“阴间模式”下，生成随机数randomSetSize
∈[2,5]，并根据p[i]和t[i]的限制选择技能集合中的技能，然后执行该技能集合。之后，根据p[local]和p[global]选择执行“局部光束”或者“全局光束”。之后，根据p[Idle]决定是否执行站立动作，站立时间为idleTime，该值小于BOSS第一阶段的对应值。“阴间模式”结束，减小p[hell]，如果当前是第三次释放阴间柱子，则设置p[hell]=0。最后回到距离判断。</li>
<li>在“普通模式”下，生成随机数randomSetSize
∈[2,5]，并根据p[i]和t[i]的限制选择技能集合中的技能，然后执行该技能集合。之后，根据p[Idle]决定是否执行站立动作，站立时间为idleTime，该值小于BOSS第一阶段的对应值。“普通模式”结束，回到距离判断。</li>
</ul></li>
</ul>
<h1 id="用behavior-designer画一个简单的行为树">用Behavior
Designer画一个简单的行为树</h1>
<p>按照上述逻辑可以设计如下的简化版BD，直接展现图，就不过多文字描述了。</p>
<h2 id="第一阶段-1">第一阶段</h2>
<p><img data-src="/images/hades-AI/bt-1.png" /></p>
<h2 id="第二阶段-2">第二阶段</h2>
<p><img data-src="/images/hades-AI/bt-2.png" /></p>
]]></content>
      <categories>
        <category>游戏 - 游戏分析</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Implementing A Minimum 1V1 Camera in UE (akin to FramingTransposer + Composer in Cinemachine)</title>
    <url>/2022/12/11/09/16/</url>
    <content><![CDATA[<p>The camera system inside Unreal Engine provides very basic functions.
It merely enables the camera to follow a target with limited adjustable
paramters such as offset, camera distance, lag, etc. We would like a
more powerful camera system, like the Cinemachine toolset in Unity, to
facilitate creating more interesting and compelling visual experience
for gameplay. In most 3D adventure games, a 1v1 camera is required when
you fight with a BOSS and you need to look at the BOSS however you move
and cast skills. Unfortunately, 1v1 camera is not a built-in function in
UE, so we have to implement our own version of 1v1 camera.</p>
<p>In this post, I will share with you how to implement a minimum 1v1
camera in UE using only blueprints, based on some simple mathematics. If
you are more familiar with coding, you can also implement this 1v1
camera with only few lines of code.</p>
<span id="more"></span>
<h1
id="start-with-a-simple-case-mathematical-derivation-for-camera-location-and-rotation">Start
with A Simple Case: Mathematical Derivation for Camera Location and
Rotation</h1>
<h2 id="constructing-the-equation">Constructing the equation</h2>
<p>The most crucial two parts of any camera behavior are the
<strong>location</strong> and <strong>rotation</strong>, the former
determines where the camera is and the latter controls where the camera
looks at.</p>
<p>Let us first begin with a simple case: assume the follow location is
<span class="math inline">\(\mathbf{a}\)</span>, the look-at location is
<span class="math inline">\(\mathbf{b}\)</span>, and the look-at point
is fixed at the center of the screen. We introduce a
<code>Follow Screen X</code> parameter (denoted by <span
class="math inline">\(a_x\)</span>) controlling the relative x-axis
offset of the follow point on the screen space. If <span
class="math inline">\(a_x=0\)</span>, the follow point will be on the
center of the screen; if <span class="math inline">\(a_x=0.5\)</span>,
the follow point will be on the rightmost position of the screen; if
<span class="math inline">\(a_x=-0.5\)</span>, it will be on the
leftmost position of the screen. At this stage, we do not take
<code>Follow Screen Y</code> into consideration for simplication.</p>
<p>To determine camera location and rotation, consider a sphere centered
at the origin. Assume camera distance (the distance of the camera to the
follow point) is <span class="math inline">\(r\)</span>, pitch angle
<span class="math inline">\(\varphi\in[-\pi/2,\pi/2]\)</span>, yaw angle
<span class="math inline">\(\theta\in[-\pi,\pi]\)</span>, we can write
down the camera location before applying the follow point offset:</p>
<p><span class="math display">\[
\begin{equation}
\mathbf{x}=\begin{pmatrix}
r\cos\varphi\cos\theta\\
r\cos\varphi\sin\theta\\
r\sin\varphi
\end{pmatrix}
\label{x}
\end{equation}
\]</span></p>
<p>Note that <span class="math inline">\(\eqref{x}\)</span> is the
<strong>raw camera location</strong> relative to the origin. The look-at
direction, however, is <span
class="math inline">\(-\mathbf{x}/r\)</span>, and the <strong>actual
camera location</strong> is <span
class="math inline">\(\mathbf{a}+\mathbf{x}\)</span>. For integrating
<span class="math inline">\(a_x\)</span>, we can assume the camera
offset is <span class="math inline">\(\mathbf{t}_1\)</span>, hence, the
<strong>final camera location</strong> is <span
class="math inline">\(\mathbf{a}+\mathbf{x}+\mathbf{t}_1\)</span>, and
the look-at direction from camera to <span
class="math inline">\(\mathbf{b}\)</span> is <span
class="math inline">\(\mathbf{b}-(\mathbf{a}+\mathbf{x}+\mathbf{t}_1)\)</span>.
Because <span class="math inline">\(\mathbf{t}_1\)</span> does not
change the orientation of camera, the camera's look-at direction, as we
have stated above, is still <span
class="math inline">\(-\mathbf{x}/r\)</span>. It is obvious that we have
the following equation:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{b}-\mathbf{a}-\mathbf{x}-\mathbf{t}_1=-k\mathbf{x}
\label{main}
\end{equation}
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is an unknown
coefficient satisfying <span class="math inline">\(k&gt;1\)</span> as we
want the look-at target is farther than the follow target to our camera.
Before wo go ahead solving this equation, we should determine <span
class="math inline">\(\mathbf{t}_1\)</span> at the first place.</p>
<h2 id="determining-mathbft_1">Determining <span
class="math inline">\(\mathbf{t}_1\)</span></h2>
<p>We can easily express <span
class="math inline">\(\mathbf{t}_1\)</span> in terms of <span
class="math inline">\(a_x, r\)</span> and the field of view of the
camera. As shown in the following figure, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \frac{N}{r}=\tan\left(\frac{\text{fov}}{2}\right)\Rightarrow
N=r\tan\left(\frac{\text{fov}}{2}\right)
\label{N}
\end{equation}
\]</span></p>
<p>where <span class="math inline">\(N\)</span> is the world-space
length of half screen. Then, the offset amount is <span
class="math inline">\(2a_xN\)</span> (note that when <span
class="math inline">\(a_x=0.5\)</span>, the offset amount will be <span
class="math inline">\(N\)</span>), and the offset direction will be the
opposite of the sign of <span class="math inline">\(a_x\)</span>. That
is, is <span class="math inline">\(a_x&gt;0\)</span>, camera will
translate left, otherwise it will translate right.</p>
<p><img data-src="/images/1v1camera/1.png" /></p>
<p>Plug <span class="math inline">\(\eqref{N}\)</span> into <span
class="math inline">\(-2x_aN\)</span>, the directional offset magnitude
will be <span
class="math inline">\(-2a_xr\tan\left(\frac{\text{fov}}{2}\right)\)</span>.</p>
<p>A remaining question is which unit vector this offset will be applied
along? The answer is the camera's local right direction. It can be
readily computed by taking the cross product between camera's local unit
forward vector <span class="math inline">\(-\mathbf{x}/r\)</span> and
world space up vector <span
class="math inline">\((0,0,1)^\top\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
    \begin{pmatrix}
    -\cos\varphi\cos\theta\\
    -\cos\varphi\sin\theta\\
    -\sin\varphi
    \end{pmatrix}\times
    \begin{pmatrix}
    0\\
    0\\
    1
    \end{pmatrix}=
    \begin{pmatrix}
    -\cos\varphi\sin\theta\\
    \cos\varphi\cos\theta\\
    0
    \end{pmatrix}
\end{equation}
\]</span></p>
<p>Normalizing the result, and considering that UE's coordiante system
is based on the left-hand rule, the local unit right vector will be
<span class="math inline">\((\sin\theta, -\cos\theta, 0)^\top\)</span>.
Thus, the consequent offset vector is:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{t}_1=t_1\begin{pmatrix}
    \sin\theta\\
    -\cos\theta\\
    0
    \end{pmatrix},~~t_1=-2a_xr\tan\left(\frac{\text{fov}}{2}\right)
\end{equation}
\]</span></p>
<h2 id="determining-varphi-and-theta">Determining <span
class="math inline">\(\varphi\)</span> and <span
class="math inline">\(\theta\)</span></h2>
<p>With <span class="math inline">\(\mathbf{t}_1\)</span>, we can now
determine <span class="math inline">\(\varphi\)</span> and <span
class="math inline">\(\theta\)</span>. Expanding <span
class="math inline">\(\eqref{main}\)</span>, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \begin{pmatrix}
    x_B\\
    y_B\\
    z_B
    \end{pmatrix}-
    \begin{pmatrix}
    x_A\\
    y_A\\
    z_A
    \end{pmatrix}-
    \begin{pmatrix}
    r\cos\varphi\cos\theta\\
    r\cos\varphi\sin\theta\\
    r\sin\varphi
    \end{pmatrix}-
    \begin{pmatrix}
    t_1\sin\theta\\
    -t_1\cos\theta\\
    0
    \end{pmatrix}=-k\begin{pmatrix}
    r\cos\varphi\cos\theta\\
    r\cos\varphi\sin\theta\\
    r\sin\varphi
    \end{pmatrix}
\label{eq6}
\end{equation}
\]</span></p>
<p>Simplifying <span class="math inline">\(\eqref{eq6}\)</span>, we
have:</p>
<p><span class="math display">\[
\begin{pmatrix}
\Delta x\\
\Delta y\\
\Delta z
\end{pmatrix}=
\begin{pmatrix}
    (1-k)r\cos\varphi\cos\theta+t_1\sin\theta\\
    (1-k)r\cos\varphi\sin\theta-t_1\cos\theta\\
    (1-k)r\sin\varphi
\end{pmatrix}
\]</span></p>
<p>which leads to three equations:</p>
<p><span class="math display">\[
\begin{align}
    (1-k)r\cos\varphi\cos\theta+t_1\sin\theta &amp;= \Delta x
\label{eq7}\\
    (1-k)r\cos\varphi\sin\theta-t_1\cos\theta &amp;= \Delta y
\label{eq8}\\
    (1-k)r\sin\varphi &amp;= \Delta z \label{eq9}
\end{align}
\]</span></p>
<p>Rewrite <span class="math inline">\(\eqref{eq9}\)</span>, we
have:</p>
<p><span class="math display">\[
\begin{equation}
    (1-k)r=\frac{\Delta z}{\sin\varphi}
    \label{eq10}
\end{equation}
\]</span></p>
<p>Plug <span class="math inline">\(\eqref{eq10}\)</span> into <span
class="math inline">\(\eqref{eq7}\)</span> and <span
class="math inline">\(\eqref{eq8}\)</span>:</p>
<p><span class="math display">\[
\begin{align}
    \frac{\Delta z}{\tan\varphi}\cos\theta+t_1\sin\theta &amp;= \Delta x
\label{eq11}\\
    \frac{\Delta z}{\tan\varphi}\sin\theta-t_1\cos\theta &amp;= \Delta y
\label{eq12}\\
\end{align}
\]</span></p>
<p>Combining <span class="math inline">\(\eqref{eq11}\)</span> and <span
class="math inline">\(\eqref{eq12}\)</span>, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \frac{\Delta x - t_1\sin\theta}{\cos\theta}=\frac{\Delta y
+t_1\cos\theta}{\sin\theta}\Rightarrow \Delta x\sin\theta-\Delta
y\cos\theta=t_1
\label{eq13}
\end{equation}
\]</span></p>
<p>To note, when <span class="math inline">\(\theta=0\)</span> or <span
class="math inline">\(\theta=\pi\)</span>, the above equation also
holds. Divided by <span class="math inline">\(\sqrt{(\Delta x)^2+(\Delta
y)^2}\)</span> on both sides, we have:</p>
<p><span class="math display">\[
\small
\begin{equation}
\begin{aligned}
    \frac{t_1}{\sqrt{(\Delta x)^2+(\Delta y)^2}} &amp;= \frac{\Delta
x}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\sin\theta-\frac{\Delta
y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\cos\theta\\
    \frac{t_1}{\sqrt{(\Delta x)^2+(\Delta y)^2}} &amp;=
\cos\alpha\sin\theta-\sin\alpha\cos\theta \\
    \frac{t_1}{\sqrt{(\Delta x)^2+(\Delta y)^2}} &amp;=
\sin(\theta-\alpha) \\
    \theta &amp;= {\color{cyan}\alpha} + {\color{pink}\beta}\\
    \theta &amp;= {\color{cyan}\arcsin\left(\frac{\Delta
y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\right)}+
{\color{pink}\arcsin\left(\frac{t_1}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\right)}
\end{aligned}
\label{eq14}
\end{equation}
\]</span></p>
<p>The tinted values <span
class="math inline">\({\color{cyan}\alpha=\arcsin\left(\frac{\Delta
y}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\right)}\)</span> and <span
class="math inline">\({\color{pink}\beta=\arcsin\left(\frac{t_1}{\sqrt{(\Delta
x)^2+(\Delta y)^2}}\right)}\)</span> should be calibrated according to
the sign of <span class="math inline">\(\Delta x\)</span> and <span
class="math inline">\(\Delta y\)</span>. It's particularly noteworthy
that when <span class="math inline">\({\color{pink}\beta=0}\)</span>,
<span class="math inline">\({\color{cyan}\alpha}\)</span> should be:</p>
<ul>
<li><span class="math inline">\(\Delta x&gt;0\)</span> and <span
class="math inline">\(\Delta y&gt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[-\pi,-\pi/2]}\)</span></li>
<li><span class="math inline">\(\Delta x&gt;0\)</span> and <span
class="math inline">\(\Delta y&lt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[\pi/2,\pi]}\)</span></li>
<li><span class="math inline">\(\Delta x&lt;0\)</span> and <span
class="math inline">\(\Delta y&gt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[-\pi/2,0]}\)</span></li>
<li><span class="math inline">\(\Delta x&lt;0\)</span> and <span
class="math inline">\(\Delta y&gt;0\)</span>, <span
class="math inline">\({\color{cyan}\alpha\in[0,\pi/2]}\)</span></li>
</ul>
<p>However, the value returned by <span
class="math inline">\(\arcsin(\cdot)\)</span> lies within <span
class="math inline">\([-\pi/2,\pi/2]\)</span> and should be further
altered according to the observation above. It can be easily concluded
that:</p>
<p><span class="math display">\[
\begin{equation}
    \hat{\alpha}=\begin{cases}
        {\color{cyan}\alpha}-\pi,~&amp;\Delta x&gt;0\\
        -{\color{cyan}\alpha},~&amp;\Delta x\le 0
    \end{cases}
\label{eq15}
\end{equation}
\]</span></p>
<p>For <span class="math inline">\(\beta\)</span>, we notice that when
<span class="math inline">\(t_1\)</span> is positive and gets larger,
the camera's yaw will decrease, so the real beta will be <span
class="math inline">\(\hat{\beta}=-{\color{pink}\beta}\)</span>. Summing
up the corrected values, we reach the true camera yaw <span
class="math inline">\(\hat{\theta}=\hat{\alpha}+\hat{\beta}\)</span>.</p>
<p>The second problem, which is very palpable, is that <span
class="math inline">\(\frac{t_1}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\)</span> can be smaller than <span
class="math inline">\(-1\)</span> or larger than <span
class="math inline">\(1\)</span>, when the denominator — the distance
between follow point and look-at point — is small. If this value exceeds
the bound and we clip it, the resulting yaw <span
class="math inline">\(\theta\)</span> and the subsequent pitch <span
class="math inline">\(\varphi\)</span> would be incorrect, making odd
camera artifacts.</p>
<p>Here are several potential workarounds to deal with this issue:</p>
<ul>
<li>Dynamically adapts <span class="math inline">\(a_x\)</span> to
ensure the absolute value of <span class="math inline">\(t_1\)</span> is
no larger than <span class="math inline">\(\sqrt{(\Delta x)^2+(\Delta
y)^2}\)</span>.</li>
<li>Introduce the concept of <strong>soft zone</strong> and apply
damping just as Cinemachine does.</li>
</ul>
<p>Method two might be a better way because it has smooth result. We
will get to this in later sections of this post, and now we focus on
implementing method one, which is much simpler to achieve using
blueprint. <span id="scale">All we need to do is to set a
<code>BeginAdaptDistanceX</code> and <code>EndAdaptDistanceX</code> that
adapts <span class="math inline">\(a_x\)</span> when <span
class="math inline">\(\sqrt{(\Delta x)^2+(\Delta y)^2}\)</span> is
within the range of <span
class="math inline">\([\text{EndAdaptDistanceX},\text{BeginAdaptDistanceX}]\)</span>.</span>
More concretely, when the distance is within the range, new <span
class="math inline">\(a_x\)</span> will be <span
class="math inline">\(a_x\frac{\text{CurrentDistance}-\text{EndAdaptDistanceX}}{\text{BeginAdaptDistanceX}-\text{EndAdaptDistanceX}}\)</span>.
When both values are set to zero, no scale is applied, when <span
class="math inline">\(\text{EndAdaptDistance}\)</span> is negative,
<span class="math inline">\(a_x\)</span> will have its minimum (the
absolute value) greater than zero. It is very effective and flexible to
use this value in order for avoiding zero-division as will be introduced
in <span class="math inline">\(\eqref{eq16}\)</span>. Directly clamping
<span class="math inline">\(t_1\)</span> between <span
class="math inline">\([-\sqrt{(\Delta x)^2+(\Delta y)^2},\sqrt{(\Delta
x)^2+(\Delta y)^2}]\)</span> will not bring about satisfactory
results.</p>
<p>Note that we leave out the case when <span
class="math inline">\(\Delta x=\Delta y =0\)</span> since for most of
the time the player character and the enemy will not be on the up axis
at the same time.</p>
<p>Once we have <span class="math inline">\(\hat{\theta}\)</span>, we
can easily find out <span class="math inline">\(\varphi\)</span>. By
<span class="math inline">\(\eqref{eq11}\)</span> (or <span
class="math inline">\(\eqref{eq12}\)</span> equivalently), we have:</p>
<p><span class="math display">\[
\begin{equation}
    \varphi=\arctan\left(\frac{\Delta z\cos\hat{\theta}}{\Delta
x-t_1\sin\hat{\theta}}\right)
\label{eq16}
\end{equation}
\]</span></p>
<p>You may ask what will happen if <span class="math inline">\(\Delta
x-t_1\sin\hat{\theta}\)</span> is close to zero? Well, this could not be
a problem as we have already dynamically adapted <span
class="math inline">\(t_1\)</span> with respect to the follow-lookat
distance, as long as the values of <code>BeginAdaptDistanceX</code> and
<code>EndAdaptDistanceX</code> are properly set.</p>
<p>What are <span class="math inline">\(\varphi,\hat{\theta}\)</span>
when <span class="math inline">\(t_1=0\)</span>? From <span
class="math inline">\(\eqref{eq14}\)</span>, we know <span
class="math inline">\(\hat{\theta}=\hat{\alpha}\)</span>; then from
<span class="math inline">\(\eqref{eq14}\eqref{eq16}\)</span> and using
the fact that <span
class="math inline">\(\cos(\arcsin(x))=\sqrt{1-x^2}\)</span>, we have
<span class="math inline">\(\varphi=-\arctan\left(\frac{\Delta
z}{\sqrt{(\Delta x)^2+(\Delta y)^2}}\right)\)</span>.</p>
<h2 id="final-camera-location-and-rotation">Final camera location and
rotation</h2>
<p>To summarize, we first compute <span
class="math inline">\(\alpha\)</span> and <span
class="math inline">\(\beta\)</span> with <span
class="math inline">\(\eqref{eq14}\)</span>:</p>
<p><span class="math display">\[
\alpha=\arcsin\left(\frac{\Delta y}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\right),~\beta=\arcsin\left(\frac{t_1}{\sqrt{(\Delta x)^2+(\Delta
y)^2}}\right)
\]</span></p>
<p>Then we calibrate <span class="math inline">\(\alpha\)</span> and
<span class="math inline">\(\beta\)</span>:</p>
<p><span class="math display">\[
\hat{\alpha}=\begin{cases}
        \alpha-\pi,~&amp;\Delta x&gt;0\\
        -\alpha,~&amp;\Delta x\le 0
\end{cases},~~~\hat{\beta}=-\beta
\]</span></p>
<p>the addition is the yaw we want: <span
class="math inline">\(\hat{\theta}=\hat{\alpha}+\hat{\beta}\)</span>. To
remedy the issue of overflowing when <span
class="math inline">\(\sqrt{(\Delta x)^2+(\Delta y)^2}\)</span> is
small, we impose an range in which the raw screen offset <span
class="math inline">\(a_x\)</span> is dynamically adjusted and achieve
smooth camera motion.</p>
<p>The camera pitch can be readily computed:</p>
<p><span class="math display">\[\varphi=\arctan\left(\frac{\Delta
z\cos\hat{\theta}}{\Delta x-t_1\sin\hat{\theta}}\right)\]</span></p>
<p>Eventually, we can compute the camera location and rotation. Location
is <span
class="math inline">\(\mathbf{x}+\mathbf{a}+\mathbf{t}_1\)</span>, and
rotation can be set to look at <span
class="math inline">\(\mathbf{b}\)</span>.</p>
<p>Here is a video showcasing this camera with different parameter
values.</p>
<video src="/images/1v1camera/showcase1.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<p>Here is the blueprint I make to implement this camera. It is now a
little out of order and I will make it more readable and extensible in
next sections.</p>
<p>In the main graph, we get camera yaw and pitch, get camera / rotation
and set them in each frame.</p>
<p><img data-src="/images/1v1camera/2.png" /></p>
<p>The <code>GetCameraYawAndPitch</code> function starts with applying
the follow position and look-at position offset. Note that the follow
position offset is based on the follow target's local coordinate.</p>
<p><img data-src="/images/1v1camera/3.png" /></p>
<p>Then, we store temporary variables including <span
class="math inline">\(\Delta X,\Delta Y,\Delta Z\)</span> and <span
class="math inline">\(t_1\)</span>.</p>
<p><img data-src="/images/1v1camera/4.png" /></p>
<p>Last, we compute yaw and pitch, and return them.</p>
<p><img data-src="/images/1v1camera/5.png" /></p>
<p>The <code>GetT1</code> function computes and returns <span
class="math inline">\(t_1\)</span>. We dynamically scale <span
class="math inline">\(a_x\)</span> according to the current
follow-lookat distance (in the XY plane).</p>
<p><img data-src="/images/1v1camera/6.png" /> <img
src="/images/1v1camera/7.png" /></p>
<p>The <code>GetCameraLocation</code> sums up the three components.</p>
<p><img data-src="/images/1v1camera/8.png" /></p>
<p>The <code>GetCameraRotation</code> forces the camera to orient to the
look-at target.</p>
<p><img data-src="/images/1v1camera/9.png" /></p>
<h1 id="finer-control-over-the-screen-space">Finer Control Over The
Screen Space</h1>
<p>To get a finer control of the follow point and look-at point on the
screen space, we would like to introduce three more paramters
<code>Follow Screen Y</code>, <code>Lookat Screen X</code> and
<code>Lookat Screen Y</code> respectively denoting the Y axis screen
position of the follow point, the X axis screen position of the lookat
point and the Y axis screen position of the lookat point. We first talk
about <code>Follow Screen Y</code>.</p>
<h2 id="determining-mathbft_2">Determining <span
class="math inline">\(\mathbf{t}_2\)</span></h2>
<p>Assume <span class="math inline">\(\mathbf{t}_2\)</span> is the
Y-axis offset applied to the camera, <span
class="math inline">\(a_y\in[-0.5,0.5]\)</span> is the value of
<code>Follow Screen Y</code>. When <span
class="math inline">\(a_y=-0.5\)</span>, the follow point lies at the
bottom edge of the screen, and at the top edge when <span
class="math inline">\(a_y=0.5\)</span>. Following what we do for <span
class="math inline">\(\mathbf{t}_1\)</span>, we can easily express <span
class="math inline">\(\mathbf{t}_2\)</span> as:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{t}_2=t_2\begin{pmatrix}
    -\sin\varphi\cos\theta\\
    -\sin\varphi\sin\theta\\
    \cos\varphi
    \end{pmatrix},~~t_2=-\frac{2a_yr}{\text{AspectRatio}}\tan\left(\frac{\text{fov}}{2}\right)
\end{equation}
\]</span></p>
<p>where <span
class="math inline">\(\mathbf{u}=(\sin\varphi\cos\theta,\sin\varphi\sin\theta,-\cos\varphi)^\top\)</span>
is camera's local up vector from the cross product of camera's local
forward vector <span
class="math inline">\(\mathbf{f}=(-\cos\varphi\cos\theta,-\cos\varphi\sin\theta,-\sin\varphi)^\top\)</span>
and camera's local right vector <span
class="math inline">\(\mathbf{r}=(\sin\theta,-\cos\theta,0)^\top\)</span>
(note again UE uses the left-hand rule). <span
class="math inline">\(\text{AspectRatio}\)</span> is camera's aspect
ratio (usually 16:9).</p>
<h2 id="determining-new-varphi-and-theta">Determining new <span
class="math inline">\(\varphi\)</span> and <span
class="math inline">\(\theta\)</span></h2>
<p>Going back to <span class="math inline">\(\eqref{main}\)</span> and
adding <span class="math inline">\(\mathbf{t}_2\)</span>, we have:</p>
<p><span class="math display">\[
\begin{equation}
    \mathbf{b}-\mathbf{a}-\mathbf{x}-\mathbf{t}_1-\mathbf{t}_2=-k\mathbf{x}
\label{eq18}
\end{equation}
\]</span></p>
<p>Then we have:</p>
<p><span class="math display">\[
\begin{align}
    (1-k)r\cos\varphi\cos\theta+t_1\sin\theta-t_2\sin\varphi\cos\theta
&amp;= \Delta x \label{eq19}\\
    (1-k)r\cos\varphi\sin\theta-t_1\cos\theta-t_2\sin\varphi\sin\theta
&amp;= \Delta y \label{eq20}\\
    (1-k)r\sin\varphi+t_2\cos\varphi &amp;= \Delta z \label{eq21}
\end{align}
\]</span></p>
<p>Interestingly, the resulting <span
class="math inline">\(\hat{\theta}\)</span> by combining <span
class="math inline">\(\eqref{eq19}\)</span> and <span
class="math inline">\(\eqref{eq20}\)</span> remains the same as <span
class="math inline">\(\eqref{eq14}\)</span>. So we do not need to change
the way we compute <span
class="math inline">\(\hat{\theta}\)</span>.</p>
<p>For <span class="math inline">\(\varphi\)</span>, it's a little
tricky. First, we rewrite <span
class="math inline">\(\eqref{eq21}\)</span> as <span
class="math inline">\((1-k)r=\frac{\Delta
z-t_2\cos\varphi}{\sin\varphi}\)</span>, we plug it into <span
class="math inline">\(\eqref{eq19}\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
    \frac{\Delta x-t_1\sin\theta}{\cos\theta}=\frac{\Delta
z\cos\varphi-t_2}{\sin\varphi}
\end{equation}
\]</span></p>
<p>This leads to <span class="math inline">\(\Delta
z\cos\varphi-A\sin\varphi=t_2\)</span> (we let <span
class="math inline">\(A=\frac{\Delta
x-t_1\sin\theta}{\cos\theta}\)</span>). We can use the same technique
for computing <span class="math inline">\(\hat{\theta}\)</span> to solve
<span class="math inline">\(\hat{\varphi}\)</span>. That will be:</p>
<p><span class="math display">\[
\small
\begin{equation}
\begin{aligned}
    \varphi &amp;= {\color{cyan}\gamma} - {\color{pink}\tau}\\
    \varphi &amp;= {\color{cyan}\arcsin\left(\frac{\Delta
z}{\sqrt{A^2+(\Delta z)^2}}\right)} -
{\color{pink}\arcsin\left(\frac{t_2}{\sqrt{A^2+(\Delta z)^2}}\right)}
\end{aligned}
\label{eq23}
\end{equation}
\]</span></p>
<p>When <span class="math inline">\(t_2=0\)</span> and with the identity
<span class="math inline">\(\tan(\arcsin(x))=x/\sqrt{1-x^2}\)</span>, we
have <span class="math inline">\(\varphi_{t_2=0}=\pm\frac{\Delta
z\cos\hat{\theta}}{\Delta x-t_1\sin\hat{\theta}}\)</span>. The only
thing left is to determine the real value of <span
class="math inline">\({\color{cyan}\gamma}\)</span> and <span
class="math inline">\({\color{pink}\tau}\)</span>. Through experiment,
we know both signs are negative, which means the final <span
class="math inline">\(\phi\)</span> should be <span
class="math inline">\(-\gamma+\tau\)</span>.</p>
<p>Besides, we also introduce <code>BeginAdaptDistanceY</code> and
<code>EndAdaptDistanceY</code>, in analogy to what we do for
<code>ScreenX</code>, to dynamically scale <span
class="math inline">\(a_y\)</span> when the follow point and the look-at
position is close. In this way, we achieve smooth camera move for both
<code>ScreenX</code> and <code>ScreenY</code>.</p>
<h2 id="but-what-about-the-look-at-position...">But what about the
look-at position...?</h2>
<p>We introduce four new parameters, <span
class="math inline">\(\Theta\)</span>, the yaw angle based on camera's
local space and <span class="math inline">\(b_x=\text{Lookat Screen
X}\)</span>, and <span class="math inline">\(\Phi\)</span>, the pitch
angle based on camera's local space and <span
class="math inline">\(b_y=\text{Lookat Screen Y}\)</span>. We adjust
<span class="math inline">\(\Theta\)</span> and <span
class="math inline">\(\Phi\)</span> (i.e., rotating camera at its own
local coordinate) to accommodate look-at position manupulation on screen
space.</p>
<p>Nonetheless, when biasing the look-at point on screen space, we will
encounter some problems. If we allow for camera rotation at its local
coordinate, the values of <span class="math inline">\(t_1\)</span> and
<span class="math inline">\(t_2\)</span> computed above would be wrong,
because the local orientation of camera can significantly influence the
follow position on screen space. Now that the determination of <span
class="math inline">\(t_1, t_2\)</span> and the determination of
camera's local orientation are entangled, establishing and solving the
equation can be very difficult, particularly for an explicit
solution.</p>
<p>(*: There might be a nice explicit solution, but for now I won't
manage to solve it out. Perhaps for someday in the future I will take a
shot.)</p>
<p>What we gonna do to mitigate this issue is to increment camera
position and orientation, rather than hard-set it at its "correct"
position and orientation. This is exactly what Cinemachine does for
camera motion.</p>
<h1
id="emulate-cinemachine-by-using-incremental-motion-and-adding-damping">Emulate
Cinemachine by using Incremental Motion and Adding Damping</h1>
<p>Our solution is to emulate Cinemachine in Unity through incrementally
changing camera position and rotation. This paradigm also enjoys the
benifit of adding damping easily. To increment camera motion, we only
need to calculate the desired position and rotation, and interpolate
between its current state and its desired state.</p>
<p>Let us go through the process by showing the blueprints.</p>
<h2 id="high-level-workflow-and-the-initialize-function">High-level
workflow and the <code>Initialize</code> function</h2>
<p>The high-level steps are pretty simple: we first determine and set
camera rotation, then set camera position. <code>FirstFrame</code> is a
boolean variable used to indicate whether the current tick is the first
frame during execution. If it is, no damping will be applied.</p>
<p><img data-src="/images/1v1camera/10.png" /></p>
<p>The <code>Initialize</code> function integrates the follow offset and
look-at offset to get the real follow position and lookat position.</p>
<p><img data-src="/images/1v1camera/11.png" /></p>
<h2 id="set-camera-rotation">Set camera rotation</h2>
<p>The <code>Set Camera Rotation</code> function gets the delta rotation
(after damping), and then rotates camera accordingly.</p>
<p><img data-src="/images/1v1camera/12.png" /></p>
<p>Similarly, the <code>Set Camera Position</code> function gets the
delta position (after damping), and then shifts camera in its local
reference frame, not changing camera orientation.</p>
<p><img data-src="/images/1v1camera/13.png" /></p>
<p>The first part of the <code>Get Delta Rotation</code> function
examines whether camera is too close to the look-at target. If it is the
case, the camera will not update its rotation.</p>
<p><img data-src="/images/1v1camera/14.png" /></p>
<p>Then, the second part of <code>Get Delta Rotation</code> computes the
difference between current rotation and the desired rotation, taking the
given look-at screen offset into account.</p>
<p><img data-src="/images/1v1camera/15.png" /></p>
<p>Last, the third part of <code>Get Delta Rotation</code> optionally
applies damping to the difference rotation and returns the damped
result.</p>
<p><img data-src="/images/1v1camera/16.png" /></p>
<p>Going inside the <code>Damp Rotation</code> function, we find it
separately damps each of the rotation component roll, pitch and yaw, all
using the <code>Damper</code> function.</p>
<p><img data-src="/images/1v1camera/17.png" /></p>
<p>The <code>Damper</code> function, however, is a simple exponential
decay operator that leaves a particular negligible residual after
<code>Damp Time</code>. It can be formulated as:</p>
<p><span
class="math display">\[\text{DampedInput}=\text{RawInput}\cdot\left(1-\mathrm{e}^{\ln(k)\frac{\Delta
T}{T}}\right)\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the negligible
residual, say <span class="math inline">\(0.01\)</span>, and <span
class="math inline">\(T\)</span> is the expected damp time.</p>
<p><img data-src="/images/1v1camera/18.png" /></p>
<h2 id="set-camera-position">Set camera position</h2>
<p>The <code>Get Delta Position</code> has a similar workflow. It first
computes the scaled follow screen offset. We have introduced it in the
first section (see <a href="#scale">here</a>).</p>
<p><img data-src="/images/1v1camera/19.png" /></p>
<p>Then, it converts the follow position from world space to camera's
local space. It is a little bit relating to mathematics. Put it simply,
assume the camera's local forward vector is <span
class="math inline">\(\mathbf{f}\)</span>, right vector is <span
class="math inline">\(\mathbf{r}\)</span> and up vector is <span
class="math inline">\(\mathbf{u}\)</span>, and the world space follow
position is <span
class="math inline">\(\mathbf{a}=(x,y,z)^\top\)</span>. The local
coordinate of <span class="math inline">\(\mathbf{a}\)</span> would
be:</p>
<p><span class="math display">\[\mathbf{a}&#39;=\begin{bmatrix}
    \mathbf{f}^\top\\
    \mathbf{r}^\top\\
    \mathbf{u}^\top
\end{bmatrix}\mathbf{a}=\begin{bmatrix}
    \mathbf{f}_x &amp; \mathbf{f}_y &amp; \mathbf{f}_z\\
    \mathbf{r}_x &amp; \mathbf{r}_y &amp; \mathbf{r}_z\\
    \mathbf{u}_x &amp; \mathbf{u}_y &amp; \mathbf{u}_z
\end{bmatrix}\begin{bmatrix}
    x\\
    y\\
    z
\end{bmatrix}\]</span></p>
<p><img data-src="/images/1v1camera/20.png" /></p>
<p>A local space coordiante facilitates computing the difference between
current camera position and desired position. Follow screen offset is
also incorporated.</p>
<p><img data-src="/images/1v1camera/21.png" /></p>
<p>Last, we damp the difference position and returns the result. The
<code>Damp Position</code> function manipulates three
<code>Raw Delta Position</code> components instead of two as we did in
<code>Damp Rotation</code>.</p>
<p><img data-src="/images/1v1camera/22.png" /></p>
<h2 id="result">Result</h2>
<p>OK, let us enjoy our achievements! We can freely play with various
parameters and see how the camera responses. You may notice that only
setting up the follow damping leads to camera jitter, not drastic but
still perceptible. A possible reason for this phenomenon is the unstable
tick rate on my PC. We can, of course, increase the frame rate, but a
more robust solution is to modify our damping algorithm. Rather than
directly use <code>DeltaTime</code> as the damping step size, we can
further split <code>DeltaTime</code> into several sub-delta time steps,
and simulate damping for each time step upon the last simulation,
finally having a much more smooth damping result. This is exactly what
Cinemachine does when <code>DeltaTime</code> is unstable.</p>
<video src="/images/1v1camera/showcase2.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<p>Another potential enhancement is to add the concept of <strong>Soft
Zone</strong>, which defines a rectangular area in screen space where
follow / look-at point is allowed to move around and the rest screen
space where follow / look-at point will never show up in. In other
words, the follow / look-at position is hard restricted in the soft
zone. It provides a more flexible screen space control over our point of
interest.</p>
<p>(*: I've already added soft zone and the improved damping algorithm
in both blueprints and code implementation. Feel free to use and modify
as whatever you like.)</p>
<p><strong>Complementary note</strong></p>
<p>The improved damping algorithm is not difficult to implement. Suppose
we want to split <code>DeltaTime</code> <span
class="math inline">\(\Delta T\)</span> into <span
class="math inline">\(n\)</span> equal sub-parts, each of which is <span
class="math inline">\(\Delta T/n\)</span>. Then the decay factor is
<span class="math inline">\(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\)</span>. The original delta amount is <span
class="math inline">\(I\)</span>, and the split segment will be <span
class="math inline">\(I/n\)</span>. The simulation progressively damps
each segment <span class="math inline">\(I/n\)</span> using the decay
factor <span class="math inline">\(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\)</span>.</p>
<p>In the first iteration, the residual is <span
class="math inline">\(\frac{I}{n}\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\)</span>, or the actor traverses <span
class="math inline">\(\frac{I}{n}(1-\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}})\)</span> in other words. In the second iteration, the residual
will be:</p>
<p><span
class="math display">\[\left(\frac{I}{n}\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}+\frac{I}{n}\right)\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}=\frac{I}{n}\left(\left(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)^2+\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)\]</span></p>
<p>This process terminates until the last <span
class="math inline">\(n\)</span>-th iteration, where the final residual
will be:</p>
<p><span
class="math display">\[\frac{I}{n}\left(\left(\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)^n+\cdots+\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}\right)=\frac{I}{n}\cdot\frac{\mathrm{e}^{\ln(k)\frac{\Delta
T}{nT}}(1-\mathrm{e}^{\ln(k)\frac{\Delta
T}{T}})}{1-\mathrm{e}^{\ln(k)\frac{\Delta T}{nT}}}\]</span></p>
<p>Compared with the original residual without multi-step simulation
<span class="math inline">\(I\cdot \mathrm{e}^{\ln(k)\frac{\Delta
T}{T}}\)</span>, the simulated result will almost always be larger than
the non-simulated conterpart, implying that the actor moves less within
duration <span class="math inline">\(\Delta T\)</span>. This makes the
actor behave more smooth under deltatime variability.</p>
<h1 id="code">Code</h1>
<p>Our last step is to code-implement the Cinemachine-like 1v1 camera
system. It is not hard but as we want a more practical, robust and
extensible camera system, we would like to organize the code in a more
systematical way. Cinemachine makes a great example (thank you,
Cinemachine).</p>
<h2 id="code-framework">Code framework</h2>
<p>The overall code framework can be simply illustrated using the
following class diagram:</p>
<pre class="mermaid">
classDiagram
class AMECameraBase { 
    USceneComponent* SceneRootComponent
    UMECameraSettingsComponent* MainMECameraComponent
    UCameraComponent* MainCamera
    UMECameraSettingsComponent* GetSettingsComponent()
    UCameraComponent* GetCameraComponent()
}
AMECameraBase --&gt; AActor : Inherit
UMECameraLibrary --&gt; UBlueprintFunctionLibrary : Inherit
class UMECameraLibrary {
    static void DamperValue(EDampMethod DampMethod, const float&amp; DeltaSeconds, const float&amp; Input, float DampTime, double&amp; Output, float Residual &#x3D; 0.01)
    static void DamperVectorWithSameDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FVector&amp; Input, float DampTime, FVector&amp; Output, float Residual &#x3D; 0.01)
    static void DamperVectorWithDifferentDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FVector&amp; Input, FVector DampTime, FVector&amp; Output, float Residual &#x3D; 0.01)
    static void DamperRotatorWithSameDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FRotator&amp; Input, float DampTime, FRotator&amp; Output, float Residual &#x3D; 0.01)
    static void DamperRotatorWithDifferentDampTime(EDampMethod DampMethod, const float&amp; DeltaSeconds, const FRotator&amp; Input, FVector DampTime, FRotator&amp; Output, float Residual &#x3D; 0.01)
    static AMECameraBase* CallCamera(TSubclassOf&lt;AMECameraBase&gt; CameraClass, AActor* FollowTarget, AActor* AimTarget, float BlendTime, enum EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
}
</pre>
<pre class="mermaid">
classDiagram
class UMECameraComponentBase {
    EStage Stage
    AActor* OwningActor
    UMECameraSettingsComponent* OwningSettingComponent
    UCameraComponent* OwningCamera
    virtual void UpdateComponent(float DeltaTime)
}
UMECameraComponentBase &lt;-- UMECameraComponentFollow : Inherit
UMECameraComponentBase &lt;-- UMECameraComponentAim : Inherit
class UMECameraComponentFollow {
    TObjectPtr~AActor~ FollowTarget
    virtual void UpdateComponent(float DeltaTime) override
}
class UMECameraComponentAim {
    TObjectPtr~AActor~ AimTarget
    virtual void UpdateComponent(float DeltaTime) override
}
UMECameraComponentFollow &lt;-- UFramingFollow : Inherit
class UFramingFollow {
    float CameraDistance
    FVector FollowOffset
    EDampMethod DampMethod
    float DampResidual
    FVector FollowDamping
    FVector2f ScreenOffset
    FVector2f AdaptiveScreenOffsetDistanceX
    FVector2f AdaptiveScreenOffsetDistanceY
    FVector2f ScreenOffsetWidth
    FVector2f ScreenOffsetHeight
    virtual void UpdateComponent(float DeltaTime) override
}
UMECameraComponentAim &lt;-- UTargetingAim : Inherit
class UTargetingAim {
    FVector AimOffset
    EDampMethod DampMethod
    float DampResidual
    FVector AimDamping
    FVector2f ScreenOffset
    FVector2f ScreenOffsetWidth
    FVector2f ScreenOffsetHeight
    virtual void UpdateComponent(float DeltaTime) override
}
UMECameraComponentFollow &lt;-- USimpleFollow : Inherit
UMECameraComponentFollow &lt;-- UOrbitFollow : Inherit
UMECameraComponentFollow &lt;-- UHardLockFollow : Inherit
UMECameraComponentAim &lt;-- UPlayerControlAim : Inherit
UMECameraComponentAim &lt;-- UGroupTargetingAim : Inherit
UMECameraComponentAim &lt;-- UHardLockAim : Inherit
</pre>
<pre class="mermaid">
classDiagram
USceneComponent &lt;-- UMECameraSettingsComponent : Inherit
class UMECameraSettingsComponent {
    TObjectPtr~UMECameraComponentFollow~ FollowComponent
    TObjectPtr ~UMECameraComponentAim~ AimComponent
    TArray~UMECameraExtensionBase*~ Extensions
    TArray~UMECameraComponentBase*~ ComponentContainer
	TObjectPtr~AActor~ FollowTarget
	TObjectPtr~AActor~ AimTarget
    AActor* SetFollowTarget(AActor* NewFollowTarget)
    void UpdateFollowTarget(AActor* NewFollowTarget)
    AActor* GetFollowTarget() const
    AActor* SetAimTarget(AActor* NewAimTarget)
    void UpdateAimTarget(AActor* NewAimTarget)
    AActor* GetAimTarget() const
    virtual void InitializeMECameraComponents()
    virtual void InitializeMECameraComponent(UMECameraComponentBase* Component)
    virtual void PostEditChangeProperty(FPropertyChangedEvent&amp; PropertyChangedEvent) override
}
</pre>
<h2 id="implementing-framingfollow">Implementing
<code>FramingFollow</code></h2>
<p><code>FramingFollow</code> is akin to <code>Framing Transposer</code>
in Cinemachine. Here is my simple-to-understand implementation:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFramingFollow::UpdateComponent</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">UpdateComponent</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FollowTarget != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		FVector FollowPosition = <span class="built_in">GetRealFollowPosition</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Get real screen offset. */</span></span><br><span class="line">		FVector AimPosition = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		FVector2f RealScreenOffset = <span class="built_in">FVector2f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetOwningSettingComponent</span>()-&gt;<span class="built_in">GetAimComponent</span>() != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">GetOwningSettingComponent</span>()-&gt;<span class="built_in">GetAimComponent</span>()-&gt;<span class="built_in">GetAimTarget</span>() != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			AimPosition = <span class="built_in">GetOwningSettingComponent</span>()-&gt;<span class="built_in">GetAimComponent</span>()-&gt;<span class="built_in">GetRealAimPosition</span>();</span><br><span class="line">			RealScreenOffset = <span class="built_in">GetAdaptiveScreenOffset</span>(FollowPosition, AimPosition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> RealScreenOffset = ScreenOffset;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Transform from world space to local space. */</span></span><br><span class="line">		FVector LocalSpaceFollowPosition = <span class="built_in">GetLocalSpacePosition</span>(FollowPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Temporary (before damping) delta position. */</span></span><br><span class="line">		FVector TempDeltaPosition = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** First move the camera along the local space X axis. */</span></span><br><span class="line">		<span class="built_in">SetForwardDelta</span>(LocalSpaceFollowPosition, TempDeltaPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Then move the camera along the local space YZ plane. */</span></span><br><span class="line">		<span class="type">float</span> W = <span class="built_in">SetYZPlaneDelta</span>(LocalSpaceFollowPosition, TempDeltaPosition, RealScreenOffset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Get damped delta position. */</span></span><br><span class="line">		FVector DampedDeltaPosition = <span class="built_in">DampDeltaPosition</span>(LocalSpaceFollowPosition, TempDeltaPosition, DeltaTime, RealScreenOffset, W);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Apply damped delta position. */</span></span><br><span class="line">		<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">AddActorLocalOffset</span>(DampedDeltaPosition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector <span class="title">UFramingFollow::GetRealFollowPosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector ActorLocation = FollowTarget-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">	FRotator ActorRotation = FollowTarget-&gt;<span class="built_in">GetActorRotation</span>();</span><br><span class="line">	FVector LocalOffset = UKismetMathLibrary::<span class="built_in">GreaterGreater_VectorRotator</span>(FollowOffset, ActorRotation);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ActorLocation + LocalOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector2f <span class="title">UFramingFollow::GetAdaptiveScreenOffset</span><span class="params">(<span class="type">const</span> FVector&amp; FollowPosition, <span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector Diff = FollowPosition - AimPosition;</span><br><span class="line">	<span class="type">float</span> ProjectedDistance = FMath::<span class="built_in">Sqrt</span>(FMath::<span class="built_in">Square</span>(Diff.X) + FMath::<span class="built_in">Square</span>(Diff.Y));</span><br><span class="line"></span><br><span class="line">	FVector2f OutRange = <span class="built_in">FVector2f</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	FVector2f RealScreenOffset;</span><br><span class="line">	RealScreenOffset.X = ScreenOffset.X * FMath::<span class="built_in">GetMappedRangeValueClamped</span>(AdaptiveScreenOffsetDistanceX, OutRange, ProjectedDistance);</span><br><span class="line">	RealScreenOffset.Y = ScreenOffset.Y * FMath::<span class="built_in">GetMappedRangeValueClamped</span>(AdaptiveScreenOffsetDistanceY, OutRange, ProjectedDistance);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RealScreenOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector <span class="title">UFramingFollow::GetLocalSpacePosition</span><span class="params">(<span class="type">const</span> FVector&amp; FollowPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector Diff = FollowPosition - <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line"></span><br><span class="line">	FVector ForwardVector = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorForwardVector</span>();</span><br><span class="line">	FVector RightVector = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorRightVector</span>();</span><br><span class="line">	FVector UpVector = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorUpVector</span>();</span><br><span class="line"></span><br><span class="line">	FVector LocalSpaceFollowPosition =</span><br><span class="line">		UKismetMathLibrary::<span class="built_in">MakeVector</span>(ForwardVector.X, RightVector.X, UpVector.X) * Diff.X +</span><br><span class="line">		UKismetMathLibrary::<span class="built_in">MakeVector</span>(ForwardVector.Y, RightVector.Y, UpVector.Y) * Diff.Y +</span><br><span class="line">		UKismetMathLibrary::<span class="built_in">MakeVector</span>(ForwardVector.Z, RightVector.Z, UpVector.Z) * Diff.Z;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> LocalSpaceFollowPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFramingFollow::SetForwardDelta</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, FVector&amp; TempDeltaPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TempDeltaPosition.X = LocalSpaceFollowPosition.X - CameraDistance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">UFramingFollow::SetYZPlaneDelta</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, FVector&amp; TempDeltaPosition, <span class="type">const</span> FVector2f&amp; RealScreenOffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> W = UKismetMathLibrary::<span class="built_in">DegTan</span>(<span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView / <span class="number">2.0f</span>) * CameraDistance * <span class="number">2.0f</span>;</span><br><span class="line">	<span class="type">float</span> ExpectedPositionY = W * RealScreenOffset.X;</span><br><span class="line">	<span class="type">float</span> ExpectedPositionZ = W / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio * RealScreenOffset.Y;</span><br><span class="line"></span><br><span class="line">	TempDeltaPosition.Y = LocalSpaceFollowPosition.Y - ExpectedPositionY;</span><br><span class="line">	TempDeltaPosition.Z = LocalSpaceFollowPosition.Z - ExpectedPositionZ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FVector <span class="title">UFramingFollow::DampDeltaPosition</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, <span class="type">const</span> FVector&amp; TempDeltaPosition, <span class="type">float</span> DeltaTime, <span class="type">const</span> FVector2f&amp; RealScreenOffset, <span class="type">float</span>&amp; W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FVector DampedDeltaPosition = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	UMECameraLibrary::<span class="built_in">DamperVectorWithDifferentDampTime</span>(DampMethod, DeltaTime, TempDeltaPosition, FollowDamping, DampedDeltaPosition, DampResidual);</span><br><span class="line">	<span class="built_in">EnsureWithinBounds</span>(LocalSpaceFollowPosition, DampedDeltaPosition, RealScreenOffset, W);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DampedDeltaPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFramingFollow::EnsureWithinBounds</span><span class="params">(<span class="type">const</span> FVector&amp; LocalSpaceFollowPosition, FVector&amp; DampedDeltaPosition, <span class="type">const</span> FVector2f&amp; RealScreenOffset, <span class="type">float</span>&amp; W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> LeftBound = (RealScreenOffset.X + ScreenOffsetWidth.X) * W;</span><br><span class="line">	<span class="type">float</span> RightBound = (RealScreenOffset.X + ScreenOffsetWidth.Y) * W;</span><br><span class="line">	<span class="type">float</span> BottomBound = (RealScreenOffset.Y + ScreenOffsetHeight.X) * W / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio;</span><br><span class="line">	<span class="type">float</span> TopBound = (RealScreenOffset.Y + ScreenOffsetHeight.Y) * W / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio;</span><br><span class="line"></span><br><span class="line">	FVector ResultLocalSpacePosition = LocalSpaceFollowPosition - DampedDeltaPosition;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Y &lt; LeftBound)   DampedDeltaPosition.Y += ResultLocalSpacePosition.Y - LeftBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Y &gt; RightBound)  DampedDeltaPosition.Y += ResultLocalSpacePosition.Y - RightBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Z &lt; BottomBound) DampedDeltaPosition.Z += ResultLocalSpacePosition.Z - BottomBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultLocalSpacePosition.Z &gt; TopBound)    DampedDeltaPosition.Z += ResultLocalSpacePosition.Z - TopBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="implementing-targetingaim">Implementing
<code>TargetingAim</code></h2>
<p><code>TargetingAim</code> serves the same function as
<code>Composer</code> in Cinemachine. It only sets the camera rotation
and keeps the aim target at a fixed position on screen. Here is the
implementation:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetingAim::UpdateComponent</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">UpdateComponent</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (AimTarget != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/** Get the *real* aim position, based on actor&#x27;s local space. */</span></span><br><span class="line">		FVector AimPosition = <span class="built_in">GetRealAimPosition</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** If camera is too close to aim target, return. */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">CheckIfTooClose</span>(AimPosition)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Temporary delta rotation before damping. */</span></span><br><span class="line">		FRotator TempDeltaRotation = <span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Set delta rotation. */</span></span><br><span class="line">		<span class="built_in">SetDeltaRotation</span>(AimPosition, TempDeltaRotation);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Get damped delta rotation. */</span></span><br><span class="line">		FRotator DampedDeltaRotation = <span class="built_in">DampDeltaRotation</span>(TempDeltaRotation, DeltaTime, AimPosition);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Apply damped delta rotation. */</span></span><br><span class="line">        <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">AddActorLocalRotation</span>(<span class="built_in">FRotator</span>(DampedDeltaRotation.Pitch, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">AddActorWorldRotation</span>(<span class="built_in">FRotator</span>(<span class="number">0</span>, DampedDeltaRotation.Yaw, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UTargetingAim::CheckIfTooClose</span><span class="params">(<span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> Distance = UKismetMathLibrary::<span class="built_in">Vector_Distance</span>(<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>(), AimPosition);</span><br><span class="line">	<span class="keyword">return</span> UKismetMathLibrary::<span class="built_in">NearlyEqual_FloatFloat</span>(Distance, <span class="number">0</span>, <span class="number">0.001</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetingAim::SetDeltaRotation</span><span class="params">(<span class="type">const</span> FVector&amp; AimPosition, FRotator&amp; TempDeltaRotation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRotator CenteredDeltaRotation = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(UKismetMathLibrary::<span class="built_in">FindLookAtRotation</span>(<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>(), AimPosition), <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorRotation</span>());</span><br><span class="line">    TempDeltaRotation.Yaw = CenteredDeltaRotation.Yaw - ScreenOffset.X * <span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView;</span><br><span class="line">    TempDeltaRotation.Pitch = CenteredDeltaRotation.Pitch - ScreenOffset.Y * <span class="number">2.0f</span> * UKismetMathLibrary::<span class="built_in">DegAtan</span>(UKismetMathLibrary::<span class="built_in">DegTan</span>(<span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView / <span class="number">2</span>) / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio);</span><br><span class="line">    TempDeltaRotation.Roll = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FRotator <span class="title">UTargetingAim::DampDeltaRotation</span><span class="params">(<span class="type">const</span> FRotator&amp; TempDeltaRotation, <span class="type">float</span> DeltaTime, <span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FRotator DampedDeltaRotation = <span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	UMECameraLibrary::<span class="built_in">DamperRotatorWithDifferentDampTime</span>(DampMethod, DeltaTime, TempDeltaRotation, AimDamping, DampedDeltaRotation, DampResidual);</span><br><span class="line">	<span class="built_in">EnsureWithinBounds</span>(DampedDeltaRotation, AimPosition);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DampedDeltaRotation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetingAim::EnsureWithinBounds</span><span class="params">(FRotator&amp; DampedDeltaRotation, <span class="type">const</span> FVector&amp; AimPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> VFieldOfView = <span class="number">2.0f</span> * UKismetMathLibrary::<span class="built_in">DegAtan</span>(UKismetMathLibrary::<span class="built_in">DegTan</span>(<span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView / <span class="number">2</span>) / <span class="built_in">GetOwningCamera</span>()-&gt;AspectRatio);</span><br><span class="line">	<span class="type">double</span> LeftBound = (ScreenOffset.X + ScreenOffsetWidth.X) * <span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView;</span><br><span class="line">	<span class="type">double</span> RightBound = (ScreenOffset.X + ScreenOffsetWidth.Y) * <span class="built_in">GetOwningCamera</span>()-&gt;FieldOfView;</span><br><span class="line">	<span class="type">double</span> BottomBound = (ScreenOffset.Y + ScreenOffsetHeight.X) * VFieldOfView;</span><br><span class="line">	<span class="type">double</span> TopBound = (ScreenOffset.Y + ScreenOffsetHeight.Y) * VFieldOfView;</span><br><span class="line"></span><br><span class="line">	FQuat DesiredQuat = <span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorRotation</span>().<span class="built_in">Quaternion</span>();</span><br><span class="line">	DesiredQuat = <span class="built_in">FQuat</span>(<span class="built_in">FRotator</span>(<span class="number">0</span>, DampedDeltaRotation.Yaw, <span class="number">0</span>)) * DesiredQuat * <span class="built_in">FQuat</span>(<span class="built_in">FRotator</span>(DampedDeltaRotation.Pitch, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	FRotator DesiredRotation = DesiredQuat.<span class="built_in">Rotator</span>();</span><br><span class="line"></span><br><span class="line">	FRotator ResultRotationDiff = UKismetMathLibrary::<span class="built_in">NormalizedDeltaRotator</span>(UKismetMathLibrary::<span class="built_in">FindLookAtRotation</span>(<span class="built_in">GetOwningActor</span>()-&gt;<span class="built_in">GetActorLocation</span>(), AimPosition), DesiredRotation);</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Yaw &lt; LeftBound) DampedDeltaRotation.Yaw += ResultRotationDiff.Yaw - LeftBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Yaw &gt; RightBound) DampedDeltaRotation.Yaw += ResultRotationDiff.Yaw - RightBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Pitch &lt; BottomBound) DampedDeltaRotation.Pitch += ResultRotationDiff.Pitch - BottomBound;</span><br><span class="line">	<span class="keyword">if</span> (ResultRotationDiff.Pitch &gt; TopBound) DampedDeltaRotation.Pitch += ResultRotationDiff.Pitch - TopBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="use-in-unreal-engine">Use in Unreal Engine</h2>
<p>Use in UE is really simple. What you need to do is:</p>
<ul>
<li>Create a new blueprint class inherited from MECameraBase;</li>
<li>Set up the parameters in the CameraSettingsComponent component,
e.g., set the <code>FollowComponent</code> as <code>FramingFollow</code>
and <code>AimComponent</code> as <code>TargetingAim</code>;</li>
<li>Use the <code>CallCamera</code> node in blueprint to instantiate an
actor of the blueprint class you just created.</li>
</ul>
]]></content>
      <categories>
        <category>游戏 - 相机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>UE</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>The Jittering Issue with Damping in Cinemachine and How to Tackle it</title>
    <url>/2023/07/08/18/22/</url>
    <content><![CDATA[<p>If you are familiar with Cinemachine. you probably know there is a
knotty problem with Cinemachine' damping if you are using
<code>Framing Transposer</code> or some other components to track a
follow point. That is, the camera jitters with damping enabled under
unstable frame rate. The more unstable frame rate is, the more heavily
camera will jitter. This post will discuss this phenomenon and proposes
a workaround to solve this issue.</p>
<span id="more"></span>
<h1 id="camera-jitters-with-damping-in-cinemachine">Camera jitters with
damping in Cinemachine</h1>
<p>Unity's Cinemachine has a notoriously severe problem that may cause
the follow object to seemingly jitter when you are using the
<code>Framing Transposer</code> component with damping enabled.</p>
<p>To show this, I did a simple experiment. I created a new blank scene
and spawned a new attached with the following script:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> fps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> CurrentSpeed</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> currentSpeed; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> elapsedTime = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fps != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Application.targetFrameRate = fps;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentSpeed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        elapsedTime += Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elapsedTime &gt;= <span class="number">5.0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentSpeed &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                currentSpeed = <span class="number">0.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentSpeed = speed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            elapsedTime = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transform.position += <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) * currentSpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This script moves the cube for 5 seconds and then keeps it steady for
another 5 seconds and continues moving. The move <code>speed</code> as
well as the <code>fps</code> (frames per second) can be set for test
under different conditions.</p>
<p>A new virtual camera is then created with a
<code>Framing Transposer</code> component following this cube. A default
damping of 0.2 is used.</p>
<p>Here is result with <code>speed</code> is 100 and <code>fps</code> is
0 (when set to 0, the real fps is determined by Unity, may but
unstable).</p>
<p><img data-src="/images/improvingdamping/gif-1.gif" width="900" height="450"/></p>
<p>The jitters are very clear. You can also notice that the frame rate
(presented in the Statistics panel) is very unstable, and we will know
soon it is the unstable fps that results in camera jitters.</p>
<p>Cinemachine proposes a workaround to alleviate this problem, that is,
to use the revised version of damping where they sub-divide each frame
and simulates damping in the consecutive series of sub-frames. To enable
this functionality, go to Edit -&gt; Project Settings -&gt; Player -&gt;
Script Compilation and add the
<code>CINEMACHINE_EXPERIMENTAL_DAMPING</code> marco to it.</p>
<p><img data-src="/images/improvingdamping/pic-1.png" /></p>
<p>OKay, now we have enabled the new damping algorithm and let's see how
it will mitigate the jittering issue. Here is result with the same
setting we used in our previous experiment, i.e., <code>speed</code> is
100 and <code>fps</code> is 0.</p>
<p><img data-src="/images/improvingdamping/gif-2.gif" width="900" height="450"/></p>
<p>It is astonishing to see the jittering issue becomes even more
severe. I conjecture that the variance of fps will significantly amplify
camera jitters when this feature is enabled. In other words, the
experimental damping algorithm responds to the variance of fps in a
NON-linear way: when the variance is small, the experiment damping will
reduce the gaps of camera location between contiguous frames; but when
the variance is large, it will enlarge the gaps, leading to unacceptable
jittering. (Note: I did not validate this conjecture. If you are
interested, just review the code and test it yourself.)</p>
<p>What about the expected result if fps is stable? Let's take more
experiments!</p>
<p>Here is result with <code>speed</code> is 100 and <code>fps</code> is
120 (very high fps, which is usually prohibitive in shipped games).</p>
<p><img data-src="/images/improvingdamping/gif-3.gif" width="900" height="450"/></p>
<p>Very steady camera! What about setting fps to <code>60</code>? Here
is the result.</p>
<p><img data-src="/images/improvingdamping/gif-4.gif" width="900" height="450"/></p>
<p>An fps of 60 performs equally well with 120, which is anticipated as
fps is stable. Okay, let's try a final experiment where fps is set at an
extreme value of 20.</p>
<p><img data-src="/images/improvingdamping/gif-5.gif" width="900" height="450"/></p>
<p>Even a low fps of 20 makes our camera stable, only if fps itself is
stable.</p>
<p>Now we can conclude that it is the instability of fps that induces
camera jitters, regardless of the exact value of fps. But, why?</p>
<h1 id="why-camera-jitters">Why camera jitters</h1>
<p>Before answering this question, let us first take a look at the
source of damping implemented in Cinemachine.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Damp</span>(<span class="params"><span class="built_in">float</span> initial, <span class="built_in">float</span> dampTime, <span class="built_in">float</span> deltaTime</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dampTime &lt; Epsilon || Mathf.Abs(initial) &lt; Epsilon)</span><br><span class="line">        <span class="keyword">return</span> initial;</span><br><span class="line">    <span class="keyword">if</span> (deltaTime &lt; Epsilon)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">float</span> kNegligibleResidual = <span class="number">0.01f</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">float</span> kLogNegligibleResidual = <span class="number">-4.605170186f</span>; <span class="comment">// == math.Log(kNegligibleResidual=0.01f);</span></span><br><span class="line">    <span class="built_in">float</span> k = -kLogNegligibleResidual / dampTime; <span class="comment">//DecayConstant(dampTime, kNegligibleResidual);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CINEMACHINE_EXPERIMENTAL_DAMPING</span></span><br><span class="line">    <span class="comment">// Try to reduce damage caused by frametime variability</span></span><br><span class="line">    <span class="built_in">float</span> step = Time.fixedDeltaTime;</span><br><span class="line">    <span class="keyword">if</span> (deltaTime != step)</span><br><span class="line">        step /= <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">int</span> numSteps = Mathf.FloorToInt(deltaTime / step);</span><br><span class="line">    <span class="built_in">float</span> vel = initial * step / deltaTime;</span><br><span class="line">    <span class="built_in">float</span> decayConstant = Mathf.Exp(-k * step);</span><br><span class="line">    <span class="built_in">float</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numSteps; ++i)</span><br><span class="line">        r = (r + vel) * decayConstant;</span><br><span class="line">    <span class="built_in">float</span> d = deltaTime - (step * numSteps);</span><br><span class="line">    <span class="keyword">if</span> (d &gt; Epsilon)</span><br><span class="line">        r = Mathf.Lerp(r, (r + vel) * decayConstant, d / step);</span><br><span class="line">    <span class="keyword">return</span> initial - r;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> initial * (<span class="number">1</span> - Mathf.Exp(-k * deltaTime));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Translating into mathematics, we have:</p>
<p><span
class="math display">\[\ell_\text{Damp}=\ell_\text{Input}\cdot\left(1-\exp\left(\ln(0.01)\frac{\Delta
T}{T}\right)\right)\]</span></p>
<p>where <span class="math inline">\(T\)</span> is the damp time
parameter and <span class="math inline">\(\Delta T\)</span> the elapsed
time in this frame. This equation decays the input <span
class="math inline">\(\ell_\text{input}\)</span>, the distance for the
camera to go to the desired position, by an exponential factor <span
class="math inline">\(\exp\left(\ln(0.01)\frac{\Delta
T}{T}\right)\)</span>. If <span class="math inline">\(\Delta
T=T\)</span>, the residual will be <span
class="math inline">\(0.01\ell_\text{input}\)</span>, meaning that at
this frame, the camera will traverse 99% of the desired distance to go,
only remaining 1% amount for future frames.</p>
<p>OK, let's assume we've placed a cube in the origin and it moves along
the x-axis at a fixed speed, say, <span class="math inline">\(v\)</span>
m/s. A camera is placed to track the cube with damping where damp time
<span class="math inline">\(T\not=0\)</span>. Let's further denote the
delta time for each frame by <span class="math inline">\(\Delta
T^{(k)}\)</span>, where <span class="math inline">\(k=0, 1, 2,
\cdots\)</span> is the <span class="math inline">\(k\)</span>-th
frame.</p>
<p>Having all variables fully prepared, we can then simulate the object
movement and camera track process.</p>
<p>In the beginning of 0-th frame, the camera and the cube are both at
the origin, i.e., (0, 0, 0). As the cube only moves along x-axis, we can
emit the y and z dimensions and use a one-dimensional coordiante to
represent cube and camera positions.</p>
<p>At the 1-th frame, the cube moves to <span
class="math inline">\(P^{(1)}=P^{(0\to1)}=v\Delta T^{(1)}\)</span>, the
distance the camera traverses is <span
class="math inline">\(Q^{(1)}=P^{(0\to1)}\left(1-\mathrm{e}^{m\frac{\Delta
T^{(1)}}{T}}\right)\)</span>, and the residual is <span
class="math inline">\(R^{(1)}=P^{(0\to1)}\mathrm{e}^{m\frac{\Delta
T^{(1)}}{T}}\)</span>. We set <span
class="math inline">\(m=\ln(0.01)\)</span> for simplicity.</p>
<p>At the 2-th frame, the cube moves to <span
class="math inline">\(P^{(2)}=P^{(0\to1)}+P^{(1\to2)}=v\Delta
T^{(1)}+v\Delta T^{(2)}\)</span>, the distance the camera traverses is
<span
class="math inline">\(Q^{(2)}=(R^{(1)}+P^{(1\to2)})\left(1-\mathrm{e}^{m\frac{\Delta
T^{(2)}}{T}}\right)\)</span>, and the residual is <span
class="math inline">\(R^{(2)}=(R^{(1)}+P^{(1\to2)})\mathrm{e}^{m\frac{\Delta
T^{(2)}}{T}}\)</span>.</p>
<p>At the k-th frame, we have <span
class="math inline">\(P^{(k)}=v\sum_{i=1}^k\Delta T^{(i)}\)</span>,
<span class="math inline">\(Q^{(k)}=(R^{(k-1)}+P^{((k-1)\to
k)})\left(1-\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}}\right)\)</span>, and
<span class="math inline">\(R^{(k)}=(R^{(k-1)}+P^{((k-1)\to
k)})\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}}\)</span>.</p>
<p>Without loss of generality, we can set <span
class="math inline">\(v=1\)</span>. The following sections will use this
settings unless otherwise stated.</p>
<p>For different combinations of <span class="math inline">\(\Delta
T^{(i)}\)</span>, <span class="math inline">\(P^{(k)}, Q^{(k)},
R^{(k)}\)</span> may have different results. Let's dive into <span
class="math inline">\(\Delta T^{(i)}\)</span> and see how it influences
the results.</p>
<h2 id="case-1-stable-fps-all-delta-ti-are-equal">Case 1: Stable FPS,
all <span class="math inline">\(\Delta T^{(i)}\)</span> are equal</h2>
<p>When all <span class="math inline">\(\Delta T^{(i)}\)</span> are
equal, say <span class="math inline">\(\Delta T\)</span>, our equations
reduce to:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
P^{((k-1)\to k)}&amp;=\Delta T\\
P^{(k)}&amp;=k\Delta T\\
R^{(k)}&amp;=\Delta T\cdot\frac{\mathrm{e}^{m\frac{\Delta
T}{T}}}{1-\mathrm{e}^{m\frac{\Delta
T}{T}}}\cdot\left(1-\left(\mathrm{e}^{m\frac{\Delta
T}{T}}\right)^{k+1}\right)\\
Q^{(k)}&amp;=\Delta T\cdot\left(1-\left(\mathrm{e}^{m\frac{\Delta
T}{T}}\right)^{k+1}\right)
\end{aligned}
\end{equation}
\]</span></p>
<p><span class="math inline">\(R^{(k)}\)</span> apparently has a
limitation of <span class="math inline">\(\mathfrak{R}=\Delta
T\cdot\mathrm{e}^{m\frac{\Delta T}{T}}/(1-\mathrm{e}^{m\frac{\Delta
T}{T}})\)</span> when <span class="math inline">\(k\to\infty\)</span>
since <span class="math inline">\(m=\ln(0.01)&lt;0\)</span>. This
explains why a camera with damping always has a maximum distance to its
following target. There maximum distance, also the supremum, is exactly
<span class="math inline">\(\mathfrak{R}\)</span>. When <span
class="math inline">\(T\)</span> is larger, <span
class="math inline">\(\mathfrak{R}\)</span> will be larger, implying the
maximum distance between the camera and its following target will be
larger.</p>
<p>What if <span class="math inline">\(\Delta T^{(i)}\)</span> is
mutable? In this case, we can assume there exists an upper bound <span
class="math inline">\(\Delta T\)</span> such that all <span
class="math inline">\(\Delta T^{(i)}\)</span> satisty <span
class="math inline">\(|\Delta T^{(i)}|\le \Delta T\)</span>. Then we are
able to derive the same conclusion.</p>
<p>Another question is, why camera does not jitter when FPS is stable?
We turn to examine the sign of <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R^{(k)}-R^{(k-1)}&amp;=\Delta T\cdot\frac{\mathrm{e}^{m\frac{\Delta
T}{T}}}{1-\mathrm{e}^{m\frac{\Delta
T}{T}}}\cdot\left(1-\left(\mathrm{e}^{m\frac{\Delta
T}{T}}\right)^{k+1}\right) - \Delta
T\cdot\frac{\mathrm{e}^{m\frac{\Delta
T}{T}}}{1-\mathrm{e}^{m\frac{\Delta
T}{T}}}\cdot\left(1-\left(\mathrm{e}^{m\frac{\Delta
T}{T}}\right)^{k}\right)\\
&amp;=\Delta T\cdot\frac{\mathrm{e}^{m\frac{\Delta
T}{T}}}{1-\mathrm{e}^{m\frac{\Delta
T}{T}}}\left(\mathrm{e}^{m\frac{\Delta
T}{T}}\right)^k\left(1-\mathrm{e}^{m\frac{\Delta T}{T}}\right)\\
&amp;=\Delta T\cdot \left(\mathrm{e}^{m\frac{\Delta
T}{T}}\right)^{k+1}\\
&amp;&gt;0
\end{aligned}
\end{equation}
\]</span></p>
<p>Therefore, when FPS is stable, <span
class="math inline">\(R^{(k)}\)</span> is always larger than <span
class="math inline">\(R^{(k-1)}\)</span>, and jitter will never
happen.</p>
<h2 id="case-2-unstable-fps-delta-ti-vary">Case 2: Unstable FPS, <span
class="math inline">\(\Delta T^{(i)}\)</span> vary</h2>
<p>When FPS is unstable, where <span class="math inline">\(\Delta
T^{(i)}\)</span> may mutate, how will the camera move in response to its
following target? We can still examine the sign of <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span>, but in another
way:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R^{(k)}-R^{(k-1)}&amp;=(R^{(k-1)}+P^{((k-1)\to
k)})\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}}-R^{(k-1)}\\
&amp;=P^{((k-1)\to k)}\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}} -
R^{(k-1)}\left(1-\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}}\right)
\end{aligned}
\end{equation}
\]</span></p>
<p>This equation uncovers why camera jitters happen with unstable FPS.
The residual at the k-th frame <span
class="math inline">\(R^{(k)}\)</span> is essentially an interpolation
between the following target's current position increment <span
class="math inline">\(P^{((k-1)\to k)}\)</span> and the last frame's
negative residual <span class="math inline">\(-R^{(k-1)}\)</span>, where
the interpolation strength is the decaying factor <span
class="math inline">\(\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}}\)</span>.
As both <span class="math inline">\(P^{((k-1)\to k)}\)</span> and <span
class="math inline">\(-R^{(k-1)}\)</span> are fixed, a change in <span
class="math inline">\(\Delta T^{(k)}\)</span> will incline the resulting
residual <span class="math inline">\(R^{(k)}\)</span> to different ends,
either <span class="math inline">\(P^{((k-1)\to k)}\)</span> or <span
class="math inline">\(-R^{(k-1)}\)</span>.</p>
<p>In our simplified case in which the target moves at a fixed speed in
the direction of x-axis, <span class="math inline">\(P^{((k-1)\to
k)}\)</span> will always be positive (though its magnitude can vary) and
<span class="math inline">\(-R^{(k-1)}\)</span> will always be negative.
A mutating <span class="math inline">\(\Delta T^{(k)}\)</span> thus has
a chance to alter the sign of <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span>, which further brings
about camera jitters.</p>
<p>So when will camera jitter? From the above equation, we know that
camera will jitter when the sign of <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span> consistently changes
over time, i.e., the value of <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span> oscillates around zero.
Let's make it equal to zero and see what we can find then.</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R^{(k)}-R^{(k-1)}&amp;=0\\
(R^{(k-1)}+P^{((k-1)\to k)})\mathrm{e}^{m\frac{\Delta
T^{(k)}}{T}}-R^{(k-1)}&amp;=0\\
\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}&amp;=\mathrm{e}^{m\frac{\Delta T^{(k)}}{T}}\\
m\frac{\Delta
T^{(k)}}{T}&amp;=\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)\\
\Delta
T^{(k)}&amp;=\frac{T}{m}\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)
\end{aligned}
\end{equation}
\]</span></p>
<p>This equation tells us when <span class="math inline">\(\Delta
T^{(k)}\)</span> is near <span
class="math inline">\(\frac{T}{m}\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)\)</span>, camera will have a large chance to jitter. This
motivates us to improve damping by filtering out the occasions where
<span class="math inline">\(\Delta T^{(k)}\)</span> is very close to
<span
class="math inline">\(\frac{T}{m}\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)\)</span>.</p>
<p>What about going deeper? We can treat <span
class="math inline">\(\Delta T^{(i)}\)</span> as variable, and all other
as constants. This abstraction gives us a function of <span
class="math inline">\(f(x)\)</span>:</p>
<p><span class="math display">\[
f(x)=x-a\ln\left(\frac{b}{b+vx}\right),~a\le0, b&gt; 0, v&gt;0, x&gt;0
\]</span></p>
<p>Taking the derivative of <span class="math inline">\(f(x)\)</span>,
we know that <span class="math inline">\(f(x)\)</span> is monotonically
decreasing when <span class="math inline">\(x\in(-\infty,
(-av-b)/v)\)</span> and monotonically increasing when <span
class="math inline">\(x\in((-av-b)/v,+\infty)\)</span>, and <span
class="math inline">\(f(0)=0\)</span>. Hence, to make the sign of <span
class="math inline">\(f(x)\)</span> mutable, <span
class="math inline">\((-av-b)/v\)</span> must be positive and the
minimum of <span class="math inline">\(f(x)\)</span> must be
negative.</p>
<p>The minimum of <span class="math inline">\(f(x)\)</span> can be
easily computed:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
f(x)_\text{min}&amp;=f((-av-b)/v)\\
&amp;=-a-\frac{b}{v}-a\ln\left(-\frac{b}{av}\right)\\
&amp;=a\left(-1-\frac{b}{av}-\ln\left(-\frac{b}{av}\right)\right)\\
&amp;\xlongequal{x\triangleq-b/av}a\left(-1+x-\ln(x)\right) ~(x\ge 0)\\
&amp;\le 0
\end{aligned}
\end{equation}
\]</span></p>
<p>The last inequality holds because <span class="math inline">\(x-1\ge
\ln x~(x&gt;0)\)</span>.</p>
<p><img data-src="/images/improvingdamping/pic-2.png" /></p>
<p>This reveals the fact that: when <span
class="math inline">\((-av-b)/v&gt;0\)</span>, a variant <span
class="math inline">\(\Delta T^{(k)}\)</span> is likely to cause <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span> to change its sign,
thus resulting in camera jitters. Suppose <span
class="math inline">\(\Delta T^{(k)}\)</span> is large enough, so then
the k-th residual <span class="math inline">\(R^{(k)}\)</span> gets
smaller than <span class="math inline">\(R^{(k-1)}\)</span> while <span
class="math inline">\(f(x)^{(k)}\)</span> is positive. A smaller <span
class="math inline">\(R^{(k)}\)</span> pushes <span
class="math inline">\(b\)</span> to become smaller for the next frame,
which further pushes the root of the function to become larger. In this
case, even with the same delta time, <span
class="math inline">\(f(x)^{(k)}\)</span> will have a larger chance wo
fall in the negative area, i.e., <span class="math inline">\(\Delta
T^{(k+1)}\)</span> is more likely to be less than the root.</p>
<p><img data-src="/images/improvingdamping/gif-5-5.gif" width="900" height="450"/></p>
<h1 id="solutions">Solutions</h1>
<h2 id="solution-1-imposing-an-invalid-range">Solution 1: imposing an
invalid range</h2>
<p>Based on what we've discussed so far, we can immediately come up with
a simple solution: enforce <span class="math inline">\(\Delta
T^{(k)}\)</span> to be <span
class="math inline">\(\mathfrak{O}=\frac{T}{m}\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)\)</span> if they are very close. That is to say, we use a
small value <span class="math inline">\(\varepsilon\)</span>, if <span
class="math inline">\(\Delta T^{(k)}/\mathfrak{O}\in(1-\varepsilon,
1+\varepsilon)\)</span>, we just set <span class="math inline">\(\Delta
T^{(k)}\)</span> to <span
class="math inline">\(\mathfrak{O}\)</span>.</p>
<p>Note that <span
class="math inline">\(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\)</span> can be zero or negative. If this is the case, we keep the
original <span class="math inline">\(\Delta T^{(k)}\)</span> without
doing anything. Besides, you should be aware that <span
class="math inline">\(\Delta T^{(k)}\)</span> here is not the time this
frame actually takes, instead, it is just the duration used to calculate
damping.</p>
<p>Let us explain it more quantitatively. Suppose <span
class="math inline">\(\Delta T^{(k)}/\mathfrak{O}=1-\delta\)</span>,
where <span class="math inline">\(0&lt;\delta&lt;\varepsilon\)</span>.
Then <span class="math inline">\(\Delta
T^{(k)}\gets\mathfrak{O}\)</span> according to our algorithm. We then
plug <span class="math inline">\(\Delta
T^{(k)}_\delta=\mathfrak{O}(1-\delta)\)</span> into the original
expression of <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R^{(k)}_\delta-R^{(k)} &amp;= (R^{(k-1)}+P^{((k-1)\to
k)})\mathrm{e}^{\frac{m}{T}(1-\delta)\frac{T}{m}\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)}-R^{(k-1)}\\
&amp;=\left(R^{(k-1)}+P^{((k-1)\to
k)}\right)\cdot\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)^{1-\delta}-R^{(k-1)}\\
&amp;=\left(R^{(k-1)}\right)^{1-\delta}\cdot
\left(R^{(k-1)}+P^{((k-1)\to k)}\right)^{\delta}-R^{(k-1)}\\
&amp;&gt;\left(R^{(k-1)}\right)^{1-\delta}\cdot\left(R^{(k-1)}\right)^{\delta}-R^{(k-1)}\\
&amp;&gt;0
\end{aligned}
\end{equation}
\]</span></p>
<p>This demonstrates that now the camera lags behind its following
target more than the previous frame since the residual is larger. After
substituting <span class="math inline">\(\Delta T^{(k)}_\delta\)</span>
with <span class="math inline">\(\mathfrak{O}\)</span>, <span
class="math inline">\(R^{(k)}-R^{(k-1)}\)</span> would be zero, meaning
that the camera now keeps the same frame as last frame. Camera does not
jitter.</p>
<p>Here comes the question: what if the following target slows down, or
stops, or even turns back to the opposite direction and the camera still
remains the same residual to it?</p>
<p>It is quite a good question. But if we look carefully at the function
of <span class="math inline">\(f(x)\)</span>, we will find this
situation will never happen. Let's rewrite <span
class="math inline">\(f(x)\)</span> here:</p>
<p><span class="math display">\[
f(x)=x-a\ln\left(\dfrac{b}{b+vx}\right), ~a\le 0, b&gt;0, x&gt;0
\]</span></p>
<p>This time, we do not constrain the value of <span
class="math inline">\(v\)</span>, but at last frame, it's positive.</p>
<p>When <span class="math inline">\(v\)</span> gets smaller but still
positive, we observe the function gradually shifts leftwards, pushing
the root towards zero. This implies that the area <span
class="math inline">\((1-\varepsilon, 1+\varepsilon)\)</span> gets
contracted and the probability of remaining the same residual gets
smaller.</p>
<p><img data-src="/images/improvingdamping/gif-6.gif" width="900" height="450"/></p>
<p>When <span class="math inline">\(v\)</span> is zero where the
following target stops, the current residual can be readily calculated
as <span
class="math inline">\(R^{(k)}=R^{(k-1)}\mathrm{e}^{m\frac{\Delta
T^{(k)}}{T}}\)</span>, which closes the distance gap between the camera
of the following target. The ratio, which is calculated as <span
class="math inline">\(\Delta T^{(k)}/\mathfrak{O}\)</span>, would be
devided by zero, outputting an infinite value.</p>
<p>When <span class="math inline">\(v\)</span> is negative, <span
class="math inline">\(P^{((k-1)\to k)}\)</span> will be negative. The
ratio <span class="math inline">\(\Delta T^{(k)}/\mathfrak{O}\)</span>
now becomes negative, also beyond the range of <span
class="math inline">\((1-\varepsilon, 1+\varepsilon)\)</span>.</p>
<p>We can implement this algorithm in less than 100 lines of code. You
should modify three files in the official Cinemachine source code
directory.</p>
<p>First is <code>Predictor.cs</code>. Add a <code>ImprovedDamp</code>
function:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">ImprovedDamp</span>(<span class="params"><span class="built_in">float</span> initial, <span class="built_in">float</span> dampTime, <span class="built_in">float</span> deltaTime, <span class="built_in">float</span> bonus</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dampTime &lt; Epsilon || Mathf.Abs(initial) &lt; Epsilon)</span><br><span class="line">        <span class="keyword">return</span> initial;</span><br><span class="line">    <span class="keyword">if</span> (deltaTime &lt; Epsilon)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> tolerance = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> alpha = Mathf.Log(bonus) * dampTime / kLogNegligibleResidual;</span><br><span class="line">    <span class="built_in">float</span> ratio = deltaTime / alpha;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ratio &lt;= <span class="number">1.0f</span> + tolerance &amp;&amp; ratio &gt;= <span class="number">1.0f</span> - tolerance)</span><br><span class="line">    &#123;</span><br><span class="line">        deltaTime = alpha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> k = -kLogNegligibleResidual / dampTime; <span class="comment">//DecayConstant(dampTime, kNegligibleResidual);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> initial * (<span class="number">1</span> - Mathf.Exp(-k * deltaTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The input <code>bonus</code> is <span
class="math inline">\(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\)</span>. Parameter <code>tolerance</code> is what you should set
as <span class="math inline">\(\varepsilon\)</span> we've introduced
above.</p>
<p>In file <code>CinemachineVirtualCameraBase.cs</code>, add a new
function <code>ImprovedDetachedFollowTargetDamp</code>:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">ImprovedDetachedFollowTargetDamp</span>(<span class="params">Vector3 initial, Vector3 dampTime, <span class="built_in">float</span> deltaTime</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject go = GameObject.Find(<span class="string">&quot;Cube&quot;</span>);  <span class="comment">// Hard find our following target of interest, you should not do like this!</span></span><br><span class="line">    Vector3 deltaDistance = <span class="keyword">new</span> Vector3(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>) * deltaTime; <span class="comment">// Hard set the velocity, you should not do like this!</span></span><br><span class="line">    Vector3 residual = initial - deltaDistance;</span><br><span class="line">    Vector3 bonus = </span><br><span class="line">        <span class="keyword">new</span> Vector3(residual.x / (residual.x + deltaDistance.x + <span class="number">1e-7</span>f), </span><br><span class="line">                    residual.y / (residual.y + deltaDistance.y + <span class="number">1e-7</span>f), </span><br><span class="line">                    residual.z / (residual.z + deltaDistance.z + <span class="number">1e-7</span>f));</span><br><span class="line"></span><br><span class="line">    dampTime = Vector3.Lerp(Vector3.Max(Vector3.one, dampTime), dampTime, FollowTargetAttachment);</span><br><span class="line">    deltaTime = Mathf.Lerp(<span class="number">0</span>, deltaTime, FollowTargetAttachment);</span><br><span class="line">    <span class="keyword">return</span> Damper.ImprovedDamp(initial, dampTime, deltaTime, bonus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This piece of code is very informal, and you should never write your
code like this. The purpose of this function is to get <span
class="math inline">\(R^{(k-1)}\)</span> and <span
class="math inline">\(P^{((k-1)\to k)}\)</span>. I reckon the correct
way to do this is to create a new (or two) variable in the
<code>CinemachineVirtualCameraBase</code> class and update it in each
tick. The code presented here is only for demonstration.</p>
<p>In file <code>CinemachineFramingTransposer.cs</code>, change the
called function for damping:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cameraOffset = VirtualCamera.ImprovedDetachedFollowTargetDamp(  <span class="comment">// Original is DetachedFollowTargetDamp</span></span><br><span class="line">    cameraOffset, <span class="keyword">new</span> Vector3(m_XDamping, m_YDamping, m_ZDamping), deltaTime);</span><br></pre></td></tr></table></figure>
<p>You could also try other components, not just
<code>FramingTransposer</code> here.</p>
<p>With the default <code>tolerance=0.05</code>, the result is shown
below.</p>
<p><img data-src="/images/improvingdamping/gif-7.gif" width="900" height="450"/></p>
<p>Camera jitters disappear. Note that the general fps is quite high
(around 400~500). This is because our scene is quite simple, containing
only a cube and a camera. In order to simulate a more real runtime game
situation, I place 20k cubes in the scene and now the fps is around 30,
but still unstable.</p>
<p>Below is the result when using the raw damping algorithm.</p>
<p><img data-src="/images/improvingdamping/gif-8.gif" width="900" height="450"/></p>
<p>Camera jitters more severely due to a generally lower FPS. What about
using the improved damping algorithm? Here is result with
<code>tolerance=0.05</code>.</p>
<p><img data-src="/images/improvingdamping/gif-9.gif" width="900" height="450"/></p>
<p>Just as expected, camera jitters do not show up. Let's try different
<code>tolerance</code>s. How will a small <code>tolerance</code> help
alleviate jitters? Below is the result with
<code>tolerance=0.01</code>.</p>
<p><img data-src="/images/improvingdamping/gif-10.gif" width="900" height="450"/></p>
<p>Camera jitters occur again! This suggests that an excessively small
value cannot fully filter out actions that can lead to camera jitters.
Let's try our final experiment with <code>tolerance=0.1</code>.</p>
<p><img data-src="/images/improvingdamping/gif-11.gif" width="900" height="450"/></p>
<p>Camera jitters disappear, but the camera motion seems a little stiff.
These experiments show that an appropriate value of
<code>tolerance</code> to ensure the smoothness and robustness of the
camera.</p>
<h2 id="solution-2-adding-low-pass-filter">Solution 2: adding low-pass
filter</h2>
<p>Our improved samping perfectly solves camera jitters under unstable
fps, but it looks very stiff when it reaches the boundary of max damping
distance. Can we make it more realistic so that the object won't just
look stolid? Yes of course, we can add low-pass filter, or moving
average to our improved damping to achieve more smooth results.</p>
<p>Recall the algorithm of the improved damping: if <span
class="math inline">\(\Delta T^{(k)}/\mathfrak{O}\in(1-\varepsilon,
1+\varepsilon)\)</span>, we just set <span class="math inline">\(\Delta
T^{(k)}\)</span> to <span class="math inline">\(\mathfrak{O}\)</span>.
Instead of hard setting <span class="math inline">\(\Delta
T^{(k)}\)</span> to <span
class="math inline">\(\mathcal{O}=\frac{T}{m}\ln\left(\frac{R^{(k-1)}}{R^{(k-1)}+P^{((k-1)\to
k)}}\right)\)</span>, we introduce <span
class="math inline">\(\Delta\hat{R}^{(k)}\)</span>, the smoothed version
of the original delta residual <span class="math inline">\(\Delta
R^{(k)}=R^{(k)}-R^{(k-1)}\)</span>. If <span
class="math inline">\(\Delta T^{(k)}/\mathfrak{O}\in(1-\varepsilon,
1+\varepsilon)\)</span> holds, we calculate <span
class="math inline">\(\Delta\hat{R}^{(k)}\)</span> as an average of
<span class="math inline">\(\Delta R^{(k)}\)</span> and <span
class="math inline">\(\Delta \hat{R}^{(k-1)}\)</span>:</p>
<p><span class="math display">\[
\Delta \hat{R}^{(k)}=\beta \Delta R^{(k)} + (1-\beta)\Delta
\hat{R}^{(k-1)}
\]</span></p>
<p>which can be iterated through a recursive form:</p>
<p><span class="math display">\[
\Delta \hat{R}\gets\beta \Delta R^{(k)} + (1-\beta)\Delta \hat{R}
\]</span></p>
<p>Note that <span class="math inline">\(\Delta \hat{R}\)</span> gets
updated if and only if <span class="math inline">\(\Delta
T^{(k)}/\mathfrak{O}\in(1-\varepsilon, 1+\varepsilon)\)</span> holds,
i.e., when the camera lies in the <strong>unstable area</strong>. The
use of <span class="math inline">\(\Delta \hat{R}\)</span> is similar to
low-pass filters in the sense that they all filter out high-frequency
signals.</p>
<p>Below is s sample code implementation in file
<code>Predictor.cs</code>:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CurrentResidual = initial * Mathf.Exp(-k * deltaTime);</span><br><span class="line">ResidualDifference = CurrentResidual - PreviousRedisual;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> result;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> tolerance = <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">float</span> alpha = Mathf.Log(bonus) * dampTime / kLogNegligibleResidual;</span><br><span class="line"><span class="built_in">float</span> ratio = deltaTime / alpha;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ratio &lt;= <span class="number">1.0f</span> + tolerance &amp;&amp; ratio &gt;= <span class="number">1.0f</span> - tolerance)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> beta = <span class="number">0.001f</span>;</span><br><span class="line">    CachedDeltaResidual = (<span class="number">1</span> - beta) * CachedDeltaResidual + beta * ResidualDifference;</span><br><span class="line">    result = initial - (CachedDeltaResidual + PreviousRedisual);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    result = initial - CurrentResidual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let's try it out! With damping time <span
class="math inline">\(T=0.2\)</span> and <span
class="math inline">\(\beta = 0.01\)</span>, we can achieve the
following damping result with low-pass filter:</p>
<p><img data-src="/images/improvingdamping/gif-12.gif" width="900" height="450"/></p>
<p>Now the camera looks much more smooth and, flexible. What about
trying a smaller damp time, say, <span
class="math inline">\(T=0.1\)</span>? Here is the result:</p>
<p><img data-src="/images/improvingdamping/gif-13.gif" width="900" height="450"/></p>
<p>The result is ok but sometimes it's still jittering. It is because a
smaller <span class="math inline">\(T\)</span> leads to a larger <span
class="math inline">\(\Delta R\)</span> and thus a larger chance to
cause jitters. To solve this issue, we can set a larger tolerance <span
class="math inline">\(\varepsilon\)</span>, or we can have a smaller
<span class="math inline">\(\beta\)</span>. We adopt a <span
class="math inline">\(\beta\)</span> of <span
class="math inline">\(0.001\)</span> and see how it performs.</p>
<p><img data-src="/images/improvingdamping/gif-14.gif" width="900" height="450"/></p>
<p>The camera now becomes smooth again.</p>
<p>We can measure this sort of instability more quantitatively. Below is
a graph plotting <span class="math inline">\(\Delta R^{(k)}\)</span>
during five seconds of camera trace with damp time <span
class="math inline">\(T=0.2\)</span>. The original curve (in blue)
oscillates over time due to an instability of fps. The improved damping
method eliminates all the oscillation and makes the curve absolutely
plain. Empowered by low-pass filter, the curve becomes smooth without
loss of stability.</p>
<p><img data-src="/images/improvingdamping/pic-3.png" /></p>
<p>Below is the graph with damp time <span
class="math inline">\(T=0.1\)</span>. As can be seen, even with improved
damping, the camera still has a chance to vibrate, and the original
curve, oscillates much more intensely than with <span
class="math inline">\(T=0.2\)</span>. Employing the low-pass filter
gives a much smoother and stable camera motion curve, as expected.</p>
<p><img data-src="/images/improvingdamping/pic-4.png" /></p>
<p>Speaking of this, why can't we just <strong>soften</strong> our
improved damping assignment <span class="math inline">\(\Delta
T^{(k)}=\mathcal{O}\)</span> to <span class="math inline">\(\Delta
T^{(k)}=\tau\mathcal{O}\)</span> where <span
class="math inline">\(\tau(\delta;\varepsilon)\)</span> is a function of
<span class="math inline">\(\delta\)</span> parameterized by <span
class="math inline">\(\varepsilon\)</span>.</p>
<p>Assume <span class="math inline">\(\varepsilon\ge\delta\ge0\)</span>
and <span class="math inline">\(\Delta
T^{(k)}/\mathfrak{O}=1+\delta\)</span>, we first calculate <span
class="math inline">\(\hat{\delta}\gets\exp(\delta\cdot\ln(1+\varepsilon)/\varepsilon)-1\)</span>;
then calculate <span
class="math inline">\(\hat{\delta}\gets\varepsilon\cdot(\hat{\delta}/\varepsilon)^p\)</span>;
last, we have <span class="math inline">\(\tau=1+\hat{\delta}\)</span>.
For <span class="math inline">\(\Delta
T^{(k)}/\mathfrak{O}=1-\delta\)</span>, we obtain <span
class="math inline">\(\tau=1-\hat{\delta}\)</span>. <span
class="math inline">\(p\)</span> is a parameter controlling how fast the
value of <span class="math inline">\(\hat{\delta}\)</span> grows from
<span class="math inline">\(0\)</span> to <span
class="math inline">\(\varepsilon\)</span>. The larger <span
class="math inline">\(p\)</span> is, the larger mass will be
concentrated on the <span class="math inline">\(\varepsilon\)</span>
side.</p>
<p>Below is the result with <span class="math inline">\(T=0.2\)</span>
and <span class="math inline">\(p=3\)</span>:</p>
<p><img data-src="/images/improvingdamping/gif-15.gif" width="900" height="450"/></p>
<p>Not bad! The soft version of improved damping really makes the camere
smoother and less stiff than the vanilla improved damping algorithm. The
follow plot also shows that with soft parameterization, the camera
trajectory is much more natural with neglectable amount of
oscillation.</p>
<p><img data-src="/images/improvingdamping/pic-5.png" /></p>
<p>We also compare it to different <span
class="math inline">\(T\)</span> and <span
class="math inline">\(p\)</span>. Beolow is the result with <span
class="math inline">\(T=0.2\)</span> and <span
class="math inline">\(p=5\)</span>.</p>
<p><img data-src="/images/improvingdamping/gif-16.gif" width="900" height="450"/></p>
<p>A larger <span class="math inline">\(p\)</span> makes the camera more
stiff, but is still better than the original improved damping
algorithm.</p>
<p>Below is the result with <span class="math inline">\(T=0.2\)</span>
and <span class="math inline">\(p=1\)</span>.</p>
<p><img data-src="/images/improvingdamping/gif-17.gif" width="900" height="450"/></p>
<p><span class="math inline">\(p=1\)</span> is less effective as the
magnitude of attenuation it applies to <span
class="math inline">\(\mathfrak{O}\)</span> is not enough to compensate
for the osciallation the unstable fps brings about.</p>
<p>Let's try another damp time. The result with <span
class="math inline">\(T=0.1\)</span> and <span
class="math inline">\(p=1\)</span> shows as follows.</p>
<p><img data-src="/images/improvingdamping/gif-18.gif" width="900" height="450"/></p>
<p>When <span class="math inline">\(T=0.1\)</span>, the oscillation is
more severe, as we've already stated above. What about <span
class="math inline">\(p=3\)</span>?</p>
<p><img data-src="/images/improvingdamping/gif-19.gif" width="900" height="450"/></p>
<p>Better, but still not sufficient to mitigate the oscillation. Let's
try <span class="math inline">\(p=5\)</span>.</p>
<p><img data-src="/images/improvingdamping/gif-20.gif" width="900" height="450"/></p>
<p>Almost perfect. We can conclude that a smaller <span
class="math inline">\(T\)</span> needs a larger <span
class="math inline">\(p\)</span> to offset the intense jitters resulted
from unstable fps. Besides, you can combine the soft improved damping
method and low-pass filters to achieve a smoother transition.</p>
<h2 id="solution-3-continuous-residual">Solution 3: continuous
residual</h2>
<p>Okay, let's forget all aforementioned solutions and revisit our
residual update formula at the very beginning:</p>
<p><span class="math display">\[
R^{(k)}=(R^{(k-1)}+P^{((k-1)\to k)})\mathrm{e}^{\frac{m}{T}\Delta
T^{(k)}}
\]</span></p>
<p>Reformulate thie equation to the following form:</p>
<p><span class="math display">\[
R_{t+\Delta T}=(R_t+v\Delta T)f(\Delta T, T)
\]</span></p>
<p>where <span class="math inline">\(v\)</span> is the speed of the
camera's follow target, and <span class="math inline">\(f(\Delta T,
T)\)</span> is a more generalized form of the damping function <span
class="math inline">\(\mathrm{e}^{\frac{m}{T}\Delta T}\)</span>.
Theoretically, it can represent any function of interest.</p>
<p>Now, regarding <span class="math inline">\(R_t\)</span> as a function
with respect to <span class="math inline">\(t\)</span>, we can seek to
obtain its derivative:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R&#39;_t&amp;=\lim_{\Delta T\to 0}\frac{R_{t+\Delta T}-R_t}{\Delta T}\\
&amp;=\lim_{\Delta T\to 0}\frac{(R_t+v\Delta T)f(\Delta T,
T)-R_t}{\Delta T}\\
&amp;=\lim_{\Delta T\to 0}\frac{R_t\left(f(\Delta T, T)-1\right)+v\Delta
Tf(\Delta T, T)}{\Delta T}\\
&amp;=\lim_{\Delta T\to 0}\left(R_t\frac{f(\Delta T, T)-f(0,T)}{\Delta
T}+vf(\Delta T, T)\right)\\
&amp;=R_tf&#39;(0,T)+vf(0,T)\\
&amp;=R_tf&#39;(0,T)+v
\end{aligned}
\end{equation}
\]</span></p>
<p>We use the equality <span class="math inline">\(f(0,T)=1\)</span>
because when you plug <span class="math inline">\(\Delta T=0\)</span>
into <span class="math inline">\(R_{t+\Delta T}=(R_t+v\Delta T)f(\Delta
T, T)\)</span>, you will get <span
class="math inline">\(R_t=R_tf(0,T)\)</span>, implying <span
class="math inline">\(f(0,T)=1\)</span>.</p>
<p>What about derivatives with higher orders? We can calculate the
second-order derivative as follows:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R&#39;&#39;_t&amp;=\lim_{\Delta T\to 0}\frac{R&#39;_{t+\Delta
T}-R&#39;_t}{\Delta T}\\
&amp;=\lim_{\Delta T\to 0}\frac{(R_{t+\Delta
T}f&#39;(0,T)+v)-(R_tf&#39;(0,T)+v)}{\Delta T}\\
&amp;=f&#39;(0,T)\lim_{\Delta T\to 0}\frac{R_{t+\Delta T}-R_t}{\Delta
T}\\
&amp;=f&#39;(0,T)R&#39;_t
\end{aligned}
\end{equation}
\]</span></p>
<p>It is a nice form which bridges the first-order derivative <span
class="math inline">\(R&#39;_t\)</span> and the second-order derivative
<span class="math inline">\(R&#39;&#39;_t\)</span>. In fact, for any
<span class="math inline">\(n\)</span>-th order derivative, it can be
recursively calculated as:</p>
<p><span class="math display">\[
R^{(n)}_t=f&#39;(0,T)R^{(n-1)}_t=f&#39;(0,T)^{n-1}R&#39;_t
\]</span></p>
<p>Having all these derivatives, we can then expand <span
class="math inline">\(R_{t+\Delta T}\)</span> using Taylor series and
calculate the difference to <span
class="math inline">\(R_t\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
R_{t+\Delta T}-R_t&amp;=R_t+\sum_{n=1}^\infty\frac{(\Delta
T)^n}{n!}R^{(n)}_t - R_t\\
&amp;=\sum_{n=1}^\infty\frac{(\Delta T)^n}{n!}R^{(n)}_t\\
&amp;=\sum_{n=1}^\infty\frac{(\Delta
T)^n}{n!}f&#39;(0,T)^{n-1}R&#39;_t\\
&amp;=\underbrace{\vphantom{\sum_{n=1}^\infty}(R_tf&#39;(0,T)+v)}_{\text{Velocity
term}}\cdot\underbrace{\sum_{n=1}^\infty\frac{(\Delta
T)^n}{n!}f&#39;(0,T)^{n-1}}_{\text{Coefficient term}}
\end{aligned}
\end{equation}
\]</span></p>
<p>Note that if we are still choosing <span
class="math inline">\(\mathrm{e}^{\frac{m}{T}\Delta T}\)</span> as out
damping function <span class="math inline">\(f(T,\Delta T)\)</span>, the
derivative of it with respect to <span class="math inline">\(\Delta
T\)</span> will be <span
class="math inline">\(\frac{m}{T}\mathrm{e}^{\frac{m}{T}\Delta
T}\)</span> and the value at zero will be <span
class="math inline">\(m/T\)</span>.</p>
<p>In practice, we first decide how many terms in the coefficient term
should be taken in, and then sum them up and multiply with the velocity
term, the result of which is denoted by <span
class="math inline">\(\Delta R_t\)</span>. The residual at the current
frame, can be readily computed as <span
class="math inline">\(R_{t+\Delta T}=R_t+\Delta R_t\)</span>. To save
computation, we can first cache <span class="math inline">\(n!\)</span>
up to a threshold, say <span class="math inline">\(n=5\)</span>, and
then using the formula of geometric series to efficiently compute the
coefficient sum.</p>
<p>To estimate its error, we use the Lagrange remainder:</p>
<p><span class="math display">\[
P_n(t)=\frac{R^{(n+1)}_\xi}{(n+1)!}(\Delta T)^{n+1}, ~t\le \xi\le
t+\Delta T
\]</span></p>
<p>Decompose it:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\left\vert P_n(t) \right\vert&amp;=\left\vert
\frac{R^{(n+1)}_\xi}{(n+1)!}(\Delta T)^{n+1} \right\vert\\
&amp;=\left\vert \frac{f&#39;(0,T)^{n}R&#39;_\xi}{(n+1)!}(\Delta
T)^{n+1} \right\vert\\
&amp;=\left\vert \frac{(\Delta
T)^{n+1}}{(n+1)!}f&#39;(0,T)^n\left(f&#39;(0,T)R_\xi+v\right)  \right\vert\\
&amp;=\left\vert \frac{(\Delta
T)^{n+1}}{(n+1)!}f&#39;(0,T)^n\left(f&#39;(0,T)(R_t+v\Delta\xi)f(\Delta\xi,T)+v\right)
\right\vert\\
&amp;\le\frac{(\Delta T)^{n+1}}{(n+1)!}\left\vert f&#39;(0,T)
\right\vert^n\left(|f&#39;(0,T)|\cdot|R_t+v\Delta\xi|\cdot|f(\Delta\xi,T)|+v\right)\\
&amp;\le\frac{(\Delta T)^{n+1}}{(n+1)!}\left\vert f&#39;(0,T)
\right\vert^n\left(|f&#39;(0,T)|\cdot|R_t+v\Delta T|+v\right)\\
&amp;=\frac{(\Delta T)^{n+1}}{(n+1)!}\left\vert f&#39;(0,T)
\right\vert^{n+1}|R_t+v\Delta T|+\frac{(\Delta
T)^{n+1}}{(n+1)!}\left\vert f&#39;(0,T) \right\vert^{n}v\\
&amp;\le\frac{(\Delta T)^{n+1}}{(n+1)!}\left\vert f&#39;(0,T)
\right\vert^{n+1}|R_t|+\frac{(\Delta T)^{n+1}}{(n+1)!}\left\vert
f&#39;(0,T) \right\vert^{n+1}v\Delta T+\frac{(\Delta
T)^{n+1}}{(n+1)!}\left\vert f&#39;(0,T) \right\vert^{n}v\\
\end{aligned}
\end{equation}
\]</span></p>
<p>where <span class="math inline">\(0\le\Delta\xi\le\Delta T\)</span>
and <span class="math inline">\(v&gt;0\)</span> as we assumed. We can
see that the error is asymptotically negligible with respect to <span
class="math inline">\(|R_t|\)</span>, especially when <span
class="math inline">\(f&#39;(0,T)\)</span> is small.</p>
<p>Recall that <span class="math inline">\(f&#39;(0, T)=m/T\)</span>
where <span class="math inline">\(m=\ln(0.01)\approx -4.6\)</span> and
<span class="math inline">\(T\)</span> is the damp time. If <span
class="math inline">\(T\)</span> is large, say 0.5 or even 1.0, the
value of <span class="math inline">\(f&#39;(0,T)\)</span> will be
somewhat small so that a decent precision can be reached within few
steps of expansion, i.e., a small <span class="math inline">\(n\)</span>
say 2 or 3 could satisfy camera stability. However, if <span
class="math inline">\(T\)</span> is small, say 0.2 or 0.1 or even
smaller, the value of <span class="math inline">\(f&#39;(0,T)\)</span>
would grow larger, and then a larger <span
class="math inline">\(n\)</span> might be needed to reach our expected
precision. This is in accordance with our observation that a smaller
<span class="math inline">\(T\)</span> generally leads to a more
unstable camera trajectory. We will show this soon.</p>
<p>Let's first try <span class="math inline">\(T=0.2\)</span> and <span
class="math inline">\(n=1\)</span>. Recall that <span
class="math inline">\(n\)</span> is the maximum order of derivatives we
use to approximate the residual difference. <span
class="math inline">\(n=1\)</span> means that we only use <span
class="math inline">\(\Delta T\)</span> in the coefficient term. Here is
the result:</p>
<p><img data-src="/images/improvingdamping/gif-21.gif" width="900" height="450"/></p>
<p>Looks nice! What about setting <span
class="math inline">\(n=2\)</span>?</p>
<p><img data-src="/images/improvingdamping/gif-22.gif" width="900" height="450"/></p>
<p>Not much difference, but a little bit smoother. Let's try <span
class="math inline">\(T=0.1\)</span> respectively with <span
class="math inline">\(n=1\)</span> and <span
class="math inline">\(n=2\)</span>. First comes <span
class="math inline">\(n=1\)</span>.</p>
<p><img data-src="/images/improvingdamping/gif-23.gif" width="900" height="450"/></p>
<p>It's okay but it seems too fast when the cube comes back to
stillness. How about <span class="math inline">\(n=2\)</span>?</p>
<p><img data-src="/images/improvingdamping/gif-24.gif" width="900" height="450"/></p>
<p>Now everything gets worked! Next, let's set <span
class="math inline">\(T\)</span> smaller, which generally won't be used
in actual gameplay but as a test it's worth a try. We set <span
class="math inline">\(T=0.05\)</span> and try different <span
class="math inline">\(n\)</span> to see how they influence our camera
trajectory.</p>
<p>Here is the result with <span class="math inline">\(n=1\)</span>:</p>
<p><img data-src="/images/improvingdamping/gif-25.gif" width="900" height="450"/></p>
<p>Okay... a total mess. Try <span
class="math inline">\(n=2\)</span>:</p>
<p><img data-src="/images/improvingdamping/gif-26.gif" width="900" height="450"/></p>
<p>Unfortunately, the cube always stays behind the camera. Now <span
class="math inline">\(n=3\)</span>:</p>
<p><img data-src="/images/improvingdamping/gif-27.gif" width="900" height="450"/></p>
<p>Forget about it ... Let's try <span
class="math inline">\(n=4\)</span>:</p>
<p><img data-src="/images/improvingdamping/gif-28.gif" width="900" height="450"/></p>
<p>Things are getting better! At least it does not shake anymore and
begins to stay at the right position. I bet <span
class="math inline">\(n=5\)</span> is better:</p>
<p><img data-src="/images/improvingdamping/gif-29.gif" width="900" height="450"/></p>
<p>It's close! Last, we try <span
class="math inline">\(n=6\)</span>:</p>
<p><img data-src="/images/improvingdamping/gif-30.gif" width="900" height="450"/></p>
<p>Finally, the camera disposes everything well. As we can see from the
process, a small <span class="math inline">\(T\)</span> requires a large
<span class="math inline">\(n\)</span> to reach the minimum acceptable
precision. I hope you never have the chance to use such a small <span
class="math inline">\(T\)</span>, and if it happens, cache enough orders
of derivatives or it would be prohibitively expensive to compute at
runtime.</p>
<p>To further understand why this method solves the jittering issue, we
take a deeper look at the expression of <span
class="math inline">\(R&#39;_t=f&#39;(0,T)R_t+v\)</span> derived above.
This is an ODE and we solve it out (proof left to the readers):</p>
<p><span class="math display">\[
R_t=\frac{Tv}{m}\left(\mathrm{e}^{\frac{m}{T}t}-1\right)
\]</span></p>
<p>Here I've expanded <span class="math inline">\(f(\Delta T,
T)\)</span> as <span
class="math inline">\(\mathrm{e}^{\frac{m}{T}t}\)</span>. We cannot
directly use this explicit expression to calculate <span
class="math inline">\(R_{t+\Delta t}\)</span> because there is no
<strong>correct</strong> time stamp <span
class="math inline">\(t\)</span> when game is running. What we only have
is the previous frame's residual <span
class="math inline">\(R_t\)</span> and the elapsed time at this frame
<span class="math inline">\(\Delta T\)</span>. And as the velocity <span
class="math inline">\(v\)</span> may change over time, a closed-form of
<span class="math inline">\(R_t\)</span> cannor serve our purpose well.
We can only incrementally calculate camera residuals at each frame based
on what we currently have.</p>
<p><span class="math inline">\(R_t\)</span> is a monotonic increasing
function, and of course, it's continuous. The continuity ensures that
the camera trajectory is always smooth and never jitters, if fps is
sufficiently high (over one thousand I suppose?).</p>
<p>For the original discrete residual, its velocity is:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\tilde{R}&#39;_t&amp;=\frac{\tilde{R}_{t+\Delta T}-\tilde{R}_t}{\Delta
T}\\
&amp;=\frac{(\tilde{R}_t+v\Delta T)f(\Delta T, T)-\tilde{R}_t}{\Delta
T}\\
&amp;=\frac{\tilde{R}_t}{\Delta T}(f(\Delta T, T)-1)+vf(\Delta T, T)\\
&amp;=\frac{\tilde{R}_t}{\Delta T}(f(\Delta T, T)-f(0, T)) + v(f(\Delta
T, T) - f(0,T)) + v\\
&amp;=\left(\frac{\tilde{R}_t}{\Delta T}+v\right)(f(\Delta T, T)-f(0,
T))+v\\
&amp;=(\tilde{R}_t+v\Delta T)f&#39;(\xi,T) +v
\end{aligned}
\end{equation}
\]</span></p>
<p>where <span class="math inline">\(0\le\xi\le\Delta T\)</span> is from
Lagrange's Mean Value Theorem. Note that I add a tilde symbol over <span
class="math inline">\(R\)</span> to distinguish it from the one from the
continuos version above.</p>
<p>This is another ODE. We can solve it out (proof left to the
readers):</p>
<p><span class="math display">\[
\tilde{R}_t=\left(\frac{2v}{f&#39;(\xi,T)}+\tilde{R}_\text{Init}\right)\mathrm{e}^{f&#39;(\xi,
T)t}-vt-\frac{2v}{f&#39;(\xi,T)}
\]</span></p>
<p>Note that we solve the ODE with respect <span
class="math inline">\(\Delta T\)</span>, the increment time rather than
the absolute time <span class="math inline">\(t\)</span>. So, we
introduce an initial value <span
class="math inline">\(\tilde{R}_\text{Init}\)</span> to control what the
initial value of residual is at this frame, <span
class="math inline">\(t\)</span> is now the elapsed time for this frame
satisfying <span class="math inline">\(0\le t\le T\)</span> and <span
class="math inline">\(0\le\xi\le t\)</span>.</p>
<p>The following graph shows that how the function changes with
different <span class="math inline">\(A=f&#39;(\xi,
T)=\frac{m}{T}e^{\frac{m}{T}\xi}\)</span> and <span
class="math inline">\(B=\tilde{R}_\text{Init}\)</span>. It can be
noticed that this function is very sensitive to the input <span
class="math inline">\(t\)</span>, the elapsed time at this frame. A
small change of the input would significantly change the sign of <span
class="math inline">\(\tilde{R}_t\)</span>, thus causing camera jitters.
We also notice that a smaller <span class="math inline">\(A\)</span>,
derived from a smaller <span class="math inline">\(T\)</span>, pushes
the function leftwards, which also makes it more vulnerable to
inputs.</p>
<p><img data-src="/images/improvingdamping/gif-31.gif" width="900" height="450"/></p>
<p>Below is a comparison between five damping algorithms introduced in
this article, including the original damping. Damp time <span
class="math inline">\(T\)</span> is set to 0.2. We observe significant
stability improvement when using any of the four proposed damping
algorithms. You should be careful when choosing the most appropriate
algorithm because the situation on which you intend to use damping. How
unstable is your fps? What is the damp time <span
class="math inline">\(T\)</span>? How is the tracked object moving? You
should experiment with these algorithms and choose the one that best
suits your needs.</p>
<p><img data-src="/images/improvingdamping/pic-6.png" /></p>
]]></content>
      <categories>
        <category>游戏 - 相机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>相机</tag>
        <tag>Unity</tag>
        <tag>Cinemachine</tag>
        <tag>Damping</tag>
      </tags>
  </entry>
  <entry>
    <title>《Assassain&#39;s Creed Odyssey》玩后感</title>
    <url>/2020/09/08/18/39/</url>
    <content><![CDATA[<p>115小时，主线+两个DLC通关。奥德赛是一个优秀的游戏，但不是神作，在走向RPG的道路上是系列作品的里程碑。人物塑造方面，奥德赛无疑是成功的，由于我选择的是温情
路线，所以我看到的马拉卡的内心是无比渴望家庭的温暖的，正如奥德赛音乐集的“Odyssey(Modern
Version)”中的歌词"Travel in path alone, back to the warmth of
home"一般，踏在异乡的每一步无一不通往家。本作两个主要配角Phoibe和Brasidas，都令人印象深刻。在画面上，优良的美工沿袭了育碧式BUG，有可能在欣赏风景的时候会卡到墙里面，有时候还挺扫兴的。值得一提的是，奥德赛对希腊风情的刻画非常优秀，每一个同步点都可以疯狂截图作壁纸。本作比较难受的地方是剧情，三条主线除了家庭线比较完整之外，另外两条主线都虎头蛇尾，过多的无用支线严重稀释了主线的紧凑感，让人在玩到一半之后想去玩巫师三。DLC1的整体剧情我个人比较喜欢，但是一些细节处理尤其不妥，动机不足导致DLC1评分降低。DLC2流程很长，总体来说冥界剧情好于亚特兰蒂斯剧情好于极乐世界，不过对神之领域的描绘总体来说很精彩。如果说我对11.10发售的英灵殿有什么值得期待的话，可以用几句话总结：剧情不要拉跨，任务尽量优化；BUG可以少些，卡墙不动尴尬；风景依旧如画，壮汉赶紧来吧！</p>
<span id="more"></span>
<h1 id="剧情整体精彩细节拉跨">剧情：整体精彩，细节拉跨</h1>
<p>自奥德赛发行以来，“剧情”一直是被玩家广为诟病的一点，但是在做完所有任务（包括两个DLC）、体验完所有剧情之后，我倒是觉得奥德赛的剧情<strong>整体上</strong>非常优秀，但是和大多数玩家一样，我也想吐槽其中非常多的细节，我思考了一下，这大概是出于一种“恨铁不成钢”的心理。明明奥德赛的剧情可以做得非常棒，可以几无瑕疵，可以触及巫师三，但是阿育就是把这么一个差一点点就堪比完美的剧本甩到玩家脸上，香还是香的，但就是不情愿，被迫品尝一桌盛宴中编剧埋下的一坨坨屎。</p>
<h2 id="世界观">世界观</h2>
<p>奥德赛的世界观是建立在希腊伯罗奔尼撒战争期间，但显然，奥德赛不完全是一部纪实游戏，战争只是游戏的大背景，也是游戏开始的一个引子而已，到了后面，游戏的进展其实和战争已经没什么太大关系了。在这个大背景下，著名的时代人物，如伯里克利、苏格拉底、布拉西达斯都会悉数出场并成为推进主线过程中重要的人物，而另一大群体，“神教”，正贯穿了整个主线的发展。主角的冒险由神教展开，也从神教结束，神教作为核心暗线而存在，我们把它称为<strong>神教线</strong>。而剧情的实际主线则是马拉卡找家人的旅程，在途中，主角会踏遍希腊，经历诸多精彩的故事，最终找到家人，在若干年后再次相聚，我们把它称为<strong>家庭线</strong>。除此之外，奥德赛中还引入了很多神话元素，比如传奇动物、传奇生物、神之领域（主要在DLC2），它们以“神器”联系起来，游戏进行到中后期会出现一条新的主线，也就是让主角去搜集神器，我们称之为<strong>神器线</strong>。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/1.png" alt="奥德赛的地图很大" />
<figcaption aria-hidden="true">奥德赛的地图很大</figcaption>
</figure>
<p>所以，总的来说，奥德赛的世界观就是在希腊伯罗奔尼撒战争的时代大背景下，以家庭线为明线，以神教线为暗线，以神器线为辅线而展开的。在游戏进行过程中，主角会见证真实的历史，会体验各地的风俗，会欣赏希腊的风光，会体验人生的波折。奥德赛的世界观即是如此的宏大，在游戏策划的精心编排下将希腊的大观悉数摆在我们面前，同时又让玩家以小人物的视角代入到如画的场景中，如此结合，让玩家一旦进入到角色里，就很难立刻停下来。</p>
<p>然而，相比起源把一桌菜一股脑全给你端上来又不介绍菜品让你细细琢磨、品尝，奥德赛更像是古典西餐厅里的一盘盘端上精心调制的菜品并为你介绍菜的制作方式、选用食材、食用步骤，甚至还要告诉你在品尝之前要沐浴更衣精心打扮，这就会产生下面要说的一个问题，大而不精，野心太大但却没有把握住剧情开展的主次，导致剧情上连贯性的断裂，这进而引发一个很严重的问题：游戏进展到后期同质化严重，玩家的游戏热情被大幅度削减。就好比前几道菜都详细介绍，食客会觉得很高端很优秀，但是如果有几十道菜，每个都如此呢？食客就会厌烦。</p>
<h2 id="任务">任务</h2>
<p>剧情是通过任务推进的。任何一个游戏，都有任务，完成了任务，尤其是主线任务，才能顺利推进到下一个剧情节点。可以说，任务是推进主线的首要手段（并非唯一，比如在奥德赛中，满屏幕的问号“？”也是一个手段）。</p>
<p>上面我们已经简单说了，奥德赛的主线可以分为三条：家庭线、神教线和神器线。家庭线和神教线是从头贯穿到尾的，二者并行，一明一暗互为依托，这样的设计是很好的：它既不会让游戏快速陷入单线游戏的乏味，也能营造剧情上汹波暗涌的气氛，很快抓住玩家让玩家进入角色。这里值得表扬的是本作家庭线和神教线的融合是非常到位的，二者不但是并行关系，而且是交叉关系，如同螺旋前进的两条线一样，共同推动了游戏剧情的发展。但是，第三条线神器线的出现大大打破了这一节奏，甚至是原本剧情的美感。在家庭线达到关键节点找到母亲后，本来以来父亲的出现会解释玩家所有的疑问，但是没想到，老父亲一出场就让玩家莫名其妙地搜集神器，没有半点前因后果的交代；在找到神器之后，又莫名其妙出现了古代与现代的时空错乱和穿越，我们的主角马拉卡又莫名其妙地活到了现代穿上了西服最终溘然长逝。说实话，我当时玩到这一段的时候几乎是快进过的，没有丝毫欣赏剧情的欲望。这一条线从一开始，到最后，只能用四个字去总结：说的是啥？尽管这一主线流程很短，但它的出现极大割裂了另外两条主线的连续感，也造成了马拉卡精分的错觉，让玩家搞不明白奥德赛的时间线究竟是如何排布的。</p>
<p>当然，家庭线和神教线不是没有问题，而且在很多细节之处都有槽点。比如家庭线的一大槽点就是，如果你走的是大团圆路线，你就会发现马拉卡过于圣母（没错，就是我）。诚然马拉卡是一个呆萌渴望家庭温暖外表冷漠内心火热的失足少年，但是当自己的妹妹残忍地杀害基友Brasidas，造了无数的孽后，马拉卡依然选择了原谅她，最后还能和继父、表弟在一个桌子上吃饭，我的内心无疑是充满了问号。你可以说，这是你自己选择的剧情啊！对，但是当玩家选择了这个剧情之后，我们会明显感觉到这个剧情是不尽合理的，也就是说，制作人在设计这一剧情路线的时候就没有仔细推敲其合理性，所以这个锅还要阿育来背。神教线的槽点就更多了，各种奇葩的神教成员（包括那个自爆身份好像老子不怕你的那个）一个接一个，最后鬼魅那段单口相声真的是漏洞百出，竟然还可以选择相信她，而且无论你选择什么，神教线都会到此为止，那又何必再做选项呢。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/8.png"
alt="鬼魅的最后一个线索才是“女性”，不然很好猜" />
<figcaption
aria-hidden="true">鬼魅的最后一个线索才是“女性”，不然很好猜</figcaption>
</figure>
<p>除了主线之外，奥德赛的一大尤为突出的问题是，支线任务过多，而且过于无聊。在奥德赛中，除了标有黄色感叹号的关键支线之外，其他大部分支线都是在端茶倒水、洞穴找人、团灭兵营，基本上可以概括为：“我丈夫/妻子/兄弟/孩子不听我话跑出去不见了/被强盗抓住了，他可能在某某树林/洞穴/兵营里，你能帮我找到他吗”。刚开始玩用来点亮地图确实还不错，而且可以熟悉技能，提高操作，但是当游戏进行到中后期时，满屏幕的感叹号让你没有丝毫欲望去清空，因为你知道打不打都无所谓，对主线毫无影响，给的物品也毫无吸引力。也许制作者的初衷就是让玩家在打完主线之后再慢慢清支线，但实际上，对于一部分强迫症玩家来说，满屏幕没清又强行按捺自己去清欲望的想法的确是非常痛苦的，最终的归宿可能只有隐藏地图标记才能解救他们。尽管对总的剧情没有太大影响，然而过多的冗余支线就好比蒙娜丽莎嘴角沾了米粒，赫拉脸上长满痘痘，人还是那个人，但味道总觉得变了。</p>
<p>但另一方面，也不得不表扬一些支线的确做得很有意思。比如“失落的希腊神话”系列任务就很有意思（尤其是“倒霉的一天”），此外，雅典区的一系列支线也很有特色（苏格拉底与雅典炮王的任务），还有一开始瘟疫的支线，这些支线要么本来在内容上非常丰富、有趣，要么会影响后续的剧情，这就回到了支线的作用：需要给予玩家一定的反馈。如果做完一个支线，玩家什么都没有得到，什么反馈都没有，那做这个支线干什么呢？看风景吗？所以，我认为如果把神器线做成一个系列支线，那效果可能就会好很多。如果删掉其中80%的无用的没有任何反馈的支线，说不定奥德赛的IGN评分又会更高。</p>
<p>可以看得出来，奥德赛在任务系统上有浓重的借鉴巫师三的痕迹，主要体现在剧情选项和支线系统。支线系统我们已经上面已经说了，和巫师三一样都有很多支线，但是巫师三的支线是它被称为神作的原因，奥德赛的支线只有东施效颦的副作用，究其原因，还是二者对支线作用的理解不同。</p>
<p>剧情可选是奥德赛在整个刺客细条系列中的一大突破，也是效仿巫师三最典型的一个要素。为什么我们需要可选剧情？因为这可以给玩家更多的自由度，让玩家能够更好地带入剧情，玩家需要为每一个决定负责，从而就要深思熟虑，剧情选择引发的蝴蝶效应足以在游戏结局的时候升华玩家对整个游戏的评价和感悟。巫师三做到了，奥德赛没做到。这有几点：</p>
<ul>
<li>奥德赛大部分选项不会对后面的游戏剧情有所影响；</li>
<li>可选项非常少，玩家可能面对哪个都不想选但又不得不选的尴尬境地；</li>
<li>选择之后的剧情推进和想象的不一样。</li>
</ul>
<p>从我个人的游戏体验来说，上面三点是奥德赛在“剧情开放”尝试中最为突出的问题，我相信也是大部分玩家承认的问题。奥德赛的最终结局只有几种，而决定这几种结局的选项在几十个小时的游戏中只有寥寥几个地方，那其他的无数选项的作用是什么呢？第二，奥德赛每次可选的大概在3~5个选项之间，而给出的所有选项有时候又都非常智障，明明哪个都不想选却偏要选一个，这对玩家非常不友好，有种强行喂食的感觉。第三，剧情总是朝着意料之外的发展。比如有个任务是关于贩夫的未婚妻，这个时候就不能骗她说贩夫被干掉了，否则直接导致任务失败；而有的时候又需要你假惺惺地欺骗一下NPC才能完成任务，这种任务设定毫无规律可循，遇到了大概率就是一脸懵逼然后呵呵一笑。综上，剧情上的自由可选，就奥德赛的表现来看，反而是禁锢了玩家的自由度，看似让玩家有更多决定剧情走向的权利，但实际上是画地为牢，无论怎么选，都圈定在了编剧预先定义好的条条框框里了。显然，这是一种非常不成熟、宁可没有的设计。当然了，作为向巫师三学习并处于刺客信条系列发展史的一部过渡作品，奥德赛牛刀小试也无可厚非，只是希望英灵殿能够在这上面进行改进。</p>
<p>最后来说一下两个DLC。网上普遍对DLC1的剧情诟病颇深，对DLC2倒是赞誉更多，不过我个人倒是觉得，DLC1的剧情高度比DLC2更高，但是下限也比DLC2低，而DLC2发挥整体非常平稳。但从剧情上讲，我个人更喜欢DLC1，尽管它有非常突出的硬伤。</p>
<p>DLC1的剧情整体上非常棒，前提你玩的是Alexios（据说Cassandra体验非常不好）。游戏流程不长，十个小时以内可以打完，但是任务节奏很紧凑，内容相对丰富，关键是剧本很给力，讲述了马拉卡遇到真爱但是又被命运无情摧毁的故事。在这个DLC里，我看到了马拉卡内心的脆弱，尤其是他对家庭温暖的渴望与期盼。其实，在玩游戏本体的时候，我们会经常听到马拉卡感慨自己的命运，我印象中比较深刻的是“要是我不离开凯法隆尼亚岛就好了”，再回忆片头马拉卡独自坐在房上抚摸着断矛，他一定非常渴望再见到亲人吧。虽然在凯法隆尼亚岛上，他可能永远也见不到亲人，但是，有Markos，有Phoibe，还有岛上其他的伙伴，这样的小日子，不也很美好吗，正如他与DLC1的女主相遇相知相爱后，与岳父大流士、自己的孩子四人一起生活在村里，平淡而温馨，甜蜜又幸福，不也正是马拉卡一直想要的生活吗。做一个漂流在外四海为家的佣兵并不可怕，可怕的是这样的人却时刻想要有一个稳定幸福的小家庭，这简直是一种无法企及的奢望。当上古维序者干掉女主，马拉卡在火海中呼唤着她的名字时，当马拉卡来到家门口的她的坟墓前时，当马拉卡之后到他们相知的三个地方寻找纪念物时，当最后马拉卡把孩子托付给岳父大流士看着他乘帆远去时，当最后的最后马拉卡仍旧时孤身一人时，我心中的确是被深深触动了。这是我非常喜欢DLC1的点。</p>
<p>但是也正如上面所说，DLC1的上限很高，下限也很低，主要仍然体现在细节不到位。比如火海救岳父的情节，作为一个久经沙场的佣兵，他应该是完全能够意识到将妻子儿子丢在船边会有什么后果，就算不能两边兼顾，也应该知道孰轻孰重。再有最后送走儿子的桥段结束得过于仓促，上古维序者这个组织的行为动机也不够充分，在很多地方，玩家是没有办法选择剧情的走向的，也就不得不被迫喂屎，这也是DLC1被广大玩家吐槽的原因所在。但我个人认为，DLC1仍然是瑕不掩瑜的，对于部分玩家而言依旧有非常高的可玩性。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/10.jpg"
alt="这一段还是非常感人的，我流下了130滴眼泪" />
<figcaption
aria-hidden="true">这一段还是非常感人的，我流下了130滴眼泪</figcaption>
</figure>
<p>相比之下，DLC2的流程就非常非常长了，目前需要30个小时左右才能全部通关。DLC2分为三个章节，每个章节的流程都很长，相互独立但又通过“神话”这一线索串联起来，大概是寻找亚特兰蒂斯并探索神杖的用法。这个DLC把正作的神器线联系在了一起，在希腊和现代两个时间点之间不停穿越，目的就是要给玩家解释这个神器是怎么一回事儿。说实话，我也不知道他解没解释清楚，反正我基本都是快进过了，因为实在是过于无聊。</p>
<p>在剧情上来看这个DLC没啥有意思的，我总结一下，第一个章节是神秘四角恋上演姐妹撕逼大战，第二个章节是冥王海王打赌以虐待死者为乐，第三个章节是主角化身正义使者最终颠覆亚特兰蒂斯政权。总之就是云里雾里、莫名其妙。不过值得表扬的是，每个章节的特色地图都非常不错，极乐世界的花花草草，冥界的幽暗阴森感，亚特兰蒂斯的宏伟高科技，给人耳目一新的感觉。我印象最深的还是冥界的Phoibe剧情和Brasidas基友剧情，还是有点感人的，到了最后也特别想痛扁冥王。极乐世界充当双面间谍的感觉也不错，只是亚特兰蒂斯过于平平无奇，除了最后的BOSS有点恶心之外，也没有什么比较让人能够记住的点了。</p>
<p>这里特别吐槽一下冥界Brasidas的剧情，实在非常无语和狗血，把编剧的圣母心态体现得淋漓尽致。作为一个从小接受战士教育的将军，在战场杀敌是本分；当敌人杀向你，举起武器反击是本能；只是推开挡路的女人而没有将其杀死，是本心；无论从哪个角度讲，Brasidas都没有做错，战争也好，斯巴达的荣耀也好，还是出于自己的意志也好，Brasidas的做法都是无可非议的。但是，编剧强行要通过这个故事去虐Brasidas，本来都死得那么惨了，还要让他做出痛苦的抉择，实在是非常过分。在这里，我心疼基友三秒钟。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/11.png" alt="基友太惨了" />
<figcaption aria-hidden="true">基友太惨了</figcaption>
</figure>
<figure>
<img data-src="/images/ac-odyssey-impression/3.png" alt="我恨这个女人" />
<figcaption aria-hidden="true">我恨这个女人</figcaption>
</figure>
<h1 id="画面时代顶尖bug难掩">画面：时代顶尖，BUG难掩</h1>
<p>奥德赛延续了起源优秀的画面，在刻画希腊风光上做到了无出其右，以至于获得了“旅游模拟器”的美称。<strong>画面</strong>其实是一个比较笼统的概念，当我们在说一个游戏的画面的时候，我们一般是在说这个游戏带给我们的所有视觉体验，包括光影效果、水和火的模拟、各种材质的清晰度真实度、整个画面的比例、画面的色彩等等等等，只要是我们能直观感受到的，都可以归入画面里。</p>
<p>从画面整体来看，奥德赛做到了时代的顶尖。优秀的光影、逼真的水波、温暖的色调、协调的比例、真实的场景，包括人物的建模等，都非常优秀。最难能可贵的是，奥德赛给我们生动地呈现出了波澜壮阔、风光迤逦、特色鲜明的古希腊景象，尽管可能不是最真实的历史，但是当我们置身其中时，仍然可以感到非常的震撼，仿佛自己就是那个时代的人，经历着相同的事。所以，奥德赛的画面不仅是技术上的时代顶尖，而且他还能带给我们一种沉浸式的体验，这对一个优秀的3A游戏来说，是必不可少的。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/9.jpg" alt="光影效果非常不错" />
<figcaption aria-hidden="true">光影效果非常不错</figcaption>
</figure>
<p>当然，对奥德赛来说，他还是沿袭了“育碧特色”——各种神奇的BUG，虽然已经比起源好很多了（起源的BUG可以看<a
href="https://www.bilibili.com/video/BV19x411j7dp">这里</a>）。比如，你会卡到一个地方无法动弹然后“失去同步”，会在地上皆若空游无所依，会有各种各种严重不严重的穿模。其中最为蛋疼的，其实不算BUG的地方就是，自动寻路。这个简直是噩梦，很多时候系统会绕很大一圈，甚至是本来已经绕了很大一圈了，结果来了个“无法跟随道路”，这是坠痛苦的。不过好在可能是阿育经历了起源雪崩式的BUG，在奥德赛里BUG已经不是一个很严重的问题了，至少可以完成任务不是。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/12.png"
alt="欣赏一下马拉卡的盛世美颜" />
<figcaption aria-hidden="true">欣赏一下马拉卡的盛世美颜</figcaption>
</figure>
<h1 id="人物形象丰满行为骨感">人物：形象丰满，行为骨感</h1>
<p>谈到剧情就不得不稍微说一下人物了。奥德赛对人物的刻画是非常到位的，作为一部史诗大作，奥德赛不仅对主角马拉卡和一些主要人物进行了细致入微的刻画，并且对一些关键配角也有非常到位的描写！</p>
<p>首先说一下主要人物：马拉卡、妈和妹妹。马拉卡无疑是最核心的人物了，玩家在关键剧情上的不同选择会呈现出多面的马拉卡形象，由于我选择的是真情圣母路线，所以就按照这个形象说。马拉卡给人的最大印象，在上面已经说了，作为一个铁血真汉子、无情雇佣兵，他的内心其实是非常渴望亲情的，无论是一直心心念念想要找到妈，想要挽回失足妹妹，还是对Phoibe如待女儿一般的呵护与关爱，抑或是对Markos的帮助，都体现了一个流浪在外无家可归的人向往亲情、渴望家庭的内心最真切的期盼。马拉卡不滥杀无辜，同情战争下家破人亡的底层百姓，路见不平也能拔刀相助，时而放荡不羁，时而收敛拘束，就好似武侠小说里的绝世大侠，执剑走江湖，四海皆为家。在游戏的时候，左下角的提示会出现“xx号是你的家，记得常回来看看”（大意如此），不禁让人唏嘘，马拉卡总是在外漂泊，以船为家，在注定不平凡的寻亲之路上经历这么多人生的坎坷，着实让人心疼！另外，马拉卡这个角色还透露着呆萌的气质，一方面是来自配音+动补演员本身的气质，另一方面就是在游戏中，马拉卡的确也很幽默，经常开一些黄腔，引发一些笑话。这些对丰富和塑造人物形象都非常有帮助。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/7.jpg" alt="性感吗？我可以" />
<figcaption aria-hidden="true">性感吗？我可以</figcaption>
</figure>
<p>然后再说说一些关键配角，这里说几个人：妈、后爸、Phoibe、基友Brasidas、炮王阿尔西比亚迪斯、苏格拉底。这几个人应该是除了主角之外给我留下印象最深刻的几个人了。</p>
<p>奥德赛对妈的刻画是非常到位的：坚强独立、能力突出，同时也和马拉卡一样渴望完整幸福的家庭。在找妈的路上，我们已经通过几个支线知道了妈是如何去找妹妹，如何带着她逃跑，又是如何在失去她之后绝望，到她最后重新振作成为一岛的领袖的。在这个过程中，妈的形象跃然纸上，后来和马拉卡一起挽救妹妹更是突出了她追寻亲情的一面。</p>
<p>对后爸的笔墨虽然不多，但是也能大致勾勒出一个教子严厉但关怀备至、有些教条但也饱含感情的一个将军形象。作为一个将军，他当初在悬崖边没有办法与神教抗衡，但是他也在一直懊悔。在几个CG里，我们都看出来，尽管他是继父，但是他仍然对马拉卡和妹妹视如己出，教导和关爱也都无微不至。</p>
<p>Phoibe和Brasidas应该是马拉卡人生中非常关键的两个人了。一个在他的生活中和他超越了朋友的关系，一个在他的斗争中给予了莫大的帮助。可以说，Phoibe与Brasidas是马拉卡少年时和成年时的两个缩影，一个象征着无邪的天真烂漫，一个象征着成熟的稳重冷静。站在马拉卡的视角，他想要紧紧地把握住他们，不但是对朋友的珍惜，更是对自己这两面的珍视，在他的心里，永远有一个小孩子，愿意陪着Phoibe一起长大，也永远有一个大人，能够和Brasidas并肩作战。</p>
<figure>
<img data-src="/images/ac-odyssey-impression/6.jpg"
alt="马拉卡对Phoibe非常关心，因为她是最亲密的人" />
<figcaption
aria-hidden="true">马拉卡对Phoibe非常关心，因为她是最亲密的人</figcaption>
</figure>
<p>其实说实话，我对Phoibe是又爱又恨的，爱的是她的善良机智，恨的是她的自作聪明，无视马拉卡警告对自己的能力没有清晰的判断，导致自己身死他手，实在让人惋惜。显然，既然作为一个玩家，我已经能够对她产生这样的情感了，那么无疑，奥德赛对Phoibe的塑造也是相当成功的，虽然不那么讨喜，但是至少她是真实的。</p>
<p>基友的镜头没有Phoibe那么多，但是当他在贩夫仓库第一次出场时，就注定他有一个悲剧式英雄的解决了。在熊熊燃烧的大火中单挑对方几个好汉，与马拉卡多次在战场上默契配合，在斯巴达时多次帮助主角一家恢复名誉，以至于最后也是战死在战场上的，这样一个人物，实在令人肃然起敬。而且，基友不但是一个优秀的将军战士，他其实也很善良，他在能不杀人的时候是尽量不杀人的，从贩夫，到后来的斯巴达剧情，乃至到DLC的冥界，都体现了基友刚毅且善良的一面。然而，在DLC冥界那里，只要选错一个选项Brasidas就会留在冥界，这个行为这个剧情无非就是编剧强行喂屎表达泛滥圣母心的一面，实在是为这个角色抹黑！</p>
<figure>
<img data-src="/images/ac-odyssey-impression/5.jpg" alt="基友真的太帅了" />
<figcaption aria-hidden="true">基友真的太帅了</figcaption>
</figure>
<p>最后，炮王阿尔西比亚迪斯和苏格拉底的刻画也是相当有意思。在游戏后半段这两个人都会有很多任务，炮王会不断地让你去帮他约炮，或者和他约炮，而苏格拉底就是不断和你<del>强行抬杠</del>探讨哲学，总的来说，这两个人物的刻画也非常鲜明。其他的包括船长、鬼魅、斯巴达领袖、表弟，甚至是那个性欲很强的老女人，奥德赛对他们的刻画也都有所突出，所谓众生各相，让玩家在走剧情、赏风景的同时还是感受古希腊多姿多彩的人文特色。</p>
<p>但是，正如这一节的标题所说的，很多人物的形象是很丰满，但是在一些细节方面，人物的行为动机是严重匮乏的，以至于玩家会觉得“为什么非要这么做”，这样的设计对人物的刻画是有害的。举个典型的例子，亲爸毕达哥拉斯，莫名其妙找到一个神器，然后莫名其妙又觉得自己无敌了，最后又莫名其妙地挂了，过完剧情玩家只会觉得这个人脑子有点不正常，至于其他的性格、形象、心理活动？不不不，脑子有问题就是了。人物行为骨感集中体现在DLC1，这也是DLC1被大家广为诟病之所在。上面已经说过这个问题了，这里不再赘述。</p>
<p>最后的最后，在游戏结局时马拉卡与苏格拉底在墓园的对话让人感慨万千，在此摘录如下：</p>
<blockquote>
<p>Alexios：Phoibe，她从没有过小女孩的时光，我总是以成人的方式与她对话。
苏格拉底：这是因为你尊重她。你可以问问自己为何这么选择，Alexios，但千万不要质疑自己的决定。
Alexios：谢谢你给了她该有的葬礼。
苏格拉底：在极乐世界中还有无数的人，这些受到祝福的人已经获得了永恒的喜乐，其中一个就是我们伟大的伯里克利。
Alexios：基于他的一切作为，全雅典都欠他一份情。
苏格拉底：我们会称他为“雅典第一公民”不是没有道理的。他是个有很多贡献的人，但也是个孤僻的人。
Alexios：要是他肯让我们分担他的重担就好了……
苏格拉底：我们只能从他表现出来的部分来了解他，但谁敢说那就不是他真正的自我呢？
Alexios：这场战争牺牲太多人了，就连布拉西达斯都陨落了。
苏格拉底：或许如此。但身为一个斯巴达人，他已经尽了自己的义务并战死沙场了。
Alexios：我当时也有尽全力帮助他。他是我的朋友。
苏格拉底：你还活着就是他最好的复仇，人们会将他作为英雄来尊敬的。
Alexios：人们会记得我们是如何打垮克勒翁的。</p>
</blockquote>
<h1 id="类型转型成功平衡欠佳">类型：转型成功，平衡欠佳</h1>
<p>起源之前的刺客信条属于传统意义上的ACT游戏，从起源开始，逐渐向RPG转型，到了奥德赛，已经形成了ARPG的初步格局。尽管现代游戏ACT、RPG、ARPG的界限已经趋于模糊化，但是我认为我们还是有必要对游戏进行一个粗略的分类，以更好地对游戏整体的类型风格进行评价。</p>
<p>如果用ACT的视角审视奥德赛，那么奥德赛显然是不合格的。这体现在以下几点：</p>
<ul>
<li>正如<a
href="#剧情：整体精彩，细节拉跨">剧情</a>一节所述，奥德赛非常侧重剧情的讲述，大量的CG、对话、支线任务就是为了铺垫剧情、描绘人物形象，这和传统的ACT游戏淡化剧情是相悖的；</li>
<li>奥德赛的养成元素非常多，这体现在等级压制、等级上限、装备体系、技能体系上，尽管游戏默认的是等级跟随，但是等级提高带来的技能点收益是非常重要的，尤其在打传奇动物和传奇生物的时候更为显著；</li>
<li>奥德赛的装备体系决定了它不是一个纯粹的ACT游戏，游戏的蓝装、紫装、黄装品类非常多，并且，极品装备是满属性的紫装，这就意味着玩家可以追求极致一刀99999，尽管奥德赛没有刻意去引导玩家这么做，但是显然，很多玩家已经开始爆肝了。</li>
</ul>
<p>但是另一方面，我们也不能纯粹从RPG的视角去看待奥德赛，因为游戏尽管整体上非常看重技能，但是如果你没有极品装备而只有黄色套装，那在很多时候，你还是要通过射箭、刺杀或开启无双模型与敌人硬刚，这对你的手法还是有所要求，比如闪避、防反、换装、流派，如果你不想“失去同步”，在高难度下还是需要一定的熟练程度才能手起刀落斩敌人于马下。尽管和起源的防反、马战比起来这都是小儿科，但手残玩家挑战奥德赛的噩梦难度也还是颇有难度的。从这个意义上讲，奥德赛还是保留了一些ACT的元素。</p>
<p>其实，当前纯粹的ACT游戏已经是难以走下去了，这是因为游戏作为一种艺术作品，随着时代的发展玩家越发看重它的精神内核。一个游戏可以不要高难度的战斗操作，只要它有足够优秀的剧本，那么它依然可以是神作；但是，一个游戏如果只要求高难度的操作，以及精心设计的关卡，而没有剧情或者足够有说服力的剧情，那么今天的大部分玩家是不会买账的。ACT游戏的RPG化是时代下游戏发展的一个趋势，但对刺客信条这个具有ACT传统的系列游戏来说，如何在这样的趋势下顺利转型是一大难题。</p>
<p>就我的体验来说，如果说起源是刺客信条转型的初步尝试，那么奥德赛就是转型的成功探索，它是一次探索，并且整体上成功了。如果你玩过起源和奥德赛，你会发现它们之间有莫名的相似性，但是给你的游戏体验又是完全不同的。上面讲到，起源的剧情是比较破碎的，而在很多地方，你不得不进行战斗，又加之战斗本身的难度，你会觉得剧情反而不那么重要，干掉敌人完成任务这个过程反而才是重点；同时，起源较少支线为主线让路的这个做法本身也是突出战斗的一大考量。如果把起源当成一个ARPG游戏，那么它“A”的成分还是更多一些。但是反观奥德赛，它的战斗就进一步简化了，没有马战，防反简单，刺客的飞雷神简直开挂，后期技能及其变态，甚至凑齐极品紫装后就是一刀一个小朋友，战斗本身就成了服务剧情的工具，玩家玩得爽就完事了。但是，仍然作为<strong>刺客信条</strong>系列游戏的奥德赛，总不能全是过剧情吧，那怎么办，疯狂增加要塞、兵营、洞穴就好了！再给你设计无穷多的支线，每个支线都让你去打怪，难度不够，数量来凑，这不动作的成分一下子就高上来了。</p>
<p>这是一个简单且聪明的想法，但对于奥德赛的定位来说，不够明智。我们可以体会到制作人想要保留APRG的动作成分和角色扮演成分，并且都要做大做强。这当然是可能的，如果做的时间足够久。但是，对于奥德赛来说却不可能，理由如下：</p>
<ul>
<li>开发时间短。尽管实际的开发时间我们不能精确得知，但是奥德赛发行于2018年10月，它的上一作发行于2017年10月，两作中间仅间隔一年，是标准的年货游戏。虽然奥德赛是魁北克工作室开发的，而起源是蒙特利尔工作室开发的，但是二者在整个系列的表现形式上具体显著的承接关系，故姑且认为奥德赛的实际开发周期约为2年，这个时间对3A游戏来说不算长；</li>
<li>奥德赛的定位。奥德赛位于刺客信条系列从ACT向PRG转型的过渡阶段，是比起源更具标志性的一部作品。我个人认为，奥德赛的定位就是一部不成熟的ARPG过渡作品；</li>
<li>经验的缺乏。显然，阿育对如何结合刺客信条系列传统的ACT元素与RPG元素的经验还有所缺乏，在短时间内要做一部顶级APRG游戏是非常困难的。记得是谁说过，“奥德赛就是想让你玩两年，直到下一部作品问世”，于是，他们把奥德赛的内容强行用问号、感叹号去填充，让玩家去爆肝刷装备，然后体验一刀99999的快感，但实际上，这种大而空的填鸭式内容对大部分骨灰级单机游戏玩家都没有吸引力，有的只是机械重复式的屠杀敌人，毫无乐趣。</li>
</ul>
<p>所以说，在奥德赛的游戏类型上（ARPG），平衡性是不够优秀的。大到动作成分与角色扮演成分的平衡，小到装备的平衡、技能的平衡、数值的平衡等多方面，奥德赛的“全都要”战略俨然对大部分玩家来说只是一个噱头。如果只把奥德赛玩成体验剧情、模拟旅游，那奥德赛是再好不过的，可是一旦要玩操作、玩养成，奥德赛好像就走向了低配版的国产网游之路。游戏类型的平衡，是奥德赛的一大不足。</p>
<h1 id="总结育碧特色系列之巅">总结：育碧特色，系列之巅</h1>
<p>总的来说，和以往的刺客信条年货作品不同，奥德赛算得上是一部精心打磨的作品，无论是剧情、画面，还是人物、音乐，抑或是育碧特色BUG，都看得出来是经过仔细调教了的。我个人认为奥德赛是综合看来刺客信条系列的巅峰之作，IGN评分9.2也算是比较中肯的评价了（对比起源9.0和巫师三9.3的评分）。如果要我来打分的话，我会打一个9.0分，要是阿育能够在剧情上再多打磨打磨，就可以给到9.5分。如果要说和巫师三差在哪儿，就差在剧情上。</p>
<p>另外，在本文中我没有谈到奥德赛的音乐，但这并不意味着它不出色，相反，我非常喜欢奥德赛的配乐，对比起源阴间的配乐，奥德赛的整体音乐风格就显得非常阳光和带感。OST可以在<a
href="https://www.bilibili.com/video/BV17W4111738">B站</a>或者<a
href="https://y.qq.com/n/yqq/album/0022kx9O4Oy0d9.html">QQ音乐</a>搜到，我已经循环很多天了，强烈推荐大家也去听一听。</p>
<p>对于11.10号即将发售的英灵殿来说，我个人还是非常期待的，<del>一是可以亲手操作猛男</del>，二是从试玩片段来看，它革除了奥德赛中饱受诟病的一些要素（比如剧情、满屏幕的问号、又臭又多的支线，过于强调等级和装备等），同时还保留了优良的画面。从这两点来看，英灵殿无疑是让人期待的。不管你预卜预购，我反正是已经预购了<del>（还是等打骨折更划算一些/(ㄒoㄒ)/~~）</del>。</p>
]]></content>
      <categories>
        <category>游戏 - 玩后感</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>生活</tag>
        <tag>刺客信条</tag>
      </tags>
  </entry>
  <entry>
    <title>Midjourney和NovelAI不完全使用指南</title>
    <url>/2022/10/22/17/37/</url>
    <content><![CDATA[<p>显然，AI绘画已经发展到了一个新的阶段。尽管现在市面上已经有不少AI绘画工具，但要熟练地掌握使用它们也绝非易事。本文从实践出发，为读者讲解如何更好地使用Midjourney和NovelAI这两个时下火热的AI绘画工具，但由于笔者使用时间较短，无法完全驾驭AI绘画工具，因此本文是“不完全指南”。如果本文有任意谬误或缺漏，希望读者能不吝指出。</p>
<span id="more"></span>
<h1 id="midjourney不完全使用指南">Midjourney不完全使用指南</h1>
<h2 id="太长不看版使用规范">太长不看版：使用规范</h2>
<ol type="1">
<li>首先根据公式 <strong><em>Prompt = 构图说明 + 画面内容 + 美术风格 +
光影设置 + 其他描述 + 参数列表</em></strong> 按照下面的模板写Prompt：
<ul>
<li>人物特写：<code>a &#123;headshot | closeup&#125; portrait of [content], [art style], [lighting], [other keywords], [MJ parameters]</code></li>
<li>人物半身照：<code>a &#123;medium shot | over the shoulder shot | head and shoulder shot&#125; portrait of [content], [art style], [lighting], [other keywords], [MJ parameters]</code></li>
<li>人物全身照：<code>a full body portrait of [content], [art style], [lighting], [other keywords], [MJ parameters]</code></li>
<li>风景/建筑照：<code>[content], [art style], [lighting], [other keywords], [MJ parameters]</code>
上面用大括号<code>&#123;&#125;</code>括起来且用竖线<code>|</code>分割的内容是多选一，即从所有可选的关键词中选一个即可。用中括号<code>[]</code>括起来的是我们需要根据画面内容填写的。下面介绍中括号填写的基本规范：</li>
<li><code>[content]</code>：是我们要填写的画面内容。如果是人物，主要填下面的内容（不一定都需要，也不一定完整，根据你的需求）：
<ul>
<li>什么人：<code>&#123;boy | girl | woman | old lady | warrior | witch | anthropomorphic white tiger | ...&#125;</code></li>
<li>脸部特征：<code>&#123;beautiful face | dedicate facial features | colorful tattoos on her face | ...&#125;</code></li>
<li>表情：<code>&#123;smile | crying | moaning | angry | ...&#125;</code></li>
<li>眼睛：<code>&#123;beautiful blue eyes | shining diamond eyes | ...&#125;</code></li>
<li>头发：<code>&#123;long curly black hair | flowing hair | braided hair | ... &#125;</code></li>
<li>装饰：<code>&#123;exquisite garland | opal decorations | wearing feather headdress | ...&#125;</code></li>
<li>穿着：<code>&#123;wearing tall black high heel boots | in purple and white kimono | ...&#125;</code></li>
<li>其他细节：<code>&#123;made of flower | rain on her face | ...&#125;</code>
如果是非人物，则一般不需要写这么细，只要描述大概是什么物体就好了。比如<code>magnificent mountain</code>,
<code>interior of a cyber punk city</code>等等。</li>
</ul></li>
<li><code>[art style]</code>：指定艺术风格，可以通过三种方式指定：
<ul>
<li>直接指定主题/绘画风格：比如<code>cyber punk</code>,
<code>steam punk</code>, <code>japanese anime</code>,
<code>oil painting</code>, <code>realistic painting</code>,
<code>ink painting</code>, <code>ukiyo-e</code>,
<code>bookstory illustration</code>等等；</li>
<li>直接指定相关风格的艺术家：比如吉卜力风格可以说<code>art by &#123;ghibili | koji hoshino | hayao miyazaki&#125;</code>，皮克斯/迪士尼风格可以说<code>art by &#123;pixar | disney&#125;</code>，等等；</li>
<li>直接指定作品：比如<code>breath of the wild</code>,
<code>dark souls</code>, <code>world of warcraft</code>,
<code>lord of the rings</code>等等。 这里推荐使用第二种方式。</li>
</ul></li>
<li><code>[lighting]</code>：画面的光影效果，一般来说使用<code>&#123;cinematic lighting | volumetric lighting&#125;</code>比较通用。但对人物，你偶尔还需要用<code>&#123;back lighting | rembrandt lighting | spotlight&#125;</code>；对非人物，你可能还要<code>&#123;morning lighting | flare&#125;</code>等等。</li>
<li><code>[other keywords]</code>：其他关键词包括：
<ul>
<li>材质：<code>&#123;cubic | bronze | wood | liquid | glass | prism | smoke | plume | milky way | ...&#125;</code></li>
<li>色彩：<code>&#123;dark pink | rainbow | vibrant | warm color | black and white | monochrome | ...&#125;</code></li>
<li>形状：<code>&#123;star | torus | polygonal | low poly | interior | stellation | stellation | ...&#125;</code></li>
<li>其他一般默认加上用来叠BUFF的词：<code>&#123;intricate details | 8K | enchanting | masterpiece | octane render | unreal engine 5 | well composed | award winning | high resolution | ...&#125;</code></li>
</ul></li>
<li><code>[MJ parameters]</code>：Midjourney要填写的参数，一般使用下面的参数组合（但也要有意识地灵活运用）：
<ul>
<li>人物特写照：<code>&#123;--ar 1:1 | --ar 3:4&#125; --q 1.5</code></li>
<li>人物半身照：<code>&#123;--ar 3:4 | --ar 9:16&#125; --q 1.5</code></li>
<li>人物全身照：<code>&#123;--ar 2:3 | --ar 9:16&#125; --q 1.5</code></li>
<li>非人物照：根据你的画面内容选择宽高比，如果是横板，则用<code>--ar 16:9 --q 1.5</code>；如果是竖版，则用<code>--ar 9:16 --q 1.5</code>；如果是加长竖版，则用<code>--ar 9:32 --q 1.5</code>。</li>
</ul></li>
</ul></li>
<li>写好之后，多次出图，你也可以尝试几次参数<code>--test --creative</code>和<code>--testp</code>，一般来说效果会更好些，但注意风景图不要用<code>--testp</code>；</li>
<li>从所有的图中找到让你比较满意的图，使用<code>Upscale</code>，<code>Variant</code>和<code>Remaster</code>功能对它们增强，反复出图；也可以继续在Prompt中增删细节，直到满意为止。</li>
</ol>
<p><a
href="https://promptomania.com/midjourney-prompt-builder/">关键词参考工具</a><br />
<a
href="https://github.com/willwulfken/MidJourney-Styles-and-Keywords-Reference">更完整的关键词参考</a><br />
<a
href="https://docs.google.com/spreadsheets/d/1cm6239gw1XvvDMRtazV6txa9pnejpKkM5z24wRhhFz0/edit#gid=438712621">艺术家参考</a><br />
<a
href="https://docs.google.com/document/d/11H9aDzu0al-wlLm2B4S5BwBdzW9gs5nH5dGloXKUPhI/ed">风格参考</a>
<a href="https://www.krea.ai/">其他人的作品参考1</a> <a
href="https://lexica.art/?">其他人的作品参考2</a></p>
<h2 id="概述">概述</h2>
<p>Midjourney是当前最流行的AI绘画工具之一，它部署在Discord上，因此你需要注册一个Discord账号才能使用。</p>
<p>所有的AI绘画工具最重要的就是如何写Prompts，也就是文本描述。在开始之前，你需要知道写Prompts的几个基本准则：</p>
<ul>
<li><strong>详略得当</strong>：描述越详细，图片越<em>有可能</em>接近你想的画面，但是也有更大的概率生成的图片质量更低；描述越简略，图片越多样化，质量也可能更高。但注意不要加太多细节，否则会图片会很低。一般来说，我们只需要写”意象“，而不要写得过于具体。</li>
<li><strong>以短代长</strong>：少用超过10个词的句子，而用多个短语，每个短语描述画面的一个细节/部分/风格。即使要用长句，也不要太长，保持在20词以内。</li>
<li><strong>反复润色</strong>：不可能第一次生成的图片就完全符合你的想象，需要不断给Prompts润色修改，这不是一个简单的活，因此请保持耐心。</li>
<li><strong>具象描述</strong>：尽量用一些具象的名词、形容词，比如<code>river</code>,
<code>rockstar</code>, <code>Zeus</code>, <code>landscape</code>,
<code>happy</code>,
<code>dark</code>等等，不要用一些难以在现实中找到对应实体的词，比如<code>knowledge</code>,
<code>notion</code>, <code>type</code>等等。</li>
<li><strong>指定量词</strong>：显式指定对象的数量，如果是一个就用<code>a</code>，如果是多个就指定具体数量。</li>
<li><strong>描述风格</strong>：在多数情况下都需要增加风格关键词，比如<code>cyberpunk</code>,
<code>surreal</code>, <code>abstract</code>,
<code>realistic</code>，也可以指定一个或多个艺术家，比如<code>hiroshi yoshida</code>,
<code>Max Ernst</code>, <code>MC Escher</code>,
<code>Yoji Shinkawa</code>等。此外，你还可以指定具体的绘画形式，比如<code>sketch</code>,
<code>woodblock print</code>, <code>oil painting</code>,
<code>watercolor painting</code>等等。</li>
<li><strong>描述构图</strong>：可以显式指定构图，比如<code>a portrait of</code>,
<code>an ultrawide shot of</code>, <code>a headshot of</code>,
<code>a closeup of</code>等。</li>
</ul>
<p>MJ官方文档：https://midjourney.gitbook.io/docs/</p>
<h2 id="注册账号">注册账号</h2>
<p>Midjourney当前作为Discord的内置服务，你可以按照下面的步骤注册账号开始使用：</p>
<ol type="1">
<li>登陆<a
href="https://www.midjourney.com/home/">官网</a>，点击<code>Join the beta</code>：
<img data-src="/images/ai-drawing/mj/1.png" /></li>
<li>进入后输入昵称，加入Discord，如果你没有discord，可能需要根据提示注册一个，之后进入服务器：
<img data-src="/images/ai-drawing/mj/2.png" /></li>
<li>进入一个以#newbies开头的频道，比如#newbies-117： <img
src="/images/ai-drawing/mj/3.png" /></li>
<li>在下方的输入框中输入/imagine，此时就能在弹出来的prompt框中输入你想要生成图片的文本描述了，比如我这里输入的是a
white flower is crying，稍等片刻，就能在聊天框中看到生成的4张图像了：
<img data-src="/images/ai-drawing/mj/4.png" /> <img
src="/images/ai-drawing/mj/5.png" /></li>
<li>除了生成的4张图像外，下方还有两行按钮，分别是U1/U2/U3/U4和V1/V2/V3/V4，分别表示增大每张图的分辨率，以及为每张图重新随机生成。在点击增大分辨率之后，对应大图会重新发送在频道中，下方也会随之出现几个新按钮，见字如义：
<img data-src="/images/ai-drawing/mj/6.png" /></li>
<li>如果你不想在公共频道，你也可以自己创建一个频道，然后邀请Midjourney
Bot到你的频道中。首先在左侧点击<code>添加服务器</code>；然后创建一个私有服务器；最后回到Midjourney的<em>官方服务器</em>，找到Bot，点击后把它添加至服务器即可。
<img data-src="/images/ai-drawing/mj/7.png" /></li>
</ol>
<p>然后你就可以在你自己的服务器里愉快地玩耍了！</p>
<h2 id="使用教学">使用教学</h2>
<p>首先记住下面的公式：</p>
<p><strong><em>Prompt = 构图说明 + 画面内容 + 美术风格 + 光影设置 +
其他描述 + 参数列表</em></strong></p>
<p>其中，“构图说明”也可以放在“美术风格”后面，但一般来说直接通过<code>a portrait/closeup/wide angle shot of ...</code>指定了。除了“画面内容”是必须的之外，其他的都可以省略。</p>
<p>建议初学者在<a
href="https://prompt.noonshot.com/midjourney">这个网站</a>和<a
href="https://promptomania.com/midjourney-prompt-builder/">这个网站</a>找对应的关键词，多做尝试。</p>
<h3 id="构图说明">构图说明</h3>
<p>构图说明指定是怎样的构图，比如特写、近景、远景等等。有下面基本的构图：
- 特写: <code>closeup</code>, <code>portrait</code> -
全身照：<code>full body</code>, <code>full body portrait</code> -
风景：<code>wide angle</code>, <code>epic composition</code>,
<code>low angle</code>, <code>high angle</code></p>
<p>Prompt一般直接用<code>a [composition] of ...</code>开头，其中<code>[composition]</code>就是你选择的构图，比如你想要一个特写，你就可以说<code>a closeup shot of ...</code>或者<code>a headshot portrait of ...</code>；如果你想要一个全身照，你就可以说<code>a full body portrait of ...</code>。</p>
<p>对于风景图，一般不用上述格式，而是直接以内容开头，把构图放在后面，比如<code>vast grassland, wide angle, epic composition</code>，首先说明内容是草原，然后再说用广角镜头和宏大构图。</p>
<p>下图分别是特写/中景/远景的例子，Prompt为<code>a [composition] of an old asian lady --ar 3:4 --q 1.5</code>，其中<code>[composition]</code>分别替换为<code>closeup shot</code>,
<code>medium shot</code>和<code>full body portrait</code>，同时把宽高比分别设置为<code>3:4</code>,
<code>2:3</code>和<code>9:16</code>。最后一张图是风景图，Prompt是<code>vast grassland, wide angle, epic composition --q 1.5 --ar 32:9</code>：</p>
<p><img data-src="/images/ai-drawing/mj/8.png" /></p>
<p>你可以看到几种构图之间的差别，至于为什么要更改宽高比，详见下面的参数列表。</p>
<h3 id="画面内容">画面内容</h3>
<p><strong>画面内容</strong>指定画面内容。该部分根据需求可详可略，但一般都以多个短语组成，比如下面我想以凤凰为原型设计一个角色，全身照，有红色和黄色的花，穿着彩色华丽的装饰，因此输入的Prompt为<code>a full body portrait of a phonix goddess, red and yellow blossoms, wearing rainbow opal accessories, exquisite decorations --ar 9:16</code></p>
<p><img data-src="/images/ai-drawing/mj/9.png" /></p>
<p>第一张图加了参数<code>--test</code>，因此细节更加丰富。</p>
<p>对于非人物也是相同的，比如我现在想设计一个亚特兰蒂斯城，它矗立在悬崖边，有着豪华的建筑，我就可以用<code>the city of Atlantis on steep cliff, enormous beautiful palace, exquisit architecture --aspect 9:32 --q 1.5</code>，得到下面的图：</p>
<p><img data-src="/images/ai-drawing/mj/10.png" /></p>
<p>前两张图用了<code>--test</code>。</p>
<p><strong>再次强调</strong>：描述内容的详略会极大影响生成的结果，越详细，生成的图片会越接近你想象中的画面，但有更大概率质量更低；越简略，越有可能生成非常酷的图片。<em>因此，是否详略取决于你在脑海中是否已经有一个大致的画面，如果你完全没有想法，请尽量保持简略！</em></p>
<p>比如对我想要的凤凰角色，我不知道她具体是什么样子的，就只需要输入<code>a full body portrait of a phonix goddess --ar 9:16</code>就可以了，然后再不断添加细节（前两张图是原始Prompt，第三、四张图增加了<code>red and yellow blossoms</code>）：</p>
<p><img data-src="/images/ai-drawing/mj/11.png" /></p>
<h3 id="美术风格">美术风格</h3>
<p><strong>美术风格</strong>指定图片的美术风格是怎样的。美术风格非常重要，它直接决定了图片内容是否与你想象中的相符。我们可以通过三种方法指定美术风格：（1）绘画风格，如<code>realism</code>,
<code>realistic</code>, <code>abstraction</code>,
<code>impressionism</code>, <code>oil painting</code>,
<code>cover art</code>,
<code>comic book</code>等等；（2）艺术家名字，如<code>Rolf Armstrong</code>,
<code>Lois van Baarle</code>,
<code>Aubrey Beardsley</code>等等；（3）与该风格有关的作品/游戏，如<code>breath of the wild</code>,
<code>genshin impact</code>。</p>
<ul>
<li><strong>指定绘画风格</strong>：比如现在我想对上面的凤凰角色风格化，我可以指定不同的绘画风格，比如下图是依次指定为<code>realism</code>,
<code>abstraction</code>, <code>watercolor painting</code>,
<code>oil painting</code>和<code>cartoon, anime</code>的结果：</li>
</ul>
<p><img data-src="/images/ai-drawing/mj/12.png" /></p>
<ul>
<li><strong>指定艺术家</strong>：相比指定风格，一个更好的方法是直接指定艺术家，比如我依次指定了下述艺术家<code>Alphonse Mucha</code>,
<code>Alyssa Monks</code>, <code>Andreas Rocha</code>,
<code>Miyazaki Hayao</code>和<code>Eric Lacombe</code>，所生成的图片是：</li>
</ul>
<p><img data-src="/images/ai-drawing/mj/13.png" /></p>
<p>你也可以指定多个艺术家，但最好它们风格相似。你可以在<a
href="https://docs.google.com/spreadsheets/d/1cm6239gw1XvvDMRtazV6txa9pnejpKkM5z24wRhhFz0/edit#gid=438712621">这个表</a>里找到一些参考艺术家。</p>
<ul>
<li><strong>指定相关作品</strong>：你还可以显式指定作品，下面的图依次显式指定了作品<code>naruto</code>,
<code>breath of the wild</code>, <code>dark soul</code>,
<code>genshin impact</code>和<code>minecraft</code>：</li>
</ul>
<p><img data-src="/images/ai-drawing/mj/14.png" /></p>
<p><strong>一般来说，推荐直接指定艺术家，辅之以绘画风格和相关作品，注意这三者之间的风格要尽量保持一致。当混用的时候，艺术家放在前面。</strong></p>
<h3 id="光影设置">光影设置</h3>
<p>图片的光影也是重要的一部分，我们可以直接指定光影的类型。比如我们以<code>vast grassland with a lake in the center, a giant tree growing by the lake, --ar 16:9 --q 1.5</code>为基础Prompt，分别考虑下述光影<code>moody lighting</code>,
<code>morning lighting</code>, <code>cinematic lighting</code>,
<code>soft lighting</code>, <code>volumetric lighting</code>,
<code>rembrandt lighting</code>,
<code>godrays</code>和<code>chiaroscuro</code>：</p>
<p><img data-src="/images/ai-drawing/mj/15.png" /> <img
src="/images/ai-drawing/mj/16.png" /></p>
<p>除了风景图之外，人物也可以应用不同的光影。下面以<code>a full body portrait of a phoenix goddess, red and yellow blossoms, wearing rainbow opal accessories, exquisite decorations --ar 9:16 --q 1.5</code>为基础Prompt，同样依次加入上面的光影设置：</p>
<p><img data-src="/images/ai-drawing/mj/17.png" /></p>
<p>可以看到，光影能够影响画面的整体风格，因此，根据内容选择一个合适的光影至关重要。</p>
<h3 id="其他描述">其他描述</h3>
<p>除了上面的构成要素外，你也可以增加其他你想要的关键词，大致可分为下面几类。</p>
<h4 id="材质">材质</h4>
<p>材质（Material/Texture）也可以用来描述画面的整体风格和细节，比如<code>cubic</code>就可能会使画面出现方块状物体。</p>
<p>下面以<code>a beautiful moon above the desert, the moon is in intricate details, marvel cosmic, Cory Loftis, Conrad Roset, epic composition, low angle, dramatic lighting, spotlight, greyscale, cubic, [material], psychedelic, 8k --ar 2:3 --q 1.5</code>为基础Prompt，分别使用材质<code>cubic</code>,
<code>bronze</code>, <code>carbon fiber</code>, <code>foil</code>,
<code>glass</code>, <code>wood</code>,
<code>liquid</code>和<code>smoke, plume</code>：</p>
<p><img data-src="/images/ai-drawing/mj/18.png" /></p>
<p>可以看到，加入不同的材质会整体或局部地影响画面。<code>carbon fiber</code>使画面增加了颗粒感，<code>glass</code>让月亮出现了玻璃状物体，<code>smoke, plume</code>使得画面出现烟雾。当然这里由于Prompt前面的内容足够丰富了，导致部分材质的影响较小，所以区别不是很明显。</p>
<p>如果用简单的描述，再搭配材质关键词，效果会更明显些（Prompt为<code>a tree, [material] --ar 9:16</code>）：</p>
<p><img data-src="/images/ai-drawing/mj/19.png" /></p>
<h4 id="颜色">颜色</h4>
<p>在Prompt增加一些与颜色有关的关键词有助于生成你想象中的画面。最简单的就是直接添加颜色词，比如<code>red</code>,
<code>black</code>,
<code>blue</code>等等，但这样效果不一定好。一般来说，我们可以增加带有色彩意向的词，比如<code>rainbow</code>,
<code>vibrant</code>, <code>warm color</code>, <code>prismatic</code>,
<code>black and white</code>, <code>monochrome</code>,
<code>high contrast</code>等等。</p>
<p>下面以<code>a medium shot portrait of a beautiful women in dark green kimono, beautiful face, smile, blue eyes, long black hair, painted by Anne Stokes, rembrandt lighting, [color], ultra detailed, plume --ar 2:3 --s 5000</code>为基础Prompt，分别以<code>vibrant color</code>,
<code>prismatic</code>, <code>black and white</code>,
<code>monochrome</code>,
<code>colorful, rainbow</code>为颜色关键词：</p>
<p><img data-src="/images/ai-drawing/mj/20.png" /></p>
<h4 id="形状">形状</h4>
<p>你还可以添加形状关键词。这个形状不一定是常见的三角形、正方形，也可以是跟形状有关的物体，比如金字塔<code>pyramid</code>,
星星<code>star</code>，心形<code>heart</code>等等。</p>
<p>比如以<code>a mountain, [shape] --ar 9:16</code>为基础Prompt，考察下述形状<code>star trapezohedron</code>,
<code>star prism</code>, <code>torus</code>, <code>polygonal</code>,
<code>polyhedron</code>, <code>interior</code>, <code>stellation</code>,
<code>square</code>, <code>heart</code>, <code>gear</code>：</p>
<p><img data-src="/images/ai-drawing/mj/21.png" /></p>
<p><code>polygon</code>（多边形）是一种常见的风格，<code>interior</code>则会绘制物体的内部。</p>
<h4 id="其他">其他</h4>
<p>一些其他对画面有帮助的词包括： -
细节程度：<code>very detailed</code>, <code>spectacular details</code>,
<code>ultra detailed</code>, <code>intricate details</code> -
清晰度：<code>4k</code>, <code>8k</code>, <code>high definition</code> -
景深：<code>depth of field</code>, <code>Canon 50mm</code> -
情绪：<code>enchanting</code>, <code>impressive</code> -
气氛/环境：<code>vintage</code>, <code>retro</code>,
<code>cosmic</code>, <code>celestial</code>, <code>seaside</code>,
<code>lucid dream</code>, <code>plume</code>, <code>Gossamer</code> -
绘法：<code>spatter</code>, <code>drips</code></p>
<p>你也可以增加其他的意象词。</p>
<h3 id="参数列表">参数列表</h3>
<p>你可以在Prompt的最后添加一些参数，用于生成你想要的图片风格和质量。下面列出所有参数，其中加粗的是最常用的。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">参数</th>
<th style="text-align: left;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">/imagine</td>
<td style="text-align: left;">呼出prompt，根据文本描述生成四张图片</td>
</tr>
<tr class="even">
<td style="text-align: left;">/info</td>
<td style="text-align: left;">查看当前正在运行的任务</td>
</tr>
<tr class="odd">
<td style="text-align: left;">/fast(/relax)</td>
<td style="text-align: left;">切换为使用Fast/Relax GPU时间</td>
</tr>
<tr class="even">
<td style="text-align: left;">/private</td>
<td
style="text-align: left;">切换为private模式，其他人不可见你的图片</td>
</tr>
<tr class="odd">
<td style="text-align: left;">/public</td>
<td style="text-align: left;">切换为public模式，其他人可见你的图片</td>
</tr>
<tr class="even">
<td style="text-align: left;">--hd</td>
<td
style="text-align: left;">使用旧算法，适用于抽象和风景图，图片分辨率更高</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>--ar <n:n></strong></td>
<td style="text-align: left;">显式指定图片的宽高比，比如 --ar 16:9</td>
</tr>
<tr class="even">
<td style="text-align: left;">--w <n></td>
<td style="text-align: left;">显式指定图片的宽度，比如 --w 320</td>
</tr>
<tr class="odd">
<td style="text-align: left;">--h <n></td>
<td style="text-align: left;">显式指定图片的高度，比如 --h 256</td>
</tr>
<tr class="even">
<td style="text-align: left;">--seed <n></td>
<td style="text-align: left;">显式指定种子数</td>
</tr>
<tr class="odd">
<td style="text-align: left;">--no <s></td>
<td style="text-align: left;">生成的排除该关键词，比如--no
plants为去掉文本中的”plants”</td>
</tr>
<tr class="even">
<td style="text-align: left;">--iw <f></td>
<td
style="text-align: left;">设置prompt中的图片/文本权重比，默认0.25</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>--s <n></strong></td>
<td
style="text-align: left;">指定生成图片的风格化程度，值越大，图片越“抽象”，默认为2500</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>--q <f> </strong></td>
<td
style="text-align: left;">指定图片质量，默认为1，值越大，细节越多，但耗时越长</td>
</tr>
<tr class="odd">
<td style="text-align: left;">--chaos <n></td>
<td
style="text-align: left;">指定图片的随机性，值越大，生成图片越多样，范围[0,100]</td>
</tr>
<tr class="even">
<td style="text-align: left;">--fast</td>
<td style="text-align: left;">更快地生成图片，但质量会更低，近似于--q
0.5或--q 0.25</td>
</tr>
<tr class="odd">
<td style="text-align: left;">--stop <n></td>
<td style="text-align: left;">在n%的时候停止终止生成</td>
</tr>
<tr class="even">
<td style="text-align: left;">--uplight</td>
<td
style="text-align: left;">在Upscale的时候用light版本，增加更少的细节，与原图更接近</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>--testp</strong></td>
<td style="text-align: left;">生成更接近现实的图片</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>--test</strong></td>
<td style="text-align: left;">生成更多样化、风格化的图片</td>
</tr>
</tbody>
</table>
<h4 id="指定宽高比--ar">指定宽高比：--ar</h4>
<p><code>--ar</code>指定了生成图片的宽高比，默认为1:1。宽高比会极大影响所生成的图片，比如下面的例子（基础Prompt为<code>Utah teapot, wood --seed 1</code>，从上到下、从左到右分别是宽高比为1:1，2:3，4:9，4:16，3:2，16:9，9:4，16:4）：
<img data-src="/images/ai-drawing/mj/22.png" /> <img
src="/images/ai-drawing/mj/23.png" /> <img
src="/images/ai-drawing/mj/24.png" /></p>
<p>可以看到，对于同样的内容描述，宽高比直接影响所生成的内容，这是因为AI默认会“填满”整个图，所以在设定宽高比时，要注意你要生成的内容是怎样布局的。</p>
<h4 id="指定风格化程度--s">指定风格化程度：--s</h4>
<p><code>-s</code>指定了图片的风格化程度，或者"天马行空度"。默认值为2500；20000会让你的图片看起来比较抽象，但也没有完全偏离你的prompt；但是60000会让图片完全无视prompt自由发挥。</p>
<p>下面举几个例子说明（基础Prompt为<code>Utah teapot, wood --ar 16:9 --seed 1</code>，左边是2500，中间是20000，右边是60000）：</p>
<p><img data-src="/images/ai-drawing/mj/25.png" /></p>
<p>可以看到，<code>--s 20000</code>时图片的某些部分已经不符合输入的Prompt里，比如这里丢失了木头材质的信息；<code>--s 60000</code>时就开始放飞自我了。</p>
<p>对于这个参数，一般来说保持默认即可，如果你想要更多样化的结果，可以用5000~10000之间的值。</p>
<h4 id="指定细节度--q">指定细节度：--q</h4>
<p><code>-q</code>指定了图片的质量，也就是细节的丰富度。默认值为1；2会让图片细节更加丰富，但生成速度也是原来的一半；5会让图片细节爆表，但也有可能导致图片整体效果很差。</p>
<p>下面举几个例子说明（基础Prompt为<code>Utah teapot, wood --ar 16:9 --seed 1</code>，左边是0.25，中间是1，右边是2）：</p>
<p><img data-src="/images/ai-drawing/mj/26.png" /></p>
<p>可以看到，图片的细节度是递增的。当然这个例子过于简单了，导致细节度高的茶壶反而有点奇怪。</p>
<p>这个参数我比较喜欢用<code>--q 1.5</code>，谁不喜欢更多细节呢？</p>
<h4
id="生成更逼真风格化的图片--testp---test">生成更逼真/风格化的图片：--testp,
--test</h4>
<p><code>--testp</code>让生成的图片更加逼真，而<code>--test</code>会让图片更加风格化。注意这二者都会只输入一张图片而不是通常的四张图。</p>
<p>下面有个例子（基础Prompt为<code>Japanese house with pink roof --ar 16:9 --seed 1</code>，左边为<code>--testp</code>，右边为<code>--test</code>）：</p>
<p><img data-src="/images/ai-drawing/mj/27.png" /></p>
<p>左侧的房子很逼真，右侧则不完整。当然这个例子可能不够好，但足以说明这两个参数的区别。</p>
<p>值得注意的是，并不是增加了<code>--testp</code>生成的图片就一定是更<strong>现实</strong>的，但一般而言是更<strong>逼真</strong>的。比如你想生成一张二次元萌妹，加了<code>--testp</code>之后反而可能会让萌妹更加仿真，虽然我们都知道她不是现实中存在的。</p>
<h3 id="加入参考图片">加入参考图片</h3>
<p>除了纯文字内容外，Prompt还支持插入图片，让生成的图片在内容和风格上参考给定的图片。</p>
<p>要插入图片，只需要把图片的链接放在Prompt开头就可以了，比如：
<code>https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Utah_teapot_(solid).stl/1200px-Utah_teapot_(solid).stl.png Utah Teapot --ar 16:9 --seed 1</code>
这个Prompt最开始的链接就是图片地址，然后就是常规的文本内容，把原图和生成的图片做个对比：</p>
<p><img data-src="/images/ai-drawing/mj/28.png" /></p>
<p>再对比一下没有参考图生成的图片<code>Utah Teapot --ar 16:9 --seed 1</code>：</p>
<p><img data-src="/images/ai-drawing/mj/29.png" /></p>
<p>显然，有参考图生成的图片在风格和形状上都更接近所提供的图，而没有参考图所生成的图片差异较大。</p>
<p>此外，你还可以通过参数<code>--iw</code>控制参考图的权重，默认是0.25。下面再分别给出权重为0.5和1时所生成的图：</p>
<p><img data-src="/images/ai-drawing/mj/30.png" /></p>
<p>可以看到，AI在很努力地模仿参考图的颜色、形状，但仍然颇有难度。一般来说，用默认的数值就可以了，如果你想要参考图的权重更大些，设置为0.5也足够了。</p>
<h3 id="实战操作">实战操作</h3>
<p>我们把上面说的综合起来使用给几个例子。</p>
<h4 id="吉卜力风格的风景">吉卜力风格的风景</h4>
<p>第一个例子，我想生成一只小船在水村中航行的图，村落有着丰富的细节，吉卜力的风格，同时增加一些晨光。我可以用这个Prompt：<code>A boat ride through a flooded seaside village, beautiful elaborate architecture, painted by Miyazaki, Nausicaa Ghibli, morning lighting, high saturation, spectacular details, epic composition, wide angle, low angle --ar 9:32 --q 1.5</code>，经过几轮比较随意的迭代，我找到下面几张还不错的图：</p>
<p><img data-src="/images/ai-drawing/mj/31.png" /> <img
src="/images/ai-drawing/mj/32.png" /></p>
<h4 id="黑暗系风格的怪物">黑暗系风格的怪物</h4>
<p>在第二个例子中，我想设计一个黑暗系风格的怪物。女神似乎在一般的作品中是一个正面的形象，那如果是一个腹黑女神呢？从这个出发，我试着尝试让AI画出一个黑暗系的腹黑女神，有白色裙子、邪恶笑容、黑色翅膀和金色花饰，绘画风格偏现实主义，艺术家选定为Dorothea
Tanning。</p>
<p>最后我把Prompt设定为<code>a full body portrait of a wicked goddness, beautiful white dress, evil smile, red eyes, black wings, shining gold flowers on her hair, concept art, photo realistic, painted by Dorothea Tanning, back lighting, dramatic lighting, greyscale, intricate details, bold brushstrokes, mystical --ar 2:3</code>，给出了下面的几张图（最后两张图使用了<code>--testp</code>）：</p>
<p><img data-src="/images/ai-drawing/mj/33.png" /></p>
<p>上面的图比较明显的不足是人物脸部，尤其是眼睛都没有得到很好的处理，这是当前MJ画全身照的缺点。当我们画半身照人物特写的时候一般没有这个问题。</p>
<h4 id="蒸汽朋克风格的建筑">蒸汽朋克风格的建筑</h4>
<p>第三个例子，我们想画一个蒸汽朋克风格的建筑，细节越多越好。坐落在水边，有丰富的光影，整体基调呈现暖色。</p>
<p>因此，我们选用Prompt<code>a beautiful magnificent steampuck building by the seaside, view from the sea, rigorous architecture, ultra realistic, epic composition, wide angle, close up, morning lighting, volumetric lighting, warm colors, intricate details, 8K, hd, unreal engine, enchanting --ar 9:32 --test --creative</code>，生成了下面几幅图：</p>
<p><img data-src="/images/ai-drawing/mj/34.png" /></p>
<p>加入一点艺术家得到下面的图（图一二<code>painted by Earl Norem, Edwin Lord Weeks</code>，图三<code>painted by Elizabeth Shippen Green</code>，图四<code>Ford Madox Brown</code>，图五<code>Farel Dalrymple</code>，图六<code>François Schuiten</code>，图七<code>Franz Marc</code>，图八<code>Georges Rouault</code>）：</p>
<p><img data-src="/images/ai-drawing/mj/35.png" /></p>
<p>在实验的过程中发现：<strong>不要将<code>--testp</code>用于风景图，否则会有奇怪的东西；相反，在人物图上用<code>--testp</code>效果很好。</strong></p>
<h2 id="使用建议">使用建议</h2>
<p>基于上面的使用方法和我自己的实验，初步建议大家在使用的时候遵循下述规范：</p>
<ul>
<li>重视参数<code>--ar</code>！很有时候宽高比会严重影响生成的图片，即使输入的其他内容完全一致。比如你想画个人物肖像，如果你的宽度太小无法容纳一张脸，那么AI就完全不会生成正确的肖像画；而如果宽度太大，则可能会出现多个人或者其他不必要的元素。一般来说，宽高比和画面内容的关系如下：
<ul>
<li>人物特写/Headshot：使用<code>--ar 1:1</code>或者<code>--ar 3:4</code>，并搭配<code>headshot</code>,
<code>closeup</code>, <code>portrait</code>等关键词</li>
<li>人物半身照/全身照/角色设计：使用<code>--ar 3:4</code>或<code>--ar 9:16</code>，搭配<code>full body</code>,
<code>head and shoulder shot</code>, <code>over the shoulder</code>,
<code>medium shot</code>等关键词</li>
<li>风景图/远景：使用<code>--ar 16:9</code>，搭配<code>landscape</code>,
<code>establishing shot</code>, <code>epic composition</code>等关键词
宽高比的选择完全取决于<strong>你想要生成怎样的内容</strong>，如果你想生成一个竖版的风景图，也完全可以使用<code>--ar 9:16</code>，总的原则就是<strong>!!#e06666
画面内容与宽高比保持一致!!</strong>！</li>
</ul></li>
<li>重视艺术风格！一个合适的艺术风格可以给你的画面带来极大的改变。当你需要偏现实的风格时，可以尝试<code>realistic</code>,
<code>photo realistic</code>,
<code>ultra realistic</code>等关键词，然后去找合适的现实主义风格的艺术家。当你需要特定的风格时，请精准描述艺术风格，比如浮世绘<code>ukiyo-e</code>，油画<code>oil painting</code>，流行艺术<code>pop art</code>，赛博朋克<code>cyber punk</code>，封面画<code>cover art</code>,
吉卜力<code>Ghibli</code>等等，这需要你对现有的艺术风格有比较丰富的了解！很多时候并不是你画不出来，而是你找不到对应的风格。你可以使用<strong>同一风格</strong>的多个艺术家作为关键词让画面更加倾向该风格。</li>
<li>重视参数<code>--test</code>和<code>--testp</code>！有时候仅用普通的2*2图片不能得到比较好的结果，尤其是Prompt较长的时候。此时，可以多用一下参数<code>--test</code>和<code>--testp</code>，也许会带来意想不到的结果。注意，<code>--testp</code>不要用于风景图。</li>
<li>重视参考图！尽管本教程没有过多阐述参考图的效果，但是当你手头有很多参考图时，不妨直接使用它们。记得调整参考图的权重<code>--iw</code>。</li>
<li>重视”魔法“关键词！有一些比较通用的关键词，比如<code>intricate details</code>,
<code>unreal engine 5</code>, <code>enchanting</code>,
<code>ornate</code>, <code>after effect</code>,
<code>well composed</code>, <code>elaborate</code>,
<code>Sony Alpha</code>等等，可能会提升画面的细节效果，不妨多试试它们。</li>
<li>多尝试，出一张效果好的图需要运气，也需要认真地调试。</li>
</ul>
<p>最后奉上几张AI绘制的浮世绘风格的图片，希望大家使用愉快 ;p</p>
<p><img data-src="/images/ai-drawing/mj/36.png" /></p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://midjourney.gitbook.io/docs/">MJ官方文档</a><br />
<a
href="https://promptomania.com/midjourney-prompt-builder/">关键词参考工具</a><br />
<a
href="https://github.com/willwulfken/MidJourney-Styles-and-Keywords-Reference">更完整的关键词参考</a><br />
<a
href="https://docs.google.com/spreadsheets/d/1cm6239gw1XvvDMRtazV6txa9pnejpKkM5z24wRhhFz0/edit#gid=438712621">艺术家参考</a><br />
<a
href="https://docs.google.com/document/d/11H9aDzu0al-wlLm2B4S5BwBdzW9gs5nH5dGloXKUPhI/ed">风格参考</a><br />
<a href="https://www.krea.ai/">其他人的作品参考1</a><br />
<a href="https://lexica.art/?">其他人的作品参考2</a></p>
<h1 id="novelai不完全使用指南">NovelAI不完全使用指南</h1>
<h2 id="太长不看版使用规范-1">太长不看版：使用规范</h2>
<ol type="1">
<li><p>首先按照公式 <strong><em>Prompt = 起手叠BUFF + 构图说明 +
画面内容 + 画面风格 + 光影设置 + 颜色设置 + 其他意象</em></strong>
去写Prompt，具体来说：</p>
<ul>
<li><strong>起手叠BUFF</strong>：把下面的内容放到你要写的Prompt最前面，起手BUFF还是比较重要的：
<code>&#123;masterpiece&#125;, &#123;best quality&#125;, &#123;ultra-detailed&#125;, illustration, beautiful, 8K, small breasts</code>
最后的<code>small breasts</code>可以换成<code>madium breasts</code>或者其他（你懂的）。</li>
<li><strong>构图说明</strong>：人物在画面中的位置、大小、角度等等，常用的有<code>portrait</code>（特写）、<code>medium shot</code>（半身照）、<code>full body</code>或<code>upper body</code>（全身照）、<code>dutch angle</code>（倾斜镜头）、<code>wide angle</code>（广角镜头）、<code>side view</code>（从侧面看）、<code>back view</code>（从后面看）等等。</li>
<li><strong>画面内容</strong>：画面里需要包含的各种内容，可以从人物本身和背景两个角度分别描述。人物内容包括头发、脸部、眼睛、肩膀、耳朵、配饰、手、服装、手套、鞋子等等，但首先需要指定包含几个人，比如<code>1 girl</code>,
<code>solo</code>；背景就根据自己的需求增加内容即可，比如<code>dragon background</code>,
<code>forest background</code>, <code>beautiful milkyway</code>,
<code>burning bettlefield</code>等等。此外，你还可以使用关键词<code>reference sheet</code>生成三视图、设计图。</li>
<li><strong>画面风格</strong>：画面的美术风格，常用的包括<code>realistic</code>,
<code>outline</code>, <code>sketch</code>, <code>flat color</code>,
<code>watercolor (medium)</code>, <code>grey scale</code>,
<code>ukiyo-e</code>, <code>cover art</code>, <code>poster</code>,
<code>comic</code>, <code>art nouveau</code>, <code>cyberpunk</code>,
<code>sci-fi</code>, <code>wildstyle</code>, 等等。</li>
<li><strong>光影设置</strong>：和MJ一样，设置画面的光影，主要包括：背光<code>backlight</code>,
电影打光<code>cinematic lighting</code>, 圣光<code>holy light</code>,
日光<code>sunlight</code>, 月光<code>moonlight</code>,
波光粼粼<code>glistening light of waves</code>,
金色光<code>golden light</code>等等，你也可以根据需求创造属于你的光影。</li>
<li><strong>颜色设置</strong>：使用颜色关键词让画面整体更偏向某种颜色。</li>
<li><strong>其他意象</strong>：你可以加入任意多的其他意象词为画面添加细节和内容，比如：阳光<code>sunlight</code>,
河流<code>river</code>, 水晶<code>crystal</code>,
棱镜<code>prism</code>, 冰<code>ice</code>, 浮动<code>floating</code>,
照射<code>shine</code>, 影子<code>shadow</code>,
装饰<code>ornament/decoration/frills</code>, 火焰<code>flames</code>,
火花<code>sparks</code>, 光晕<code>flares</code>,
核爆<code>nuclear explosion</code>,
飞溅的血<code>splashing blood</code>,
飞舞的花瓣<code>flying petals</code>, 等等。</li>
</ul></li>
<li><p>把下面的内容写到Undesired
Content中，然后再加入你想屏蔽的其他关键词：
<code>&#123;&#123;&#123;ugly&#125;&#125;&#125;,&#123;&#123;&#123;duplicate&#125;&#125;&#125;,&#123;&#123;morbid&#125;&#125;,&#123;&#123;mutilated&#125;&#125;,&#123;&#123;&#123;tranny&#125;&#125;&#125;,&#123;breast&#125;,mutated hands,&#123;&#123;&#123;poorly drawn hands&#125;&#125;&#125;,&#123;&#123;bad anatomy&#125;&#125;,&#123;&#123;&#123;bad proportions&#125;&#125;&#125;,extra limbs,cloned face,&#123;&#123;&#123;disfigured&#125;&#125;&#125;,&#123;&#123;&#123;more than 2 nipples&#125;&#125;&#125;,&#123;&#123;&#123;&#123;missing arms&#125;&#125;&#125;&#125;,&#123;&#123;&#123;extra legs&#125;&#125;&#125;,&#123;&#123;&#123;&#123;&#123;fused fingers&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;&#123;&#123;too many fingers&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;unclear eyes&#125;&#125;&#125;,&#123;&#123;&#123;fused hands&#125;&#125;&#125;,&#123;&#123;&#123;fused leg&#125;&#125;&#125;,&#123;&#123;&#123;bad feet&#125;&#125;&#125;,nsfw,lowers,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,worst quality,low quality,normal quality,jpeg artifacts,signature,watermark,username,blurry,bad</code></p></li>
<li><p>Steps默认<strong>28</strong>，Scale默认为<strong>7</strong>，当然你可以根据实际需求调整这两个值。Samping使用默认的k_euler_ancestral即可；</p></li>
<li><p>对你比较满意的图使用<strong>Variation</strong>和<strong>Enhance</strong>，反复迭代，直到满意为止。</p></li>
</ol>
<h2 id="概述-1">概述</h2>
<p>NovelAI是基于Stable
Diffusion模型改进的AI绘画工具，它擅长绘制二次元人物图，虽然也可以把它当作综合性的绘画工具，但是生成的图片偏写实，质量不如Midjourney。</p>
<p>写NovelAI
Prompt的基本准则是：<strong>用关键词（或者称为Tag）描述，而不要用短语甚至句子。</strong>关键词包括画面内容（人物头发、眼睛、表情、服饰、姿势、手部、胸部、肩部，等等）、画面风格、构图设置、光影设置、颜色设置、意象词和叠BUFF词等等。</p>
<p>总的来说，写NovelAI
Prompt相比MJ更容易些，但要实现精准调教仍然难度很大。下面会详细介绍。</p>
<p><a
href="https://docs.novelai.net/image/basics.html">NovelAI官方文档</a><br />
<a href="https://aitag.top/">关键词参考</a></p>
<h2 id="注册账号官方">注册账号（官方）</h2>
<ol type="1">
<li><p>登陆<a
href="https://novelai.net/">官网</a>，注册并登陆账号。</p></li>
<li><p>之后在打开的页面上点击“Generate Images”，或者直接通过<a
href="https://novelai.net/image">网页</a>进入： <img
src="/images/ai-drawing/novelai/1.png" /></p></li>
<li><p>最后输入Prompt并调整右侧参数开始使用： <img
src="/images/ai-drawing/novelai/2.png" /></p></li>
</ol>
<h2 id="本地版本">本地版本</h2>
<p>To do</p>
<h2 id="使用教学-1">使用教学</h2>
<p>NovelAI的Prompt跟MJ差不多，主要遵循下述公式： <strong><em>Prompt =
起手叠BUFF + 构图说明 + 画面内容 + 画面风格 + 光影设置 + 颜色设置 +
其他意象</em></strong></p>
<p>在介绍每个部分之前，需要先讲解下NovelAI各个参数的作用。</p>
<h3 id="novelai的参数">NovelAI的参数</h3>
<p><img data-src="/images/ai-drawing/novelai/3.png" /></p>
<p>从上到下，从左到右：</p>
<ul>
<li><strong>Prompt</strong>：在这个地方输入你的Prompt，使用大括号<code>&#123;&#125;</code>增加一个关键词的权重，使用中括号<code>[]</code>去减少关键词的权重，支持嵌套，比如<code>&#123;&#123;magical&#125;&#125;</code>就表示生成图像的时候会特别关注<code>magical</code>的内容，而<code>[[[green]]]</code>则表示生成时尽量避免生成绿色的内容；</li>
<li><strong>分辨率</strong>：在这里设置你图像的分辨率，可以使用预设，也可以手动输入，<strong>这个参数非常重要，同MJ，要和你生成的内容相匹配</strong>；</li>
<li><strong>Number of images</strong>：生成图像的数量；</li>
<li><strong>Undesired
Content</strong>：输入不想要AI生成的内容的关键词；</li>
<li><strong>Add Quality Tags</strong>：默认勾上就行；</li>
<li><strong>Steps</strong>：生成一张图需要的步数，步数越大，生成的时间越长，而且效果也不一定好，一般使用默认值28就好了，除非你已经找到一个很好的Prompt想要增加更多的细节；</li>
<li><strong>Scale</strong>：控制所生成图像匹配你输入Prompt的程度，值越小，画面越风格化和柔和，值越大，画面越细节和尖锐，但设置过大可能导致效果变差，一般来说使用小于10的值；</li>
<li><strong>Sampling</strong>：生成时的采样方法，一般而言使用默认的即可。</li>
</ul>
<p><img data-src="/images/ai-drawing/novelai/4.png" /></p>
<p>在生成图像后，会多出来一排选项，其中比较重要的是后面两个：</p>
<ul>
<li><strong>Variations</strong>：生成当前图片的变体，在细节上会有不同，但大体都是一样的；</li>
<li><strong>Enhance</strong>：对当前图像进行增强，会较显著地增加细节。但注意不要把Noise调太高。</li>
</ul>
<h3 id="起手叠buff">起手叠BUFF</h3>
<p>NovelAI要把关键信息放在Prompt的前面，因此我们一开始就要叠BUFF，可以先无脑加入下面的BUFF，然后再根据你的需求自行添加：
<code>&#123;masterpiece&#125;, &#123;best quality&#125;, &#123;ultra-detailed&#125;, illustration, beautiful, 8K, small breasts</code></p>
<p><strong>注意上面的最后一个BUFF<code>small breasts</code>限制了生成角色胸的大小，对于女性角色必须要有（否则全是涩图）！你如果不喜欢平胸，可以用<code>medium breasts</code>，或者你生成的不是女性，就把这个去掉即可。</strong></p>
<h3 id="构图说明-1">构图说明</h3>
<p>和MJ一样，可以用<code>portrait</code>表示特写，用<code>medium shot</code>/<code>upper body</code>表示上半身构图，用<code>full body shot</code>表示全身照。</p>
<p>除此之外，还可以用<code>dutch angle</code>表示倾斜镜头，用<code>wide angle</code>表示广角镜头，用<code>low angle</code>表示低角镜头，用<code>depth of field</code>增加景深，用<code>side view</code>表示从侧面看，等等。你可以根据自己想象中的内容选择合适的组合。</p>
<p><strong>!!#3d85c6 这个网站有一些主要的关键词：https://aitag.top/
。下面的所有内容都可以去参考这个网站，不再赘述。!!</strong></p>
<p>比如下面我用了一些不同的构图关键词去生成<code>a beautiful girl</code>（关键词分别是<code>portrait</code>,
<code>medium shot</code>, <code>full body shot</code>,
<code>full body shot, dutch angle</code>,
<code>portrait, dutch angle, depth of field</code>,
<code>portrait, side view</code>,
<code>full body shot, back view</code>,
<code>full body shot, from above</code>）：</p>
<p><img data-src="/images/ai-drawing/novelai/5.png" /></p>
<h3 id="画面内容-1">画面内容</h3>
<p>你首先需要明确图片中包含几个角色，一般来说是一个，那么你只需要加入<code>solo</code>和<code>1 girl</code>/<code>1 boy</code>即可。如果是两个，就是<code>two girls</code>，以此类推。</p>
<p>然后，你需要描述这个角色的各种细节，可以从下面角度考虑（不一定都要，看你需求）：</p>
<ul>
<li>头发：<code>disheveled hair</code>, <code>floating hair</code>,
<code>azure hair</code>, <code>long hair</code>,
<code>short hair</code>, <code>beautiful hair</code>,
<code>white hair</code>, <code>curly hair</code>, <code>bob hair</code>,
<code>polytails</code>, <code>updo</code>,
<code>twintails</code>，<code>side blunt bangs</code>，等等</li>
<li>脸部：<code>tears</code>, <code>cold attitude</code>,
<code>smile</code>, <code>sad</code>, <code>annoyed</code>,
<code>delicate beautiful face</code>,
<code>detailed face</code>，等等</li>
<li>眼睛：<code>Lavender eyes</code>, <code>crystal eyes</code>,
<code>bright eyes</code>, <code>beautiful detailed eyes</code>,
<code>half closed eyes</code>, <code>hollow eyes</code>,
<code>blank stare</code>, <code>rainbow eyes</code>,
<code>gradient eyes</code>, <code>sparking eyes</code>，等等</li>
<li>肩膀：<code>bare shoulder</code>, <code>off shoulder</code></li>
<li>耳朵：<code>pointy ears</code></li>
<li>手：<code>outstretched arms</code>, <code>arms behind back</code>,
<code>hands on hips</code>, <code>hand on own face</code>,
<code>hugging own legs</code>, <code>hand in own hair</code>,
<code>holding flowers</code>，等等</li>
<li>配饰：<code>gold accessories</code>, <code>white lightsaber</code>,
<code>tail</code>, <code>scarf</code>, <code>armor headdress</code>,
<code>ribbon</code>, <code>neck ribbon</code>, <code>hair ribbon</code>,
<code>halo</code>, <code>necklace</code>, <code>wings</code>,
<code>tassel</code>, <code>earrings</code>, <code>wizard hat</code>,
<code>headphone</code>,
<code>red sword</code>，<code>floral print</code>, 等等</li>
<li>服装：<code>detailed mechanical armor</code>,
<code>detailed organdie dress</code>, <code>skyblue dress</code>,
<code>princess dress with delicate gold metal decorations</code>，
<code>witch dress</code>, <code>white thin detailed cloak</code>,
<code>summer long skirt</code>, <code>angel suit</code>,
<code>very long dress</code>,
<code>translucent fluttering dress with lace</code>，<code>kimono</code>，<code>trench coat</code>,
<code>cheongsam</code>，<code>pettiskirt</code>,
<code>lolita gothic</code>，<code>pleated skirt</code>, 等等</li>
<li>手套/袖子：<code>detailed white gloves</code>,
<code>elbow gloves</code>, <code>sleeveless</code>,
<code>wide sleeves</code>, <code>large top sleeves</code>, 等等</li>
<li>鞋子：<code>barefoot</code>, <code>thigh boots</code>,
<code>geta</code>，<code>uwabaki</code>, 等等</li>
</ul>
<p>建议平时可以多看别人的关键词然后记录下来。</p>
<p>使用不同的组合并加入不同的权重可以产生你想要的效果，比如下面的例子：</p>
<p><img data-src="/images/ai-drawing/novelai/6.png" /></p>
<p>除了角色本身的细节之外，你还可以指定<strong>背景</strong>，比如没有背景<code>no background</code>,
以龙为背景<code>dragon background/loong background</code>，以森林为背景<code>forest background</code>，大火为背景<code>fire background/burning background</code>，如下（不同的背景需要不同的权重）：</p>
<p><img data-src="/images/ai-drawing/novelai/7.png" /></p>
<p><strong>特别说明：如果你想要生成人物设计图（即三视图），你可以用<code>reference sheet</code>，并同时修改分辨率</strong>：</p>
<p><img data-src="/images/ai-drawing/novelai/8.png" /></p>
<h3 id="画面风格">画面风格</h3>
<p>顾名思义，就是需要选择图片的美术风格，下面有一些供参考的风格及其关键词选择：</p>
<ul>
<li>写实：<code>realistic</code>, <code>photorealistic</code></li>
<li>素描：<code>sketch</code>, <code>rough sketch</code>,
<code>pencil sketch</code></li>
<li>描边：<code>outline</code></li>
<li>线稿：<code>lineart</code></li>
<li>像素：<code>pixel art</code></li>
<li>平涂：<code>flat color</code></li>
<li>平面着色：<code>flat shading</code>（注意和平涂不一样，下有例子）</li>
<li>水彩：<code>watercolor (medium)</code>,
<code>watercolor pencil (medium)</code></li>
<li>单色：<code>monochrome</code>, <code>spot color</code>,
<code>greyscale</code></li>
<li>浮世绘：<code>ukiyo-e</code></li>
<li>苏维埃海报：<code>soviet poster</code></li>
<li>封面：<code>cover art</code></li>
<li>漫画书：<code>comic book</code></li>
<li>动漫：<code>comic</code></li>
<li>Q版：<code>chibi</code></li>
<li>复古艺术：<code>retro artstyle</code></li>
<li>新艺术派：<code>art nouveau</code></li>
<li>年代：<code>1970s</code>, <code>1980s</code>,
<code>1990s</code></li>
<li>赛博朋克：<code>cyberpunk</code></li>
<li>狂野风：<code>wildstyle</code></li>
<li>科幻：<code>sci-fi</code></li>
<li>奇幻：<code>fantasy</code></li>
<li>传统日本风格：<code>traditional Japanese art</code></li>
</ul>
<p><strong>建议把风格使用至少三个大括号<code>&#123;&#123;&#123;&#125;&#125;&#125;</code>甚至更多包裹起来进行强调，确保可以生成正确的风格图。</strong></p>
<p>你可以选择同一个风格里的多个关键词，或者结合不同的风格。比如你可以融合像素风<code>pixel art</code>和奇幻风<code>fantasy</code>形成像素奇幻风。但最好不要融合超过两种风格，否则生成结果未知。</p>
<p>下面是一些例子（依次是<code>&#123;&#123;&#123;flat color&#125;&#125;&#125;</code>,
<code>&#123;&#123;&#123;flat shading&#125;&#125;&#125;</code>,
<code>&#123;&#123;&#123;soviet poster&#125;&#125;&#125;, &#123;&#123;&#123;flat color&#125;&#125;&#125;</code>,
<code>&#123;&#123;&#123;outline&#125;&#125;&#125;, &#123;&#123;&#123;sketch&#125;&#125;&#125;</code>,
<code>&#123;&#123;&#123;&#123;&#123;traditional media&#125;&#125;&#125;&#125;&#125;</code>,
<code>&#123;&#123;&#123;ukiyo-e&#125;&#125;&#125;, &#123;&#123;&#123;outline&#125;&#125;&#125;</code>,
<code>art nouveau</code>,
<code>&#123;&#123;&#123;pixel art&#125;&#125;&#125;, &#123;&#123;fantasy&#125;&#125;</code>,
<code>&#123;&#123;&#123;black and white&#125;&#125;&#125;, &#123;outline&#125;, &#123;flat shading&#125;, &#123;flat color&#125;, &#123;concept art&#125;, &#123;lines&#125;</code>,
<code>&#123;&#123;&#123;&#123;wildstyle&#125;&#125;&#125;&#125;, &#123;flat color&#125;</code>,
<code>&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;wildstyle&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;, &#123;cyberpunk&#125;, &#123;&#123;&#123;outline&#125;&#125;&#125;</code>,
<code>&#123;traditional japanese art&#125;, &#123;anime&#125;, &#123;fantasy&#125;</code>）： <img
src="/images/ai-drawing/novelai/9.png" /> <img
src="/images/ai-drawing/novelai/10.png" /></p>
<p>除了显式指定美术风格之外，你还可以指定艺术家和作品让画面偏向某种特定的风格。但是和MJ不同的是，NovelAI并不像MJ那样非常依赖艺术家，一般不加，或者最多只加一个艺术家或作品即可。比如下面我分别指定了<code>ghibili</code>,
<code>Hayao Miyazaki</code>,
<code>breath of the wild</code>和<code>dark soul</code>：</p>
<p><img data-src="/images/ai-drawing/novelai/11.png" /></p>
<p>可以看到，加入艺术家和作品并没有想象中的那样有效，所以推荐不加。</p>
<p>注：当然如果你非常熟悉某个艺术家，那加入艺术家也是可以的，但一般来说需要给艺术家比较强的权重模型才会生成比较相似的风格，而且也不是所有艺术家都支持的，还是建议多做尝试。<a
href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/blob/master/artists.csv">这个表</a>是已记录的一些艺术家，可以根据风格先在谷歌上搜索，然后自行尝试。</p>
<h3 id="光影设置-1">光影设置</h3>
<p>这里的光影设置和MJ是一样的，比如下面的光影：
背光<code>backlight</code>, 电影打光<code>cinematic lighting</code>,
柔和光<code>soft lighting</code>,
体积光<code>volumetric lighting</code>,
点光（聚光灯）<code>spotlight</code>, 圣光<code>holy light</code>,
日光<code>sunlight</code>, 月光<code>moonlight</code>,
波光粼粼<code>glistening light of waves</code>,
金色光<code>golden light</code>：</p>
<p><img data-src="/images/ai-drawing/novelai/12.png" /></p>
<h3 id="颜色设置">颜色设置</h3>
<p>颜色没太多好说的，如果你想要画面整体偏某种颜色，直接加入颜色关键词即可。
但更好的方法是直接指定某个物体的颜色，比如<code>red eyes</code>,
<code>cyan hair</code>，以实现精准控制。有时候需要加大物体的权重，避免这个颜色控制了其他部件。</p>
<h3 id="其他意象">其他意象</h3>
<p>其他意象词一般用来增加前景和背景的丰富度，以及人物身上的细节，比如下面的一些关键词：
羽毛<code>feather</code>, 自然<code>nature</code>,
叶子<code>leaves</code>, 阳光<code>sunlight</code>,
河流<code>river</code>, 水晶<code>crystal</code>,
棱镜<code>prism</code>, 冰<code>ice</code>, 齿轮<code>gear</code>,
流动<code>flowing</code>, 浮动<code>floating</code>,
照射<code>shine</code>, 影子<code>shadow</code>, 时钟<code>clock</code>,
装饰<code>ornament/decoration/frills</code>, 火焰<code>flames</code>,
火花<code>sparks</code>, 光晕<code>flares</code>,
核爆<code>nuclear explosion</code>, 闪电<code>lightning</code>,
飞溅的血<code>splashing blood</code>,
飞舞的花瓣<code>flying petals</code>, 微风<code>breeze</code>,
风<code>wind</code>, 雨<code>rain</code>, 云<code>clouds</code>,
烟<code>smoke</code>, 雾<code>mist</code>, 纱<code>yarn</code>,
沙<code>sand</code>, 星尘<code>stardust</code>,
银河<code>milkyway</code>, 旋转<code>swirling</code>,
头骨<code>skull</code>, 骨骼<code>skeleton</code>,
几何<code>geometric</code>, 立方体<code>cubic</code>,
多边形<code>polygon</code></p>
<p>总之你可以添加任何你想要在图片中出现的意象词，但要注意和整体画面内容的搭配。你可以通过调整词的权重控制意象出现的频率。</p>
<p>还是建议找一些相关的参考图和别人给的关键词，多做尝试。</p>
<h3 id="负面关键词">负面关键词</h3>
<p>负面关键词是你不想让它出现在图片中的内容，填入Undesired
Content中即可。虽然是根据你不想要的内容去选择负面关键词，但是也要一些通用的负面关键词。下面是默认添加的关键词，其他关键词根据需求自行添加：
<code>&#123;&#123;&#123;ugly&#125;&#125;&#125;,&#123;&#123;&#123;duplicate&#125;&#125;&#125;,&#123;&#123;morbid&#125;&#125;,&#123;&#123;mutilated&#125;&#125;,&#123;&#123;&#123;tranny&#125;&#125;&#125;,&#123;breast&#125;,mutated hands,&#123;&#123;&#123;poorly drawn hands&#125;&#125;&#125;,&#123;&#123;bad anatomy&#125;&#125;,&#123;&#123;&#123;bad proportions&#125;&#125;&#125;,extra limbs,cloned face,&#123;&#123;&#123;disfigured&#125;&#125;&#125;,&#123;&#123;&#123;more than 2 nipples&#125;&#125;&#125;,&#123;&#123;&#123;&#123;missing arms&#125;&#125;&#125;&#125;,&#123;&#123;&#123;extra legs&#125;&#125;&#125;,&#123;&#123;&#123;&#123;&#123;fused fingers&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;&#123;&#123;too many fingers&#125;&#125;&#125;&#125;&#125;,&#123;&#123;&#123;unclear eyes&#125;&#125;&#125;,&#123;&#123;&#123;fused hands&#125;&#125;&#125;,&#123;&#123;&#123;fused leg&#125;&#125;&#125;,&#123;&#123;&#123;bad feet&#125;&#125;&#125;,nsfw,lowers,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,worst quality,low quality,normal quality,jpeg artifacts,signature,watermark,username,blurry,bad</code></p>
<h3 id="实战操作-1">实战操作</h3>
<p>下面还是给几个实战操作的例子。</p>
<h4 id="和服风的设计稿">和服风的设计稿</h4>
<p>第一个例子，我们想要一个三视图设计稿，主角是一个穿着和服的传统日本女孩，盘发、头上有红色的花、化妆、精致的手镯、漂亮的印花。因为是设计图，所以要调整下分辨率，用默认的Landscape就好了。因此，我用的Prompt是：<code>&#123;&#123;masterpiece&#125;&#125;, &#123;&#123;best quality&#125;&#125;, &#123;&#123;ultra-detailed&#125;&#125;, illustration, beautiful, 8K, small breasts, full body, solo, a japanese girl, &#123;&#123;&#123;&#123;&#123;reference sheet&#125;&#125;&#125;&#125;&#125;, flat color, concept art, brown hair, red flower in hair, &#123;updo&#125;, smile, beautiful face, beautiful makeup, delicate bracelet, &#123;beautiful kimono with intricate floral print&#125;</code></p>
<p>下面是生成的一些图（尝试了不同的Steps和Scale，Steps大则细节更丰富，Scale越小则多样性越强，但建议Steps&lt;=40,
Scale&gt;=6。最后一张图给和服加了<code>blue</code>）： <img
src="/images/ai-drawing/novelai/13.png" /> <img
src="/images/ai-drawing/novelai/14.png" /></p>
<p>可以看到，人物的手和脚是重灾区，但其他地方还是可以的。另外，活用<code>Enhance</code>能够极大地修复手的问题，关键在于<code>Strength</code>的参数不要太大（0.3左右），<code>Noise</code>设置为0或者非常小。</p>
<h4 id="机甲少女全身照">机甲少女全身照</h4>
<p>第二个例子，我想要画一个机甲少女的全身照，有着冷酷的表情、红色的眼睛、脸上有纹身、拿着一把红色的刀，我并不太想指定其他过多的元素，但是想要图片的背景是弥漫着硝烟的战场，空中也飞舞着火星。因此，我使用的Prompt是<code>&#123;&#123;masterpiece&#125;&#125;, &#123;&#123;best quality&#125;&#125;, &#123;&#123;ultra-detailed&#125;&#125;, illustration, beautiful, 8K, small breasts, full body, depth of field, solo, a mechanical girl, detailed  mechanical armor, detailed mechanical body&#125; &#123;holding a red sword&#125;, disheveled hair, short hair, cold stares, half-closed eyes, &#123;&#123;dark red eyes&#125;&#125;, gradient eyes, ruined battlefield background, &#123;detailed background&#125;, burning buildings, splashing sparks, flames, holy light</code>。</p>
<p>下面是生成的图（使用了不同的Steps和Scale，最后四幅图修改了机甲的颜色）：
<img data-src="/images/ai-drawing/novelai/15.png" /></p>
<h4 id="狂野赛博艺术图">狂野赛博艺术图</h4>
<p>作为我们的第三个例子，我们将探索<code>wildstyle</code>这个风格与其他关键词的组合会得到怎样的效果。<code>wildstyle</code>意味着丰富的色彩，尤其是大面积深色的应用。我们将融入赛博朋克的元素，并搭配不同的关键词看AI会给出我们怎样的结果。我使用的基础Prompt是<code>&#123;&#123;masterpiece&#125;&#125;, &#123;&#123;best quality&#125;&#125;, &#123;&#123;ultra-detailed&#125;&#125;, illustration, &#123;&#123;&#123;&#123;wildstyle&#125;&#125;&#125;&#125;, beautiful, small breasts, solo, &#123;&#123;a girl&#125;&#125;, cyberpunk</code>。</p>
<p>下面是生成的图（每张图都调整了<code>wildstyle</code>的权重，附加Prompt依次是<code></code>,
<code>&#123;flat color&#125;</code>,
<code>&#123;&#123;flat color&#125;&#125;, &#123;colorful&#125;</code>,
<code>&#123;&#123;flat color&#125;&#125;, &#123;&#123;outline&#125;&#125;</code>,
<code>sci-fi</code>,
<code>&#123;flat color&#125;, beautiful kimono with cherry floral print</code>,
<code>&#123;flat color&#125;, watercolor (medium)</code>,
<code>&#123;&#123;&#123;pixel art&#125;&#125;&#125;</code>）： <img
src="/images/ai-drawing/novelai/16.png" /></p>
<p>结果发现，<code>wildstyle</code>和<code>flat color</code>,
<code>outline</code>等关键词搭配效果很好。</p>
<h4 id="华丽高贵女神范">华丽高贵女神范</h4>
<p>第四个例子，我想要得到一个华丽高贵的女神，被白色的花簇拥着，穿着华丽的白色礼服，点缀金色丝边，戴着项链、手镯、花环，蓝色的发光的眼睛。分别尝试不同的构图，即特写、半身、全身，和不同的风格，对背景不做要求。采用的Prompt是<code>&#123;&#123;masterpiece&#125;&#125;, &#123;&#123;best quality&#125;&#125;, &#123;&#123;ultra-detailed&#125;&#125;, illustration, beautiful, 8K, very detailed, small breasts, [composition], [style], solo, a royal goddess, disheveled hair, detailed blue eyes, gradient eyes, glowing eyes, vibrant colorful garland, gorgeous princess dress with delicate gold metal decorations, &#123;&#123;white flower decorations&#125;&#125;, &#123;&#123;surrounded by flowers&#125;&#125;, exquisite bracelet, exquisite necklace, bare foot, &#123;&#123;flowing flowers&#125;&#125;, &#123;&#123;liquid&#125;&#125;</code>。其中，<code>[composition]</code>填写构图，<code>[style]</code>填写风格。</p>
<p>下面是生成的一些图片（前两张是<code>portrait</code>,
第三四张是<code>head and shoulder shot</code>,
最后四张是<code>full body</code>；风格第一张是<code>cartoon, anime</code>,
第二张<code>realistic</code>, 第三张<code>cartoon, anime</code>,
第四张<code>fantasy, flat shading</code>,
第五张<code>flat color, geometric, cubic</code>,
第六张<code>cartoon, anime</code>,
第七张<code>flat color, flowing</code>，第八张<code>dark magic, Cthulhu</code>）：
<img data-src="/images/ai-drawing/novelai/17.png" /> <img
src="/images/ai-drawing/novelai/18.png" /></p>
<h2 id="使用建议-1">使用建议</h2>
<ul>
<li><strong>重视分辨率</strong>！道理和MJ一样，即图片的分辨率要和想要生成的内容匹配，不再赘述，详细请看MJ页面。</li>
<li><strong>尝试权重</strong>！NovelAI对关键词加权是非常重要的一个操作，有时候你写的关键词没有生效极有可能就是关键词的权重不够导致的，这时候多尝试嵌套几层大括号<code>&#123;&#123;&#123;&#125;&#125;&#125;</code>。一般来说，对</li>
<li><strong>叠通用BUFF</strong>！上面给出了最基础的通用BUFF，但是对某些类型的图来说，还有一些额外的BUFF可以叠，建议多看看对不同的美术风格、画面内容，别人怎么叠BUFF的，总结一套属于自己的BUFF表。之后有时间我也会帮大家总结。</li>
<li><strong>加入风格</strong>！加入风格（包括与风格有关的关键词）会有助于生成你想要的内容，但注意与MJ不同，NovelAI对艺术家的支持并不好，所以尽量不要用艺术家。加入<code>flat shading</code>和<code>flat color</code>偶尔会有奇效，其他的一些意向词比如<code>flowing</code>,
<code>geometric</code>也能创造很好的风格。</li>
<li><strong>多尝试参数</strong>！NovelAI的参数虽然没有MJ多，但是调试更加困难。一般来说用Steps=28,
Scale=7的默认参数能够得到还不错的效果，如果你发现怎么改关键词都不生效的话，果断尝试修改参数吧（当然也有可能是NovelAI的训练集中没有你输入的内容，弃疗吧）！</li>
</ul>
<h2 id="参考资料-1">参考资料</h2>
<p><a
href="https://docs.novelai.net/image/basics.html">NovelAI官方文档</a><br />
<a
href="https://naidb.miraheze.org/wiki/Image_Generation">NovelAI图像生成注意事项</a><br />
<a href="https://aitag.top/">关键词参考</a><br />
<a href="https://docs.qq.com/doc/DWHl3am5Zb05QbGVs">元素法典——Novel AI
元素魔法全收录（第一卷）</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>深度学习</tag>
        <tag>工具</tag>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>四元数与旋转</title>
    <url>/2022/03/25/01/00/</url>
    <content><![CDATA[<p>图形学中的旋转（Rotation）非常重要，用欧拉角（Euler
Angle）旋转非常简单，但是却存在 <strong>万向锁（Gimbal Lock）</strong>
的问题；同时，用欧拉角插值也不尽方便。基于四元数（Quaternion）的旋转既解决了万向锁的问题，又能非常便利地插值。本文将从概念出发，对四元数的定义、推导、性质、应用，以及它与欧拉角之间的联系进行介绍。本文主要参考了Krasjet的《四元数与三维旋转》<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>，其他参考内容包括<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a><a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a><a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a><a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a><a href="#fn7" class="footnote-ref"
id="fnref7" role="doc-noteref"><sup>7</sup></a><a href="#fn8"
class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a>。</p>
<span id="more"></span>
<h1 id="复数与二维旋转">复数与二维旋转</h1>
<p>首先我们将简要介绍复数及它与二维旋转的关系，从而可以更加自然地过度到四元数及其与三维旋转的关系。</p>
<h2 id="定义">定义</h2>
<p>复空间<span
class="math inline">\(\mathbb{C}\)</span>中的任一复数<span
class="math inline">\(z\in\mathbb{C}\)</span>都可以表示为<span
class="math inline">\(z=a+bi\
(a,b\in\mathbb{R})\)</span>的形式，且满足<span
class="math inline">\(i^2=-1\)</span>。此时<span
class="math inline">\(a\)</span>称为复数<span
class="math inline">\(z\)</span>的实部 (Real Part)，表达为<span
class="math inline">\(a=\text{Re}(z)\)</span>；<span
class="math inline">\(b\)</span>称为复数的虚部 (Imaginary
Part)，表达为<span class="math inline">\(b=\text{Im}(z)\)</span>。</p>
<p>从线性代数的角度来看，复数<span
class="math inline">\(z=a+bi\)</span>可以看成是基 (Basis) <span
class="math inline">\(\{1,i\}\)</span>上的线性组合，因此也可以把复数<span
class="math inline">\(z\)</span>写成一个向量：</p>
<p><span class="math display">\[z=\begin{bmatrix}a\\b
\end{bmatrix}\]</span></p>
<h2 id="复数的加法与乘法">复数的加法与乘法</h2>
<h3 id="复数的加法">复数的加法</h3>
<p>复数的加法很简单，分别把实部和虚部相加即可。减法类似，不多赘述。</p>
<h3 id="复数的乘法">复数的乘法</h3>
<p>对复数<span
class="math inline">\(z_1=a+bi,z_2=c+di\)</span>，它们相乘的结果为：</p>
<p><span
class="math display">\[z_1z_2=(a+bi)(c+di)=(ac-bd)+(bc+ad)i\]</span></p>
<p>利用上面讲过的复数的向量形式，可以把上式写成矩阵乘向量的形式：</p>
<p><span class="math display">\[z_1z_2=(ac-bd)+(bc+ad)i=
\begin{bmatrix}
ac-bd\\
bc+ad
\end{bmatrix}=
\begin{bmatrix}
a &amp; -b\\
b &amp; a
\end{bmatrix}
\begin{bmatrix}
c\\
d
\end{bmatrix}\]</span></p>
<p>右侧的向量<span
class="math inline">\(\begin{bmatrix}c\\d\end{bmatrix}\)</span>就是向量形式下的<span
class="math inline">\(z_2\)</span>，而左侧的矩阵<span
class="math inline">\(\begin{bmatrix}a&amp;-b\\b&amp;a\end{bmatrix}\)</span>则是<span
class="math inline">\(z_1\)</span>在乘法时的<strong>矩阵形式</strong>，矩阵的第一列就是自身的向量形式，而第二列进行了交换并对虚部取负。</p>
<p>所以，我们可以把<span
class="math inline">\(z_2\)</span>也写成矩阵形式，然后与<span
class="math inline">\(z_1\)</span>相乘：</p>
<p><span class="math display">\[z_1z_2=
\begin{bmatrix}
a &amp; -b\\
b &amp; a
\end{bmatrix}
\begin{bmatrix}
c &amp; -d\\
d &amp; c
\end{bmatrix}=
\begin{bmatrix}
ac-bd &amp; -(bc+ad)\\
bc+ad &amp; ac-bd
\end{bmatrix}\]</span></p>
<p>所以，我们现在可以用至少三种形式去表达一个复数了（具体用哪种形式取决于我们的需要）：</p>
<ul>
<li>代数形式：<span class="math inline">\(z=a+bi\)</span>;</li>
<li>向量形式：<span
class="math inline">\(z=\begin{bmatrix}a\\b\end{bmatrix}\)</span>;</li>
<li>矩阵形式：<span class="math inline">\(z=\begin{bmatrix}a &amp; -b\\b
&amp; a\end{bmatrix}\)</span>.</li>
</ul>
<p>有两个特殊的复数<span
class="math inline">\(1,i\)</span>，它们的矩阵形式不难得到是：</p>
<p><span class="math display">\[1=\begin{bmatrix}
1 &amp; 0\\
0 &amp; 1
\end{bmatrix}=I\;(a=1, b=0)\]</span></p>
<p><span class="math display">\[i=\begin{bmatrix}
0 &amp; -1\\
1 &amp; 0
\end{bmatrix}\;(a=0, b=1)\]</span></p>
<p>对复数<span
class="math inline">\(i\)</span>的矩阵形式进行平方，发现它就是<span
class="math inline">\(-I\)</span>，从代数形式来看，就等价于<span
class="math inline">\(i^2=-1\)</span>。这说明复数的矩阵形式是良定义的。</p>
<h2 id="复数的模长">复数的模长</h2>
<p>复数<span
class="math inline">\(z=a+bi\)</span>的模长（Magnitude）定义为:</p>
<p><span class="math display">\[\|z\| =\sqrt{a^2+b^2}\]</span></p>
<p>这可以用它的共轭（Conjugate）表示：</p>
<p><span class="math display">\[\|z\| =\sqrt{z\bar{z}},\;
\bar{z}=a-bi\]</span></p>
<h2 id="复数与二维旋转-1">复数与二维旋转</h2>
<h3 id="从复数矩阵形式导出旋转关系">从复数矩阵形式导出旋转关系</h3>
<p>下面将重点引出复数与二维旋转的关系。</p>
<p>注意观察复数<span class="math inline">\(z\)</span>的矩阵形式<span
class="math inline">\(\begin{bmatrix}a &amp; -b\\b &amp;
a\end{bmatrix}\)</span>，我们可以把它变换为下述形式：</p>
<p><span class="math display">\[\begin{bmatrix}
a &amp; -b\\
b &amp; a
\end{bmatrix}=\sqrt{a^2+b^2}
\begin{bmatrix}
\frac{a}{\sqrt{a^2+b^2}} &amp; \frac{-b}{\sqrt{a^2+b^2}}\\
\frac{b}{\sqrt{a^2+b^2}} &amp; \frac{a}{\sqrt{a^2+b^2}}
\end{bmatrix}\]</span></p>
<p>矩阵中的每一项都被模长<span
class="math inline">\(\|z\|\)</span>缩放了，此时注意到<span
class="math inline">\(\frac{a}{\sqrt{a^2+b^2}}\)</span>就是复数<span
class="math inline">\(z\)</span>在复平面与实轴形成夹角<span
class="math inline">\(\theta\)</span>的余弦值<span
class="math inline">\(\cos(\theta)\)</span>，而<span
class="math inline">\(\frac{b}{\sqrt{a^2+b^2}}\)</span>正好对应了正弦值<span
class="math inline">\(\sin(\theta)\)</span>，而这个夹角<span
class="math inline">\(\theta\)</span>就是<span
class="math inline">\(\arctan(b/a)\)</span>。</p>
<p>这样一来，我们就可以把上式写成：</p>
<p><span class="math display">\[
\begin{align}
\begin{bmatrix}
a &amp; -b\\
b &amp; a
\end{bmatrix}&amp;=\|z\|
\begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta)\\
\sin(\theta) &amp; \cos(\theta)
\end{bmatrix}=
\begin{bmatrix}
\|z\| &amp; 0\\
0 &amp; \|z\|
\end{bmatrix}
\begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta)\\
\sin(\theta) &amp; \cos(\theta)
\end{bmatrix}
\label{eq1}
\end{align}
\]</span></p>
<p>这样一来，任意复数<span
class="math inline">\(z=a+bi\)</span>都可以表示为两个矩阵的乘积，一个缩放矩阵<span
class="math inline">\(\begin{bmatrix}\|z\| &amp; 0\\0 &amp;
\|z\|\end{bmatrix}\)</span>和一个（我们熟悉的）旋转矩阵<span
class="math inline">\(\begin{bmatrix}\cos(\theta) &amp;
-\sin(\theta)\\\sin(\theta) &amp;
\cos(\theta)\end{bmatrix}\)</span>的复合。换句话说，<strong>复数的几何意义就是进行旋转与缩放，旋转角度为<span
class="math inline">\(\theta=\arctan(b/a)\)</span>，缩放大小为复数的模长。</strong>
如果复数的模长为1，那么它的几何意义就只有旋转。</p>
<p>所以，对复数<span class="math inline">\(p\)</span>的旋转：</p>
<p><span class="math display">\[p&#39;=\begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta)\\
\sin(\theta) &amp; \cos(\theta)
\end{bmatrix}p\]</span></p>
<p>我们可以构造一个复数<span
class="math inline">\(z=\cos(\theta)+i\sin(\theta)\)</span>，把它与<span
class="math inline">\(p\)</span>相乘表示旋转：</p>
<p><span
class="math display">\[p&#39;=zp=(\cos(\theta)+i\sin(\theta))p\]</span></p>
<h3 id="复数的极坐标形式">复数的极坐标形式</h3>
<p>当我们看到<span
class="math inline">\(\eqref{eq1}\)</span>式的时候，我们立马可以得到复数的另一种代数形式：</p>
<p><span
class="math display">\[z=\|z\|(\cos(\theta)+i\sin(\theta))\]</span></p>
<p>再根据欧拉公式（Euler's Formula）：</p>
<p><span
class="math display">\[\cos(\theta)+i\sin(\theta)=\mathrm{e}^{i\theta}\]</span></p>
<p>可以立得复数的<strong>极坐标形式</strong>：</p>
<p><span
class="math display">\[z=\|z\|\mathrm{e}^{i\theta}=r\mathrm{e}^{i\theta},\;
r=\|z\|\]</span></p>
<p>现在，复数<span
class="math inline">\(z\)</span>不再通过它的实部和虚部表示，而且通过一个旋转角<span
class="math inline">\(\theta\)</span>与缩放因子<span
class="math inline">\(r\)</span>去表示了，它对任意一个复数<span
class="math inline">\(p\)</span>的旋转，都可以表示为：</p>
<p><span
class="math display">\[p&#39;=r\mathrm{e}^{i\theta}p\]</span></p>
<p>如果仅需表示旋转，则令<span
class="math inline">\(r=1\)</span>即可。</p>
<details class="note success no-icon"><summary><p>Proof of Euler's Formula</p>
</summary>
<p>令<span
class="math inline">\(f(\theta)=\frac{\cos(\theta)+i\sin(\theta)}{\mathrm{e}^{i\theta}}=\mathrm{e}^{-i\theta}(\cos(\theta)+i\sin(\theta))\)</span>，对实数<span
class="math inline">\(\theta\)</span>，对<span
class="math inline">\(f(\theta)\)</span>求导，得到<span
class="math inline">\(f&#39;(\theta)=\mathrm{e}^{-i\theta}(i\cos(\theta)-\sin(\theta))-i\mathrm{e}^{-i\theta}(\cos(\theta)+i\sin(\theta))=0\)</span>，因此<span
class="math inline">\(f(\theta)\)</span>是常数。又因为<span
class="math inline">\(f(0)=1\)</span>，所以<span
class="math inline">\(f(\theta)\equiv 1\)</span>。欧拉公式得证。</p>

</details>
<h3 id="复数的几种表示形式总结">复数的几种表示形式总结</h3>
<p>现在我们已经得到了如下几种复数<span
class="math inline">\(z=a+bi\)</span>的表示形式：</p>
<ul>
<li>代数形式一：<span class="math inline">\(z=a+bi\)</span>;</li>
<li>向量形式：<span
class="math inline">\(z=\begin{bmatrix}a\\b\end{bmatrix}\)</span>;</li>
<li>矩阵形式一：<span class="math inline">\(z=\begin{bmatrix}a &amp;
-b\\b &amp; a\end{bmatrix}\)</span>;</li>
<li>矩阵形式二：<span class="math inline">\(z=\begin{bmatrix}\|z\| &amp;
0\\0 &amp; \|z\|\end{bmatrix}\begin{bmatrix}\cos(\theta) &amp;
-\sin(\theta)\\\sin(\theta) &amp;
\cos(\theta)\end{bmatrix}\)</span>;</li>
<li>代数形式二：<span
class="math inline">\(z=r(\cos(\theta)+i\sin(\theta))\)</span>;</li>
<li>极坐标形式：<span
class="math inline">\(z=r\mathrm{e}^{i\theta}\)</span>.</li>
</ul>
<p>这几种形式是完全等价的。</p>
<h2 id="旋转复合">旋转复合</h2>
<p>假设我们现在有两个仅表示旋转的复数<span
class="math inline">\(z_1=\cos(\theta)+i\sin(\theta),z_2=\cos(\phi)+i\sin(\phi)\)</span>，相继用它们对一个复数<span
class="math inline">\(p\)</span>旋转：</p>
<p><span
class="math display">\[p&#39;=z_2z_1p=(z_2z_1)p=(z_1z_2)p=(\cos(\theta+\phi)+i\sin(\theta+\phi))p\]</span></p>
<p>所以，用两个复数进行旋转时，所得到的结果仍然是一个旋转，且旋转的角度是两次旋转角度之和。</p>
<h1 id="基于axis-angle的旋转">基于Axis Angle的旋转</h1>
<p>在<a
href="https://sulley.cc/2021/06/07/%E5%90%91%E9%87%8F%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC/">这篇博客</a>中，我们已经介绍了三维空间中一个向量绕任意轴旋转的公式（被称为<a
href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">Rodrigues'
formula</a>）。因为下文会涉及大量此公式，因此把结论在此重新记述，推导过程请参考原文。</p>
<p>记<span
class="math inline">\(\mathbf{p}\)</span>是待旋转的向量，<span
class="math inline">\(\mathbf{n}\)</span>是被围绕旋转的轴，是一个单位向量，<span
class="math inline">\(\theta\)</span>是要旋转的角度，<span
class="math inline">\(\mathbf{p}&#39;\)</span>是旋转后的向量。我们有：</p>
<p><span
class="math display">\[\mathbf{p}&#39;=\cos(\theta)\mathbf{p}+(1-\cos(\theta))(\mathbf{n}\cdot\mathbf{p})\mathbf{n}+\sin(\theta)(\mathbf{n}\times\mathbf{p})\]</span></p>
<p>或者矩阵形式：</p>
<p><span class="math display">\[
\mathbf{p}&#39;=\mathbf{R}\mathbf{p},\;\mathbf{R}=\mathbf{I}+(1-\cos(\theta))\mathbf{N}^2+\sin(\theta)\mathbf{N},
\mathbf{N}=
\begin{bmatrix}
  0 &amp; -n_z &amp; n_y\\
  n_z &amp; 0 &amp; -n_x\\
  -n_y &amp; n_x &amp; 0
\end{bmatrix}
\]</span></p>
<p>因为这种旋转方式是通过一个旋转轴和一个旋转角度定义的，所以我们称之为Axis
Angle旋转。 请记住此公式，我们将看到它与四元数之间紧密的联系。</p>
<h1 id="欧拉角与万向锁gimbal-lock问题">欧拉角与万向锁（Gimbal
Lock）问题</h1>
<h2 id="unity中的gimbal-lock现象">Unity中的Gimbal Lock现象</h2>
<p>在正式进入四元数之前，我们先介绍欧拉角及其引发的万向锁问题。网上有很多关于Gimbal
Lock的文章，但是找了一通发现大都表述得非常抽象。下面我把这个现象放到Unity中可视化展示，读者应该就能立刻知道问题所在。</p>
<video src="/images/quaternion/1.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<p>注意左上角红框圈出的部分，X/Y/Z=1表示这个Cube正在绕<strong>世界坐标系</strong>的x/y/z轴旋转，在我们一开始就把Cube绕x轴旋转90度时，我们惊异地发现，旋转y轴或者z轴的效果都是一样的！显然这不是我们想要的结果。</p>
<details class="note default"><summary><p>Codeblock for rotation</p>
</summary>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rotation</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> rotationSpeed = <span class="number">45</span>;</span><br><span class="line">    Vector3 currentEulgerAngles = <span class="keyword">new</span> Vector3 (<span class="number">90</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Rotating 90 degree</span></span><br><span class="line">    <span class="built_in">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown (KeyCode.X)) x = <span class="number">1</span> - x;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown (KeyCode.Y)) y = <span class="number">1</span> - y;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown (KeyCode.Z)) z = <span class="number">1</span> - z;</span><br><span class="line"></span><br><span class="line">        currentEulgerAngles += <span class="keyword">new</span> Vector3 (x, y, z) * Time.deltaTime * rotationSpeed;</span><br><span class="line"></span><br><span class="line">        transform.eulerAngles = currentEulgerAngles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUIStyle style = <span class="keyword">new</span> GUIStyle ();</span><br><span class="line">        style.fontSize = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">        GUI.Label (<span class="keyword">new</span> Rect (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="string">&quot;Rotating on X: &quot;</span> + x + <span class="string">&quot; Y: &quot;</span> + y + <span class="string">&quot; Z: &quot;</span> + z, style);</span><br><span class="line">        GUI.Label (<span class="keyword">new</span> Rect (<span class="number">10</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="string">&quot;Transform.eulerAngle: &quot;</span> + transform.eulerAngles, style);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>那么为什么会出现Gimbal
Lock现象呢？核心原因在于欧拉角旋转顺序是被<strong>固定的</strong>。要理解这句话，我们就要首先知道什么是欧拉角，什么叫固定顺序旋转。</p>
<h2 id="欧拉角坐标系与旋转顺序">欧拉角、坐标系与旋转顺序</h2>
<p>如果你没有任何基础知识取看Wikipedia的<a
href="https://en.wikipedia.org/wiki/Euler_angles">Euler
Angles</a>页面，你一定会感到一脸懵逼。从严格的定义来看，Wikipedia的介绍比较准确，但是在这里我们只需要简单地把欧拉角理解为<strong>点</strong>绕着<strong>世界坐标轴</strong>旋转的角度即可。</p>
<p>欧拉证明了三维空间中的任意旋转都可以拆分为沿着<strong>自身</strong>的三个坐标轴的旋转，欧拉角就是这三次旋转的角度。但是在这里我们使用相对于<strong>世界坐标系</strong>的旋转角度，这是因为<u><strong>相对自身坐标系的旋转与相对世界坐标系的旋转是可以互相转换的，只需要把旋转矩阵按照相反顺序相乘即可</strong></u>。</p>
<p>我们把绕着自身坐标系旋转称为<em>intrinsic
rotation</em>，把绕着世界坐标系旋转称为<em>extrinsic rotation</em>。</p>
<details class="note success"><summary><p>Intrinsic rotations and extrinsic rotations</p>
</summary>
<p>假定点<span class="math inline">\(P(x,y,z)\)</span>绕世界坐标轴<span
class="math inline">\(x\to y\to z\)</span>分别旋转<span
class="math inline">\(\theta/\phi/\tau\)</span>度，则旋转后的位置<span
class="math inline">\(P(x&#39;,y&#39;,z&#39;)\)</span>等价于绕自身坐标轴<span
class="math inline">\(z\to y\to x\)</span>分别旋转<span
class="math inline">\(\tau/\phi/\theta\)</span>度。</p>
<p><strong>证明</strong>：</p>
<p>我们知道在世界坐标系中绕<span
class="math inline">\(x/y/z\)</span>轴旋转的旋转矩阵分别为：</p>
<p><span class="math display">\[R_x(\theta)=
\begin{bmatrix}
  1 &amp; 0 &amp; 0\\
  0 &amp; \cos(\theta) &amp; -\sin(\theta)\\
  0 &amp; \sin(\theta) &amp; \cos(\theta)
\end{bmatrix},
R_y(\phi)=
\begin{bmatrix}
  \cos(\phi) &amp; 0 &amp; \sin(\phi)\\
  0 &amp; 1 &amp; 0 \\
  -\sin(\phi) &amp; 0 &amp; \cos(\phi)
\end{bmatrix},
R_z(\tau)=
\begin{bmatrix}
  \cos(\tau) &amp; -\sin(\tau) &amp; 0 \\
  \sin(\tau) &amp; \cos(\tau) &amp; 0 \\
  0 &amp; 0 &amp; 1
\end{bmatrix}\]</span></p>
<p>用<span class="math inline">\(x\to y\to
z\)</span>的顺序进行旋转，得到复合旋转矩阵： <span
class="math display">\[
R_\text{global}=R_z(\tau)R_y(\phi)R_x(\theta)=
\begin{bmatrix}
\cos(\phi)\cos(\tau) &amp;
\sin(\theta)\sin(\phi)\cos(\tau)-\cos(\theta)\sin(\tau) &amp;
\cos(\theta)\sin(\phi)\cos(\tau)+\sin(\theta)\sin(\tau)\\
\cos(\phi)\sin(\tau) &amp;
\sin(\theta)\sin(\phi)\sin(\tau)+\cos(\theta)\cos(\tau) &amp;
\cos(\theta)\sin(\phi)\sin(\tau)-\sin(\theta)\cos(\tau)\\
-\sin(\phi) &amp; \sin(\theta)\cos(\phi) &amp; \cos(\theta)\cos(\phi)
\end{bmatrix}
\]</span></p>
<p>现在考虑在点<span
class="math inline">\(P\)</span>的局部坐标系上按照<span
class="math inline">\(z\to y\to
x\)</span>的顺序旋转，注意，因为是局部坐标系，所以每次旋转都会同等地旋转每个局部坐标轴。旋转之前的局部坐标系与世界坐标系重合。我们能够得到上述绕自身局部坐标系旋转的旋转矩阵<span
class="math inline">\(R_\text{local}\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
  R_\text{local}&amp;={\color{pink}((R_z(\tau)R_y(\phi))R_x(\theta)(R_z(\tau)R_y(\phi))^{-1})}{\color{teal}(R_z(\tau)R_y(\phi)R_z^{-1}(\tau))}{\color{violet}R_z(\tau)}\\
  &amp;=R_z(\tau)R_y(\phi)R_x(\theta)\\
  &amp;=R_\text{global}
\end{aligned}
\]</span></p>
<p>这里要稍微做一些解释。粉色的<span
class="math inline">\({\color{violet}R_z(\tau)}\)</span>就是最开始基于<span
class="math inline">\(z\)</span>轴的变换，在这个变换之后，局部坐标系也跟着进行了变换，如下图所示：</p>
<p><img data-src="/images/quaternion/0_1.gif" /></p>
<p>可以看到在绕<span
class="math inline">\(z\)</span>轴旋转的过程中，自身局部的<span
class="math inline">\(x/y\)</span>轴也在随之旋转。接下来我们想要绕着自身的<span
class="math inline">\(y\)</span>轴旋转，我们先看看直接操作旋转是怎样的效果：</p>
<p><img data-src="/images/quaternion/0_2.gif" /></p>
<p>可以看到上图进行了两次旋转操作，第一次是绕着自身（其实也是世界坐标系）的<span
class="math inline">\(z\)</span>轴旋转了约<span
class="math inline">\(45\)</span>度，第二次是绕着自身的<span
class="math inline">\(y\)</span>轴（绿色轴）旋转了约<span
class="math inline">\(45\)</span>度，得到了一个倾斜的正方体。</p>
<p>那么，绕自身<span
class="math inline">\(y\)</span>轴旋转这个过程该怎么用数学形式表示呢？其实我们可以这么想：无论局部坐标系怎么变，绕自身的<span
class="math inline">\(y\)</span>轴旋转这个操作都是相对不变的，也就是说，无论有没有第一步的绕<span
class="math inline">\(z\)</span>轴旋转，绕<span
class="math inline">\(y\)</span>轴旋转前后所得到的位置相对自身坐标系而言都是相同的。如此一来，我们就可以<strong>先把绕<span
class="math inline">\(z\)</span>轴旋转这个操作还原回去，进行绕<span
class="math inline">\(y\)</span>轴旋转的操作，然后再恢复到绕<span
class="math inline">\(z\)</span>轴旋转后的状态</strong>，这样就求出了我们原本期望的旋转，也就是绿色部分<span
class="math inline">\({\color{teal}(R_z(\tau)R_y(\phi)R_z^{-1}(\tau))}\)</span>进行的操作。</p>
<p>这个过程可以用下图表示：</p>
<p><img data-src="/images/quaternion/0_3.gif" /></p>
<p>首先我们绕<span class="math inline">\(z\)</span>轴旋转了<span
class="math inline">\(45\)</span>度，然后又还原了回去绕<span
class="math inline">\(y\)</span>轴旋转<span
class="math inline">\(45\)</span>度，最后再恢复到第一步操作后的状态。这里要特别注意的是，最后"恢复到初始状态"这个操作，是针对世界坐标系而言的，而不是当前的局部坐标系，这是因为我们第一步绕<span
class="math inline">\(z\)</span>轴旋转<span
class="math inline">\(45\)</span>度本质上就是在世界坐标系中进行的。</p>
<p>如果你还不理解，我们再来看一下最后公式的粉色部分<span
class="math inline">\({\color{pink}((R_z(\tau)R_y(\phi))R_x(\theta)(R_z(\tau)R_y(\phi))^{-1})}\)</span>，这里的<span
class="math inline">\({\color{pink}R_z(\tau)R_y(\phi)}\)</span>就是前两步旋转的结果，而<span
class="math inline">\({\color{pink}(R_z(\tau)R_y(\phi))^{-1}}\)</span>就是对这个旋转<strong>整体</strong>取反向操作，回复到最开始的没有旋转的状态。所以这时候你应该明白，应该把<span
class="math inline">\({\color{pink}R_z(\tau)R_y(\phi)}\)</span>看作一个整体，而这个整体表示的旋转就是<strong>相对于世界坐标系</strong>而言的。无论之后是否还有更多的旋转，都可以采用这种思路套娃下去。</p>

</details>
<p>有了上述结论，我们在这里就不再关心是局部坐标系还是全局坐标系了，我们默认使用全局坐标系。</p>
<p>此外，<strong>顺序</strong>对基于欧拉角的旋转来说至关重要，这是因为矩阵往往不具备交换律，即<span
class="math inline">\(AB\not=BA\)</span>。所以在实际应用的时候，我们会固定采用一个顺序进行旋转，比如<span
class="math inline">\(x\to y\to
z\)</span>。这种按照固定顺序旋转的做法就导致了Gimbal Lock的产生。</p>
<h2 id="unity中的欧拉角">Unity中的欧拉角</h2>
<p>Unity中的欧拉角是采用<span class="math inline">\(z\to x\to
y\)</span>的顺序进行旋转的。采用<span class="math inline">\(z\to x\to
y\)</span>顺序旋转的直接结果是：当我们固定了<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>轴旋转后再增量基于<span
class="math inline">\(z\)</span>轴旋转，会发现物体是在绕着<strong>自身</strong>的<span
class="math inline">\(z\)</span>轴旋转而不是绕着世界坐标系的<span
class="math inline">\(z\)</span>轴旋转。如下图所示：</p>
<p><img data-src="/images/quaternion/2.gif" /></p>
<p>这是因为当我们变动欧拉角的时候，Unity会<strong>重新</strong>按照<span
class="math inline">\(z\to x\to
y\)</span>的顺序计算旋转。如果我们固定了<span
class="math inline">\(x\)</span>轴和<span
class="math inline">\(y\)</span>轴的旋转角，不断地变动<span
class="math inline">\(z\)</span>轴旋转角的时候，Unity会首先对<span
class="math inline">\(z\)</span>轴进行旋转，然后才是对<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>轴，然而在对<span
class="math inline">\(x/y\)</span>轴旋转的过程中，物体的局部坐标系也在随之变动。既然我们已经固定了<span
class="math inline">\(x/y\)</span>轴的旋转角度，变换的只有<span
class="math inline">\(z\)</span>轴，所以最终呈现出来就是物体在绕自身局部坐标系的<span
class="math inline">\(z\)</span>轴旋转。</p>
<h2 id="unity中的gimbal-lock问题">Unity中的Gimbal Lock问题</h2>
<p>有了上面的铺垫，我们就知道为什么会出现开头那样的Gimbal
Lock现象了。当我们固定<span
class="math inline">\(x\)</span>轴的旋转角度为<span
class="math inline">\(\theta=90\)</span>度时，再设绕<span
class="math inline">\(y\)</span>轴和<span
class="math inline">\(z\)</span>轴的旋转角度为<span
class="math inline">\(\phi,\tau\)</span>，我们可以把以<span
class="math inline">\(z\to x\to y\)</span>为顺序的复合旋转矩阵写为：</p>
<p><span class="math display">\[
\begin{aligned}
  R_{zxy}&amp;=R_y(\phi)R_x(\tfrac{\pi}{2})R_z(\tau)\\
  &amp;=
  \begin{bmatrix}
    \cos(\phi)\cos(\tau)+\sin(\phi)\sin(\tau) &amp;
-\cos(\phi)\sin(\tau)+\sin(\phi)\cos(\tau) &amp; 0\\
    0 &amp; 0 &amp; -1\\
    -\sin(\phi)\cos(\tau)+\cos(\phi)\sin(\tau) &amp;
\sin(\phi)\sin(\tau)+\cos(\phi)\cos(\tau) &amp; 0
  \end{bmatrix}\\
  &amp;=\begin{bmatrix}
    \cos(\phi-\tau) &amp; \sin(\phi-\tau) &amp; 0\\
    0 &amp; 0 &amp; -1\\
    -\sin(\phi-\tau) &amp; \cos(\phi-\tau) &amp; 0
  \end{bmatrix}\\
  &amp;=R_x(\tfrac{\pi}{2})R_z(\tau-\phi)
\end{aligned}
\]</span></p>
<p>我们发现，这个旋转矩阵竟然仅仅是旋转了<span
class="math inline">\(z\)</span>和<span
class="math inline">\(x\)</span>轴，它并没有对物体本身的<span
class="math inline">\(y\)</span>轴做旋转（可以看本节最开始的视频，正方体围绕蓝色的轴，也即自身的<span
class="math inline">\(z\)</span>轴在旋转），而是把两个变换合并为了一个变换。还记得我们上一小节讲到的固定<span
class="math inline">\(x/y\)</span>轴只变动<span
class="math inline">\(z\)</span>轴时物体围绕自身的<span
class="math inline">\(z\)</span>轴旋转的现象吗？在这个地方，我们固定了<span
class="math inline">\(x\)</span>轴的旋转为<span
class="math inline">\(90\)</span>度，对<span
class="math inline">\(y\)</span>轴和对<span
class="math inline">\(z\)</span>轴的变换都作用到了<span
class="math inline">\(z\)</span>轴上，所以最终呈现的效果就是物体绕了<span
class="math inline">\(x\)</span>轴旋转<span
class="math inline">\(90\)</span>度之后<strong>只能围绕自身的<span
class="math inline">\(z\)</span>轴旋转</strong>。我们再也没有机会对物体原本的<span
class="math inline">\(y\)</span>轴进行变换了，这就是所谓的Gimbal
Lock问题。</p>
<p>所以，由此可见，Gimbal
Lock产生的根本原因在于采用固定的旋转顺序，因为旋转顺序固定，所以就会在某些情况（如此处<span
class="math inline">\(x\)</span>轴恒定旋转为<span
class="math inline">\(90\)</span>度）下失去一个轴的自由度。采用欧拉角就意味着旋转顺序有先后，就必然会出现Gimbal
Lock问题。</p>
<p>除了Gimbal Lock之外，Euler
Angles还存在插值困难和歧义性（与旋转矩阵之间的对应关系复杂）等问题。</p>
<h1 id="四元数">四元数</h1>
<h2 id="定义-1">定义</h2>
<p>四元数可以定义为如下形式：</p>
<p><span class="math display">\[q=a+bi+cj+dk
\;(a,b,c,d\in\mathbb{R})\]</span></p>
<p>这个定义和复数非常相似，只不过四元数有三个“虚部” (<span
class="math inline">\(i,j,k\)</span>)，而复数只有一个“虚部” (<span
class="math inline">\(i\)</span>)。</p>
<p>上述的<span class="math inline">\(i,j,k\)</span>满足如下性质：</p>
<p><span class="math display">\[i^2=j^2=k^2=ijk=-1\]</span></p>
<p>如果把上式称为四元数的<strong>代数形式</strong>，那么同样地，它也可以有对应的<strong>向量形式一</strong>：</p>
<p><span class="math display">\[q=\begin{bmatrix}
  a\\b\\c\\d
\end{bmatrix}\]</span></p>
<p>如果把四元数<span
class="math inline">\(q\)</span>的“实部”和“虚部”拆开，那么四元数还可以表示为下述的<strong>向量形式二</strong>：</p>
<p><span class="math display">\[q=[s,\mathbf{v}],\;
(\mathbf{v}=\begin{bmatrix}
  x\\
  y\\
  z
\end{bmatrix},s,x,y,z\in\mathbb{R})\]</span></p>
<p>所以，仅仅从定义来看，四元数就有如下三种等价的形式：</p>
<ul>
<li><strong>代数形式</strong>：<span
class="math inline">\(q=a+bi+cj+dk\)</span>;</li>
<li><strong>向量形式一</strong>：<span
class="math inline">\(q=\begin{bmatrix}a\\b\\c\\d\end{bmatrix}\)</span>;</li>
<li><strong>向量形式二</strong>：<span
class="math inline">\(q=[s,\mathbf{v}]\)</span>.</li>
</ul>
<h2 id="加法乘法模长">加法、乘法、模长</h2>
<h3 id="加法">加法</h3>
<p>给定两个四元数<span
class="math inline">\(q_1=a_1+b_1i+c_1j+d_1k\)</span>与<span
class="math inline">\(q_2=a_2+b_2i+c_2j+d_2k\)</span>，定义四元数的加法为：</p>
<p><span
class="math display">\[q_1+q_2=(a_1+a_2)+(b_1+b_2)i+(c_1+c_2)j+(d_1+d_2)k\]</span></p>
<p>用四元数的向量形式<span
class="math inline">\(q_1=[a_1,\mathbf{v}_1],q_2=[a_2,\mathbf{v}_2]\)</span>，可以把上式简化为：</p>
<p><span class="math display">\[q_1\pm q_2=[a_1\pm a_2, \mathbf{v}_1\pm
\mathbf{v}_2]\]</span></p>
<h3 id="乘法">乘法</h3>
<p>四元数的标量乘法和实数、复数一样，可以定义为：</p>
<p><span class="math display">\[sq=s(a+bi+cj+dk)\]</span></p>
<p>然而四元数之间的乘积可以通过如下步骤定义：</p>
<p><span class="math display">\[
\begin{equation}
  \begin{aligned}
  q_1q_2=&amp;(a_1+b_1i+c_1j+d_1k)(a_2+b_2i+c_2j+d_2k)\\
        =&amp;a_1a_2+a_1b_2i+a_1c_2j+a_1d_2k+\\
        &amp;b_1a_2i+b_1b_2i^2+b_1c_2ij+b_1d_2ik+\\
        &amp;c_1a_2j+c_1b_2ji+c_1c_2j^2+c_1d_2jk+\\
        &amp;d_1a_2k+d_1b_2ki+d_1c_2kj+d_1d_2k^2
  \end{aligned}
\end{equation}
\]</span></p>
<p>我们可以从性质<span
class="math inline">\(i^2=j^2=k^2=ijk=-1\)</span>推导出如下的性质：</p>
<p><span class="math inline">\(jk=i\)</span>, <span
class="math inline">\(ij=k\)</span>, <span
class="math inline">\(ki=j\)</span>, <span
class="math inline">\(kj=-i\)</span>, <span
class="math inline">\(ji=-k\)</span>, <span
class="math inline">\(ik=-j\)</span></p>
<p>于是能够得到下表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(\times\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(i\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(j\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(k\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(i\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(j\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(k\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(i\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(i\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(k\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-j\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(j\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(j\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-k\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(i\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(k\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(k\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(j\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-i\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(-1\)</span></td>
</tr>
</tbody>
</table>
<p>容易观察到交换律并不成立，即<span class="math inline">\(ij\neq
ji\)</span>。利用这个表格，我们能够对四元数之间的乘法进行归纳简化：</p>
<p><span class="math display">\[
\begin{equation}
  \begin{aligned}
  q_1q_2=&amp;(a_1+b_1i+c_1j+d_1k)(a_2+b_2i+c_2j+d_2k)\\
        =&amp;(a_1a_2-b_1b_2-c_1c_2-d_1d_2)+\\
        &amp;(a_1b_2+b_1a_2+c_1d_2-d_1c_2)i+\\
        &amp;(a_1c_2-b_1d_2+c_1a_2+d_1b_2)j+\\
        &amp;(a_1d_2+b_1c_2-c_1b_2+d_1a_2)k
  \end{aligned}
\end{equation}
\]</span></p>
<p>现在，得到的这个新四元数<span
class="math inline">\(q_0=q_1q_2\)</span>的四个分量都表示了出来，即：</p>
<p><span class="math display">\[q_0=a_0+b_0i+c_0j+d_0k,\; \begin{cases}
  a_0=a_1a_2-b_1b_2-c_1c_2-d_1d_2\\
  b_0=a_1b_2+b_1a_2+c_1d_2-d_1c_2\\
  c_0=a_1c_2-b_1d_2+c_1a_2+d_1b_2\\
  d_0=a_1d_2+b_1c_2-c_1b_2+d_1a_2
\end{cases}\]</span></p>
<p>或者可以写成下述的<strong>矩阵形式</strong>：</p>
<p><span class="math display">\[q_0=q_1q_2=\begin{bmatrix}
  a_0\\
  b_0\\
  c_0\\
  d_0
\end{bmatrix}=\begin{bmatrix}
  a_2 &amp; -b_2 &amp; -c_2 &amp; -d_2\\
  b_2 &amp; a_2 &amp; d_2 &amp; -c_2\\
  c_2 &amp; -d_2 &amp; a_2 &amp; b_2\\
  d_2 &amp; c_2 &amp; -b_2 &amp; a_2
\end{bmatrix}\begin{bmatrix}
  a_1\\
  b_1\\
  c_1\\
  d_1
\end{bmatrix}\]</span></p>
<p>这样一来，我们就把两个四元数的乘积写成了矩阵与向量的乘积，并且由于四元数的乘法不可交换，<span
class="math inline">\(q_0=q_1q_2\)</span>代表的仅仅是<span
class="math inline">\(q_1\)</span>为左乘数、<span
class="math inline">\(q_2\)</span>为右乘数时的结果。我们把矩阵<span
class="math inline">\(\begin{bmatrix}a_2 &amp; -b_2 &amp; -c_2 &amp;
-d_2\\b_2 &amp; a_2 &amp; d_2 &amp; -c_2\\c_2 &amp; -d_2 &amp; a_2 &amp;
b_2\\d_2 &amp; c_2 &amp; -b_2 &amp;
a_2\end{bmatrix}\)</span>称为四元数<span
class="math inline">\(q_2\)</span>当右乘子时的变换矩阵，或<strong>矩阵形式</strong>。</p>
<h3 id="graßmann积">Graßmann积</h3>
<p>显然矩阵形式又臭又长，我们希望用一种更简单的形式——Graßmann积——去表示四元数乘法。</p>
<p>重新整理之前的乘法结果：</p>
<p><span class="math display">\[
\begin{equation}
  \begin{aligned}
q_0=q_1q_2=&amp;(a_1a_2-(b_1b_2+c_1c_2+d_1d_2))+\\
          &amp;({\color{pink}{a_1}}b_2+{\color{teal}{a_2}}b_1+{\color{violet}{c_1d_2-d_1c_2}})i+\\
          &amp;({\color{pink}{a_1}}c_2+{\color{teal}{a_2}}c_1+{\color{violet}{d_1b_2-b_1d_2}})j\\
          &amp;({\color{pink}{a_1}}d_2+{\color{teal}{a_2}}d_1+{\color{violet}{b_1c_2-c_1b_2}})k
  \end{aligned}
\end{equation}
\]</span></p>
<p>如果令<span
class="math inline">\(q_1=[a_1,\mathbf{v}_1],q_2=[a_2,\mathbf{v}_2]\)</span>，则有：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{v}_1\cdot \mathbf{v}_2&amp;=b_1b_2+c_1c_2+d_1d_2\\
  \mathbf{v}_1\times\mathbf{v}_2&amp;=\begin{bmatrix}
    \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k}\\
    b_1 &amp; c_1 &amp; d_1\\
    b_2 &amp; c_2 &amp; d_2
  \end{bmatrix}=({\color{violet}{c_1d_2-d_1c_2}})\mathbf{i}+({\color{violet}{d_1b_2-b_1d_2}})\mathbf{j}+({\color{violet}{b_1c_2-c_1b_2}})\mathbf{k}
\end{aligned}
\]</span></p>
<p>这样一来，我们就可以用点乘和叉乘的形式表示四元数的乘积：</p>
<p><span class="math display">\[\begin{aligned}
  q_0=q_1q_2=[a_1a_2-\mathbf{v}_1\cdot\mathbf{v}_2,a_1\mathbf{v}_2+a_2\mathbf{v}_1+\mathbf{v}_1\times\mathbf{v}_2]
\end{aligned}\]</span></p>
<p>这就是所谓的Graßmann积（Graßmann
Product）。所以，从Graßmann积也可能看到两个四元数的乘积一般是不可交换的，因为叉乘一般不可交换。</p>
<h3 id="模长">模长</h3>
<p>四元数的模长和向量的模长定义一样：</p>
<p><span class="math display">\[\|q\|
=\sqrt{a^2+b^2+c^2+d^2}=\sqrt{a^2+\mathbf{v}\cdot
\mathbf{v}}\]</span></p>
<h2 id="纯四元数">纯四元数</h2>
<p>定义“实部”为零的四元数为<strong>纯四元数</strong>，即：</p>
<p><span class="math display">\[q=[0,\mathbf{v}]\]</span></p>
<p>对于两个纯四元数<span
class="math inline">\(q_1=[0,\mathbf{v}_1],q_2=[0,\mathbf{v}_2]\)</span>，它们的乘积为：</p>
<p><span
class="math display">\[q_1q_2=[-\mathbf{v}_1\cdot\mathbf{v}_2,\mathbf{v}_1\times
\mathbf{v}_2]\]</span></p>
<h2 id="共轭">共轭</h2>
<p>四元数的共轭（Conjugation）与复数的共轭类似，可以定义为：</p>
<p><span
class="math display">\[q^*=[a,-\mathbf{v}]=[a,-b,-c,-d]=a-bi-cj-dk\]</span></p>
<p>四元数与它自己的共轭相乘可以得到一个标量：</p>
<p><span
class="math display">\[qq^*=[a^2+\mathbf{v}\cdot\mathbf{v},-a\mathbf{v}+a\mathbf{v}+\mathbf{v}\times(-\mathbf{v})]=[a^2+\mathbf{v}\cdot\mathbf{v},0]=\|q\|^2\]</span></p>
<p>正好是四元数模长的平方。同时：</p>
<p><span
class="math display">\[q^*q=(q^*)(q^*)^*=\|q^*\|^2=\|q\|^2\]</span></p>
<p>这表明四元数与它共轭的乘法是可交换的。这是一个非常好的性质。</p>
<h2 id="逆">逆</h2>
<p>有了共轭，我们最后就可以来定义四元数的逆（Inverse）了。记四元数<span
class="math inline">\(q\)</span>的逆为<span
class="math inline">\(q^{-1}\)</span>，则<span
class="math inline">\(q^{-1}\)</span>是满足下述性质的四元数：</p>
<p><span class="math display">\[qq^{-1}=q^{-1}q=1,\; (q\neq
0)\]</span></p>
<p>利用共轭，我们可以进行如下推导：</p>
<p><span class="math display">\[
\begin{aligned}
  qq^{-1}&amp;=1\\
  q^*qq^{-1}&amp;=q^*\\
  \|q\|^2q^{-1}&amp;=q^*\\
  q^{-1}&amp;=\frac{q^*}{\|q\|^2}
\end{aligned}
\]</span></p>
<p>所以，四元数的逆就是它的共轭除以它模长的平方。如果<span
class="math inline">\(\|q\|=1\)</span>，那么它的逆就是它的共轭，此时称<span
class="math inline">\(q\)</span>为一个<strong>单位四元数</strong> (Unit
Quaternion)。</p>
<h1 id="四元数与三维旋转">四元数与三维旋转</h1>
<h2 id="从三维旋转公式到四元数表示">从三维旋转公式到四元数表示</h2>
<p>现在我们正式考察四元数与三维旋转之间的关系。首先，让我们回忆一下普通3D旋转的推导过程：</p>
<details class="note success"><summary><p>A sketch derivation of Rodrigues' formula</p>
</summary>
<p>记<span
class="math inline">\(\mathbf{p}\)</span>是待旋转的向量，<span
class="math inline">\(\mathbf{n}\)</span>是被围绕旋转的轴，是一个单位向量，<span
class="math inline">\(\theta\)</span>是要旋转的角度，<span
class="math inline">\(\mathbf{p}&#39;\)</span>是旋转后的向量。则：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{p}&#39;&amp;=\mathbf{p}&#39;_\parallel+\mathbf{p}&#39;_\perp\\
             &amp;=\mathbf{p}_\parallel+\cos(\theta)\mathbf{p}_\perp+\sin(\theta)(\mathbf{n}\times\mathbf{p}_\perp)\\
             &amp;(=\cos(\theta)\mathbf{p}+(1-\cos(\theta))(\mathbf{n}\cdot\mathbf{p})\mathbf{n}+\sin(\theta)(\mathbf{n}\times\mathbf{p}))\;(\text{omit
this line)}
\end{aligned}
\]</span></p>

</details>
<p>现在我们想要找到四元数与上式的关系，我们自然地想到能不能像推导四元数乘法的<strong>矩阵形式</strong>那样，把上面所有的向量都用四元数去表示。于是我们可以定义：</p>
<p><span class="math display">\[p&#39;=[0,\mathbf{p}&#39;],\
p&#39;_\parallel=[0, \mathbf{p}&#39;_\parallel],\ p&#39;_\perp=[0,
\mathbf{p}&#39;_\perp],\ p=[0, \mathbf{p}], p_\parallel=[0,
\mathbf{p}_\parallel],\ p_\perp=[0, \mathbf{p}_\perp],\ n=[0,
\mathbf{n}]\]</span></p>
<p>从而我们有：</p>
<p><span class="math display">\[
\begin{equation}
\label{eq2}
  p&#39;=p_\parallel+\cos(\theta)p_\perp+\sin(\theta)(\mathbf{n}\times
\mathbf{p}_\perp)
\end{equation}
\]</span></p>
<p>前面两项我们已经顺利地用四元数表示出来了，但是第三项的叉乘怎么办？我们先尝试一下用对应的四元数相乘看看：</p>
<p><span
class="math display">\[np_\perp=[0,\mathbf{n}]\cdot[0,\mathbf{p}_\perp]=[0,\mathbf{n}\times\mathbf{p}_\perp]=\mathbf{n}\times\mathbf{p}_\perp\]</span></p>
<p>这里就用到了纯四元数的概念。不管怎样，我们很“幸运”地用四元数的乘法把最后的叉乘表示了出来，代入<span
class="math inline">\(\eqref{eq2}\)</span>中，就有：</p>
<p><span class="math display">\[
p&#39;=p_\parallel+\cos(\theta)p_\perp+\sin(\theta)np_\perp=p_\parallel+qp_\perp,\;
(q=\cos(\theta)+\sin(\theta)n)
\]</span></p>
<p>这里的<span
class="math inline">\(q\)</span>用四元数的向量就可以表示为<span
class="math inline">\(q=[\cos(\theta),\sin(\theta)\mathbf{n}]\)</span>，而且还可以验证它是一个单位四元数（模长为1）！</p>
<h2 id="四元数旋转公式的简化">四元数旋转公式的简化</h2>
<p>现在我们也可以像之前那样，分别把<span
class="math inline">\(p_\parallel,p_\perp,q\)</span>代入，但是我们想要更好的形式。为了进一步化简上式，我们需要证明三个引理。</p>
<h3 id="引理一">引理一</h3>
<details class="note primary"><summary><p>Lemma 1</p>
</summary>
<p>如果<span
class="math inline">\(q=[\cos(\theta),\sin(\theta)\mathbf{n}]\)</span>，且<span
class="math inline">\(\mathbf{n}\)</span>为单位向量，则<span
class="math inline">\(q^2=qq=[\cos(2\theta),\sin(2\theta)\mathbf{n}]\)</span>.</p>

</details>
<p>证明从略。</p>
<p>现在我们引入一个新的四元数<span
class="math inline">\(w=[\cos(\frac{1}{2}\theta),\sin(\frac{1}{2}\theta)\mathbf{n}]\)</span>，根据引理一，我们显然有<span
class="math inline">\(w^2=q\)</span>，并且<span
class="math inline">\(w\)</span>也是单位四元数，从而<span
class="math inline">\(w^{-1}=w^*\)</span>。</p>
<p>所以，之前的结果现在就可以重写为：</p>
<p><span
class="math display">\[p&#39;=p_\parallel+qp_\perp=ww^*p_\parallel+wwp_\perp\]</span></p>
<p>这里用<span
class="math inline">\(w\)</span>的原因就是要把两项都表示为三个因子的乘积。<span
class="math inline">\(ww^*\)</span>实际上是一个恒等变换，它并不对<span
class="math inline">\(p_\parallel\)</span>产生作用，真正起作用的是<span
class="math inline">\(w^2\)</span>，它对<span
class="math inline">\(p_\perp\)</span>旋转了<span
class="math inline">\(\theta\)</span>度，使得相加后能得到正确的结果。</p>
<p>但是这种形式还是不能简化右式，我们需要下面的<strong>引理二</strong>。</p>
<h3 id="引理二">引理二</h3>
<details class="note primary"><summary><p>Lemma 2</p>
</summary>
<p>如果<span
class="math inline">\(p_\parallel=[0,\mathbf{p}_\parallel]\)</span>是一个纯四元数，<span
class="math inline">\(w=[\alpha,\beta \mathbf{n}]\)</span>，其中<span
class="math inline">\(\mathbf{n}\)</span>是单位向量，<span
class="math inline">\(\alpha,\beta\in\mathbb{R}\)</span>。若<span
class="math inline">\(\mathbf{p}_\parallel\)</span>平行于<span
class="math inline">\(\mathbf{n}\)</span>，则<span
class="math inline">\(p_\parallel w=wp_\parallel\)</span>.</p>

</details>
<p>该引理证明如下：</p>
<p><span class="math display">\[
\begin{aligned}
  \text{LHS}&amp;=[0,\mathbf{p}_\parallel]\cdot[\alpha,\beta
\mathbf{n}]\\
  &amp;=[-\beta \mathbf{p}_\parallel\cdot \mathbf{n},\alpha
\mathbf{p}_\parallel]
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
  \text{RHS}&amp;=[\alpha,\beta
\mathbf{n}]\cdot[0,\mathbf{p}_\parallel]\\
  &amp;=[-\beta \mathbf{p}_\parallel\cdot \mathbf{n}, \alpha
\mathbf{p}_\parallel]\\
  &amp;=\text{LHS}
\end{aligned}
\]</span></p>
<p>根据引理二，我们就可以把上式的第一项最后两个因子交换，得到：</p>
<p><span class="math display">\[p&#39;=wp_\parallel
w^*+wwp_\perp\]</span></p>
<p>我们再使用<strong>引理三</strong>进行最后的化简。</p>
<h3 id="引理三">引理三</h3>
<details class="note primary"><summary><p>Lemma 3</p>
</summary>
<p>如果<span
class="math inline">\(p_\perp=[0,\mathbf{p}_\perp]\)</span>是一个纯四元数，<span
class="math inline">\(w=[\alpha,\beta \mathbf{n}]\)</span>，其中<span
class="math inline">\(\mathbf{n}\)</span>是单位向量，<span
class="math inline">\(\alpha,\beta\in\mathbb{R}\)</span>。若<span
class="math inline">\(\mathbf{p}_\perp\)</span>正交于<span
class="math inline">\(\mathbf{n}\)</span>，则<span
class="math inline">\(wp_\perp=p_\perp w^*\)</span>.</p>

</details>
<p>证明与引理二过程类似，不多赘述。根据这个引理，我们就能对原式做最后的化简：</p>
<p><span class="math display">\[
\begin{aligned}
  p&#39;&amp;=wp_\parallel w^*+wwp_\perp\\
  &amp;=wp_\parallel w^*+wp_\perp w^*\\
  &amp;=w(p_\parallel+p_\perp)w^*\\
  &amp;=wpw^*
\end{aligned}
\]</span></p>
<p>最后我们得到了一个非常优美的结果，在这个公式中，我们不再把待旋转向量拆分为两个分量，而是直接通过四元数之间的乘法实现了旋转。该结论可以总结为一个定理：</p>
<h2 id="三维旋转定理四元数型">三维旋转定理（四元数型）</h2>
<details class="note success"><summary><p>3D Rotation Theorem (Quaternion)</p>
</summary>
<p>任意三维向量<span
class="math inline">\(\mathbf{p}\)</span>绕着单位向量<span
class="math inline">\(\mathbf{n}\)</span>旋转<span
class="math inline">\(\theta\)</span>度之后的向量<span
class="math inline">\(\mathbf{p}&#39;\)</span>可以用下式表示：</p>
<p><span class="math display">\[p&#39;=wpw^*,\;
(p=[0,\mathbf{p}],w=[\cos(\tfrac{1}{2}\theta),\sin(\tfrac{1}{2}\theta)\mathbf{n}])\]</span></p>

</details>
<p>现在我们进行验证：</p>
<p><span class="math display">\[
\begin{aligned}
  wpw^*&amp;=(wp)w^*\\
  &amp;=([\cos(\tfrac{1}{2}\theta),\sin(\tfrac{1}{2}\theta)\mathbf{n}]\cdot[0,\mathbf{p}])\cdot
[\cos(\tfrac{1}{2}\theta),-\sin(\tfrac{1}{2}\theta)\mathbf{n}]\\
  &amp;=[-\sin(\tfrac{1}{2}\theta)\mathbf{n}\cdot\mathbf{p},
\cos(\tfrac{1}{2}\theta)\mathbf{p}+\sin(\tfrac{1}{2}\theta)\mathbf{n}\times\mathbf{p}]\cdot
[\cos(\tfrac{1}{2}\theta),-\sin(\tfrac{1}{2}\theta)\mathbf{n}]\\
  &amp;=[0,\cos(\theta)\mathbf{p}+(1-\cos(\theta))(\mathbf{n}\cdot\mathbf{p})\mathbf{n}+\sin(\theta)(\mathbf{n}\times\mathbf{p})]
\end{aligned}
\]</span></p>
<p>正好就是Rodrigues' formula！</p>
<p>并且，从上面的推导我们还知道：<strong>所有的单位四元数都对应了一个三维旋转（但这二者之间并非双射）</strong>。那么给定单位四元数<span
class="math inline">\(w=[a,\mathbf{b}]\)</span>，我们就能得到它对应的旋转角<span
class="math inline">\(\theta\)</span>和旋转轴<span
class="math inline">\(\mathbf{n}\)</span>：</p>
<p><span
class="math display">\[\color{violet}\frac{\theta}{2}=\arccos(a),\;\mathbf{n}=\frac{\mathbf{b}}{\sin(\arccos(a))}\]</span></p>
<p>因此，我们得到了：</p>
<p><span
class="math display">\[w=[a,\mathbf{b}]=[\cos(\tfrac{\theta}{2}),\sin(\tfrac{\theta}{2})\mathbf{n}]\]</span></p>
<h2 id="四元数乘积的性质">四元数乘积的性质</h2>
<p>下面我们介绍几个关于四元数乘积的性质，这些性质与我们的主题没有直接关联，但对我们深入理解四元数大有帮助，供感兴趣的读者参考。</p>
<details class="note primary"><summary><p>Property 1</p>
</summary>
<p>令<span class="math inline">\(w\)</span>为单位四元数，<span
class="math inline">\(p=[a,\mathbf{b}]\)</span>，则<span
class="math inline">\(p&#39;=wpw^*\)</span>满足<span
class="math inline">\(p=[a,\mathbf{b}&#39;]\)</span>且<span
class="math inline">\(\|\mathbf{b&#39;}\|=\|\mathbf{b}\|\)</span>。</p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
  p&#39;&amp;=wpw^*\\
  &amp;=w([a,\mathbf{0}]+[0,\mathbf{b}])w^*\\
  &amp;=w[a,\mathbf{0}]w^*+w[0,\mathbf{b}]w^*\\
  &amp;=[a,\mathbf{0}]ww^*+[0,\mathbf{b}&#39;]\\
  &amp;=[a,\mathbf{b}&#39;]
\end{aligned}
\]</span></p>
<p>此外，还有<span
class="math inline">\(\|p&#39;\|=\|wpw^*\|=\|w\|\|p\|\|w^*\|=\|p\|\)</span>，从而推得<span
class="math inline">\(\|\mathbf{b&#39;}\|=\|\mathbf{b}\|\)</span>。</p>

</details>
<p>Property
1告诉我们：对四元数的旋转不改变标量和向量的模长。这与四元数表示旋转的本质是符合的。</p>
<details class="note primary"><summary><p>Property 2</p>
</summary>
<p>令<span class="math inline">\(w,p\)</span>都为单位四元数，<span
class="math inline">\(p=[\cos(\theta),\sin(\theta)\mathbf{n}]\)</span>，对<span
class="math inline">\(t\in\mathbb{R}\)</span>有<span
class="math inline">\(wp^tw^*=(wpw^*)^t\)</span>。</p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
  wp^tw^*&amp;=w(\exp(t\log(p)))w^*\\
  &amp;=w(\exp[0,t\theta\mathbf{n}])w^*\\
  &amp;=w[\cos(t\theta),\sin(t\theta)\mathbf{n}]w^*\\
  &amp;=[\cos(t\theta),\sin(t\theta)\mathbf{n}&#39;]\\
  &amp;=\exp(t[0,\theta\mathbf{n}&#39;])\\
  &amp;=\exp(t\log[\cos(\theta),\sin(\theta)\mathbf{n}&#39;])\\
  &amp;=\exp(t\log(wpw^*))\\
  &amp;=(wpw^*)^t
\end{aligned}
\]</span></p>
<p>其中第四个等号和第七个等号可以通过Property 1推知。</p>

</details>
<p>Property 2告诉我们：对一个单位四元数的<span
class="math inline">\(t\)</span>次幂旋转，等价于对单位四元数旋转的<span
class="math inline">\(t\)</span>次幂。</p>
<p>接下来的四个性质与单位四元数的求导有关。</p>
<details class="note primary"><summary><p>Property 3 (Derivative of exponential)</p>
</summary>
<p>令<span
class="math inline">\(p=[\cos(\theta),\sin(\theta)\mathbf{n}]\)</span>为单位四元数，<span
class="math inline">\(t\in\mathbb{R}\)</span>，则有：</p>
<p><span
class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t}p^t=p^t\log(p)\]</span></p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
  \frac{\mathrm{d}}{\mathrm{d}t}q^t=\frac{\mathrm{d}}{\mathrm{d}t}\exp(t\log(p))=\exp(t\log(p))\frac{\mathrm{d}}{\mathrm{d}t}(t\log(p))=p^t\log(p)
\]</span></p>

</details>
<details class="note primary"><summary><p>Property 4 (Product rule)</p>
</summary>
<p>设<span class="math inline">\(f,g\in
C^1(\mathbb{R},Q)\)</span>是将实数映射为四元数的<span
class="math inline">\(C^1\)</span>连续函数，从而有： <span
class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t}(f(t)g(t))=\left(\frac{\mathrm{d}}{\mathrm{d}t}f(t)\right)g(t)+f(t)\left(\frac{\mathrm{d}}{\mathrm{d}t}g(t)\right)\]</span></p>
<p><strong>证明</strong>： <span class="math display">\[
\begin{aligned}
  \frac{\mathrm{d}}{\mathrm{d}t}(f(t)g(t))&amp;=\lim_{\delta\to
0}\frac{f(t+\delta)g(t+\delta)-f(t)g(t)}{\delta}\\
  &amp;=\lim_{\delta\to
0}\frac{f(t+\delta)g(t+\delta)-f(t+\delta)g(t)+f(t+\delta)g(t)-f(t)g(t)}{\delta}\\
  &amp;=\lim_{\delta\to
0}\left(f(t+\delta)\frac{g(t+\delta)-g(t)}{\delta}+\frac{f(t+\delta)-f(t)}{\delta}g(t)\right)\\
  &amp;=f(t)\left(\frac{\mathrm{d}}{\mathrm{d}t}g(t)\right)+\left(\frac{\mathrm{d}}{\mathrm{d}t}f(t)\right)g(t)
\end{aligned}
\]</span></p>

</details>
<details class="note primary"><summary><p>Property 5 (Chain rule)</p>
</summary>
<p>设<span class="math inline">\(f\in
C^1(Q,Q)\)</span>是将四元数映射为四元数的<span
class="math inline">\(C^1\)</span>连续函数，<span
class="math inline">\(g\in
C^1(\mathbb{R},Q)\)</span>是将实数映射为四元数的<span
class="math inline">\(C^1\)</span>连续函数，则有： <span
class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t}f(g(t))=f&#39;(g(t))g&#39;(t)\]</span></p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
  \frac{\mathrm{d}}{\mathrm{d}t}f(g(t))&amp;=\lim_{x\to
t}\frac{f(g(x))-f(g(t))}{x-t}\\
  &amp;=\lim_{x\to
t}\frac{(f(g(x))-f(g(t)))(g(x)-g(t))}{(g(x)-g(t))(x-t)}\\
  &amp;=\lim_{x\to
t}\left(\frac{f(g(x))-f(g(t))}{g(x)-g(t)}\frac{g(x)-g(t)}{x-t}\right)\\
  &amp;=f&#39;(g(t))g&#39;(t)
\end{aligned}
\]</span></p>

</details>
<details class="note primary"><summary><p>Property 6</p>
</summary>
<p>设<span class="math inline">\(q\in
C^1(\mathbb{R},Q)\)</span>是将实数映射为四元数的<span
class="math inline">\(C^1\)</span>连续函数，<span
class="math inline">\(r\in
C^1(\mathbb{R},\mathbb{R})\)</span>是将实数映射到实数的<span
class="math inline">\(C^1\)</span>连续函数，再设<span
class="math inline">\(q(t)=[\cos(\theta_t),\sin(\theta_t)\mathbf{n}_t]\)</span>。我们有：
<span class="math display">\[
\begin{aligned}
\frac{\mathrm{d}}{\mathrm{d}t}q(t)^{r(t)}&amp;={\Large[}-\sin(r(t)\theta_t)(r&#39;(t)\theta_t+r(t)\theta_t&#39;),\\
&amp;~~~~~~~~~~~\cos(r(t)\theta_t)(r&#39;(t)\theta_t+r(t)\theta_t&#39;)\mathbf{n}_t+\sin(r(t)\theta_t)\mathbf{n}&#39;_t{\Large]}
\end{aligned}
\]</span></p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
  \frac{\mathrm{d}}{\mathrm{d}t}q(t)^{r(t)}&amp;=\frac{\mathrm{d}}{\mathrm{d}t}\exp(r(t)\log(q(t)))\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}\exp(r(t)[0,\theta_t\mathbf{n}_t])\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}\exp([0,(r(t)\theta_t)\mathbf{n}_t])\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}[\cos(r(t)\theta_t),\sin(r(t)\theta_t)\mathbf{n}_t]\\
  &amp;={\Large[}-\sin(r(t)\theta_t)(r&#39;(t)\theta_t+r(t)\theta_t&#39;),\\
  &amp;~~~~~~~~~~~\cos(r(t)\theta_t)(r&#39;(t)\theta_t+r(t)\theta_t&#39;)\mathbf{n}_t+\sin(r(t)\theta_t)\mathbf{n}&#39;_t{\Large]}
\end{aligned}
\]</span></p>

</details>
<p>最后一个Property联系了四元数的乘积与点乘。</p>
<details class="note primary"><summary><p>Property 7</p>
</summary>
<p>设<span
class="math inline">\(p=[a,\mathbf{b}],q_1=[a_1,(x_1,y_1,z_1)]=[a_1,\mathbf{b}_1],q_2=[a_2,(x_2,y_2,z_2)]=[a_2,\mathbf{b}_2]\)</span>是三个四元数，则有<span
class="math inline">\((pq_1)\cdot(pq_2)=\|p\|^2(q_1\cdot
q_2)\)</span>。</p>
<p><strong>证明</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
  (pq_1)\cdot(pq_2)&amp;=[aa_1-\mathbf{b}\cdot\mathbf{b}_1,a\mathbf{b}_1+a_1\mathbf{b}+\mathbf{b}\times\mathbf{b}_1]\cdot
[aa_2-\mathbf{b}\cdot\mathbf{b}_2,a\mathbf{b}_2+a_2\mathbf{b}+\mathbf{b}\times\mathbf{b}_2]\\
  &amp;=a^2a_1a_2+(\mathbf{b}\cdot\mathbf{b}_1)(\mathbf{b}\cdot\mathbf{b}_2)+\\
  &amp;~~~~~a^2\mathbf{b}_1\cdot\mathbf{b}_2+a\mathbf{b}_1\cdot(\mathbf{b}\times\mathbf{b}_2)+a_1a_2\mathbf{b}\cdot\mathbf{b}+\\
  &amp;~~~~~a(\mathbf{b}\times\mathbf{b}_1)\cdot\mathbf{b}_2+(\mathbf{b}\times\mathbf{b}_1)\cdot(\mathbf{b}\times
\mathbf{b}_2)
\end{aligned}
\]</span></p>
<p>使用恒等式<span
class="math inline">\((\mathbf{b}\times\mathbf{b}_1)\cdot(\mathbf{b}\times
\mathbf{b}_2)=(\mathbf{b}\cdot\mathbf{b})(\mathbf{b}_1\cdot\mathbf{b}_2)-(\mathbf{b}\cdot\mathbf{b}_2)(\mathbf{b}_1\cdot\mathbf{b})\)</span>，我们有：</p>
<p><span class="math display">\[
\begin{aligned}
  (pq_1)\cdot(pq_2)&amp;=a^2a_1a_2+(\mathbf{b}\cdot\mathbf{b}_1)(\mathbf{b}\cdot\mathbf{b}_2)+\\
  &amp;~~~~~a^2\mathbf{b}_1\cdot\mathbf{b}_2+a\mathbf{b}_1\cdot(\mathbf{b}\times\mathbf{b}_2)+a_1a_2\mathbf{b}\cdot\mathbf{b}+\\
  &amp;~~~~~a(\mathbf{b}\times\mathbf{b}_1)\cdot\mathbf{b}_2+(\mathbf{b}\cdot\mathbf{b})(\mathbf{b}_1\cdot\mathbf{b}_2)-(\mathbf{b}\cdot\mathbf{b}_2)(\mathbf{b}_1\cdot\mathbf{b})\\
  &amp;=(a^2+\mathbf{b}\cdot\mathbf{b})(a_1a_2+\mathbf{b}_1\cdot\mathbf{b}_2)+a\mathbf{b}_1\cdot(\mathbf{b}\times\mathbf{b}_2)+a(\mathbf{b}\times\mathbf{b}_1)\cdot\mathbf{b}_2\\
  &amp;=\|p\|^2(q_1\cdot
q_2)+a\mathbf{b}_1\cdot(\mathbf{b}\times\mathbf{b}_2)+a(\mathbf{b}\times\mathbf{b}_1)\cdot\mathbf{b}_2
\end{aligned}
\]</span></p>
<p>最后，我们使用下述等式：</p>
<p><span class="math display">\[\mathbf{b}\cdot(\mathbf{b}_1\times
\mathbf{b}_2)=
\begin{vmatrix}
  x &amp; y &amp; z\\
  x_1 &amp; y_1 &amp; z_1\\
  x_2 &amp; y_2 &amp; z_2
\end{vmatrix}
\]</span></p>
<p>现在我们有：</p>
<p><span class="math display">\[
\begin{aligned}
  (pq_1)\cdot(pq_2)&amp;=\|p\|^2(q_1\cdot
q_2)+a\mathbf{b}_1\cdot(\mathbf{b}\times\mathbf{b}_2)+a(\mathbf{b}\times\mathbf{b}_1)\cdot\mathbf{b}_2\\
  &amp;=\|p\|^2(q_1\cdot q_2)+a\left(\begin{vmatrix}
  x_1 &amp; y_1 &amp; z_1\\
  x &amp; y &amp; z\\
  x_2 &amp; y_2 &amp; z_2
\end{vmatrix}+
\begin{vmatrix}
  x_2 &amp; y_2 &amp; z_2\\
  x &amp; y &amp; z\\
  x_1 &amp; y_1 &amp; z_1
\end{vmatrix}\right)\\
&amp;=\|p\|^2(q_1\cdot q_2)
\end{aligned}
\]</span></p>

</details>
<h2 id="三维旋转定理矩阵型">三维旋转定理（矩阵型）</h2>
<p>通过之前的讨论（尽管不完全相同，但可以类似推导）我们知道左乘一个四元数<span
class="math inline">\(w=a+bi+cj+dk\)</span>等同于下面的矩阵</p>
<p><span class="math display">\[
L(w)=
\begin{bmatrix}
  a &amp; -b &amp; -c &amp; -d\\
  b &amp; a &amp; -d &amp; c\\
  c &amp; d &amp; a &amp; -b\\
  d &amp; -c &amp; b &amp; a
\end{bmatrix}
\]</span></p>
<p>而右乘<span class="math inline">\(w\)</span>等同于</p>
<p><span class="math display">\[
R(w)=
\begin{bmatrix}
  a &amp; -b &amp; -c &amp; -d\\
  b &amp; a &amp; d &amp; -c\\
  c &amp; -d &amp; a &amp; b\\
  d &amp; c &amp; -b &amp; a
\end{bmatrix}
\]</span></p>
<p>现在我们就可以利用这个结论把<span
class="math inline">\(p&#39;=wpw^*\)</span>写成矩阵形式。假定<span
class="math inline">\(a=\cos(\tfrac{1}{2}\theta),b=\sin(\tfrac{1}{2}\theta)n_x,c=\sin(\tfrac{1}{2}\theta)n_y,d=\sin(\tfrac{1}{2}\theta)n_z,w=a+bi+cj+dk\)</span>，我们就有：</p>
<p><span class="math display">\[
\begin{aligned}
  wpw^*&amp;=L(w)R(w^*)p\\
  &amp;=\begin{bmatrix}
  a &amp; -b &amp; -c &amp; -d\\
  b &amp; a &amp; -d &amp; c\\
  c &amp; d &amp; a &amp; -b\\
  d &amp; -c &amp; b &amp; a
\end{bmatrix}
\begin{bmatrix}
  a &amp; b &amp; c &amp; d\\
  -b &amp; a &amp; -d &amp; c\\
  -c &amp; d &amp; a &amp; -b\\
  -d &amp; c &amp; b &amp; a
\end{bmatrix}p\\
&amp;=\begin{bmatrix}
  a^2+b^2+c^2+d^2 &amp; ab-ab-cd+cd &amp; ac+bd-ac-bd &amp;
ad-bc+bc-ad\\
  ab-ab+cd-cd &amp; b^2+a^2-d^2-c^2 &amp; bc-ad-ad+bc &amp;
bd+ac+bd+ac\\
  ac-bd-ac+bd &amp; bc+ad+ad+bc &amp; c^2-d^2+a^2-b^2 &amp;
cd+cd-ab-ab\\
  ad+bc-bc-ad &amp; bd-ac+bd-ac &amp; cd+cd+ab+ab &amp; d^2-c^2-b^2+a^2
\end{bmatrix}p\\
&amp;=\begin{bmatrix}
  1 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd\\
  0 &amp; 2bc+2ad &amp; 1-2b^2-2d^2 &amp; 2cd-2ab\\
  0 &amp; 2bd-2ac &amp; 2ab+2cd &amp; 1-2b^2-2c^2
\end{bmatrix}p
\end{aligned}
\]</span></p>
<p>实际上我们不需要存这个完整的<span class="math inline">\(4\times
4\)</span>的矩阵，只需要存右下角的<span class="math inline">\(3\times
3\)</span>矩阵即可。如此一来，我们就得到旋转定理的矩阵形式：</p>
<details class="note success"><summary><p>3D Rotation Theorem (Matrix)</p>
</summary>
<p>任意三维向量<span
class="math inline">\(\mathbf{p}\)</span>绕着单位向量<span
class="math inline">\(\mathbf{n}\)</span>旋转<span
class="math inline">\(\theta\)</span>度之后的向量<span
class="math inline">\(\mathbf{p}&#39;\)</span>可以用下面的矩阵表示：</p>
<p><span class="math display">\[
\mathbf{p}&#39;=\begin{bmatrix}
  1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd\\
  2bc+2ad &amp; 1-2b^2-2d^2 &amp; 2cd-2ab\\
  2bd-2ac &amp; 2ab+2cd &amp; 1-2b^2-2c^2
\end{bmatrix}\mathbf{p}
\]</span></p>
<p>其中<span
class="math inline">\(a=\cos(\tfrac{1}{2}\theta),b=\sin(\tfrac{1}{2}\theta)n_x,c=\sin(\tfrac{1}{2}\theta)n_y,d=\sin(\tfrac{1}{2}\theta)n_z\)</span>.</p>

</details>
<p>尽管看起来比较复杂，但是在实际中如果旋转轴<span
class="math inline">\(\mathbf{n}\)</span>和旋转角度<span
class="math inline">\(\theta\)</span>固定了之后，该矩阵就可以预先计算下来，在需要旋转很多<span
class="math inline">\(\mathbf{p}\)</span>时提高效率。</p>
<h2 id="三维旋转定理指数型">三维旋转定理（指数型）</h2>
<p>类似复数，我们也可以把四元数写成指数的形式。如果<span
class="math inline">\(\mathbf{n}\)</span>是一个单位向量，对于单位四元数<span
class="math inline">\(n=[0,\mathbf{n}]\)</span>，我们有:</p>
<p><span
class="math display">\[\mathrm{e}^{n\theta}=\cos(\theta)+n\sin(\theta)=\cos(\theta)+\mathbf{n}\sin(\theta)\]</span></p>
<p>也就是说，<span
class="math inline">\(w=[\cos(\theta),\sin(\theta)\mathbf{n}]=\cos(\theta)+n\sin(\theta)\)</span>可以写为<span
class="math inline">\(\mathrm{e}^{n\theta}\)</span>。你还可以注意到<span
class="math inline">\(n^2=[-\mathbf{n}\cdot\mathbf{n},0]=-1\)</span>，这与复数中的<span
class="math inline">\(i\)</span>是非常类似的。</p>
<details class="note success"><summary><p>3D Rotation Theorem (Exponential)</p>
</summary>
<p>任意三维向量<span
class="math inline">\(\mathbf{p}\)</span>绕着单位向量<span
class="math inline">\(\mathbf{n}\)</span>旋转<span
class="math inline">\(\theta\)</span>度之后的向量<span
class="math inline">\(\mathbf{p}&#39;\)</span>可以用下面的指数表示：</p>
<p><span class="math display">\[
p&#39;=\mathrm{e}^{n\frac{\theta}{2}}p\mathrm{e}^{-n\frac{\theta}{2}}
\]</span></p>
<p>其中<span
class="math inline">\(p=[0,\mathbf{p}],n=[0,\mathbf{n}]\)</span>.</p>

</details>
<p>有了指数形式，我们就可以很自然地运用关于指数的一些运算了。比如对单位四元数<span
class="math inline">\(w=[\cos(\theta),\sin(\theta)\mathbf{n}],
n=[0,\mathbf{n}]\)</span>，<span
class="math inline">\(w\)</span>的对数是：</p>
<p><span
class="math display">\[\log(w)=\log(\mathrm{e}^{n\theta})=n\theta=[0,\mathbf{n}\theta]\]</span></p>
<p>下面是幂运算；</p>
<p><span
class="math display">\[w^t=(\mathrm{e}^{n\theta})^t=\mathrm{e}^{n(t\theta)}=[\cos(t\theta),\sin(t\theta)\mathbf{n}]\]</span></p>
<p>即一个单位四元数的<span
class="math inline">\(t\)</span>次幂等同于旋转角缩放到原来的<span
class="math inline">\(t\)</span>倍，且不会改变旋转轴。</p>
<h2 id="旋转复合-1">旋转复合</h2>
<p>现在来考虑基于四元数的旋转复合，假设分别在四元数<span
class="math inline">\(w_1,w_2\)</span>上进行旋转，则有：</p>
<p><span
class="math display">\[p&#39;&#39;=w_2p&#39;w_2^*=w_2w_1pw_1^*w_2^*=wpw^*\;(w=w_2w_1)\]</span></p>
<p>上式隐含了<span
class="math inline">\((w_2w_1)^*=w_1^*w_2^*\)</span>，它的证明不多赘述。</p>
<p>需要注意的是，复合后旋转<span
class="math inline">\(w=w_2w_1\)</span>是绕着一个新的旋转轴旋转某个角度，尽管结果是相同的，但是过程完全不同。</p>
<h2 id="双倍覆盖">双倍覆盖</h2>
<p>单位四元数与三维旋转并不是双射（一对一）的，一个单位四元数对应一个三维旋转，但是一个三维旋转可以找到两个单位四元数去对应它，这就是所谓的<strong>2对1满射同态</strong>，或者说单位四元数<strong>双倍覆盖</strong>了三维旋转。</p>
<p>具体来说，<span class="math inline">\(w\)</span>与<span
class="math inline">\(-w\)</span>代表了同一个旋转：</p>
<p><span
class="math display">\[-w=[-\cos(\tfrac{1}{2}\theta),-\sin(\tfrac{1}{2}\theta)\mathbf{n}]=[\cos(\pi-\tfrac{1}{2}\theta),\sin(\pi-\tfrac{1}{2}\theta)(\mathbf{-n})]\]</span></p>
<p>即<span class="math inline">\(-w\)</span>是绕着轴<span
class="math inline">\(-\mathbf{n}\)</span>旋转了<span
class="math inline">\(2\pi-\theta\)</span>度，正好是<span
class="math inline">\(w\)</span>代表的旋转。这个结果也可以从四元数旋转公式得到：</p>
<p><span
class="math display">\[(-w)p(-w)^*=(-1)^2wpw^*=wpw^*\]</span></p>
<p>现在我们已经知道四元数相比欧拉角而言的优点了：</p>
<ul>
<li>插值非常简单（将在下一节介绍）；</li>
<li>几何意义明显，双倍覆盖三维旋转；</li>
<li>与旋转的顺序无关，一次四元数乘法即可完成旋转；</li>
<li>约束少，仅要求为单位四元数；</li>
<li>不存在Gimbal lock；</li>
<li>复合旋转简单。</li>
</ul>
<h1 id="四元数插值">四元数插值</h1>
<h2 id="基于幂运算的插值">基于幂运算的插值</h2>
<p>假设有两个旋转变换<span
class="math inline">\(w_0=[\cos(\theta_0),\sin(\theta_0)\mathbf{n}_0],w_1=[\cos(\theta_1),\sin(\theta_1)\mathbf{n}_1]\)</span>，我们希望能够通过<span
class="math inline">\(w_0,w_1\)</span>得到它们的中间旋转变换<span
class="math inline">\(w_t (t\in[0,1])\)</span>。</p>
<p>然而直接求这个中间旋转似乎比较困难，我们不妨从结果出发，期望原始向量<span
class="math inline">\(p\)</span>在经过<span
class="math inline">\(w_t\)</span>旋转之后得到的向量<span
class="math inline">\(p_t=w_tpw_t^*\)</span>，它能够位于<span
class="math inline">\(p_0=w_0pw_0^*\)</span>和<span
class="math inline">\(p_1=w_1pw_1^*\)</span>之间。所以，对于向量<span
class="math inline">\(p\)</span>而言，它是先变换到<span
class="math inline">\(p_0\)</span>，再进行<span
class="math inline">\(\Delta_t w\)</span>的变换到<span
class="math inline">\(p_t\)</span>。特殊地，当<span
class="math inline">\(t=1\)</span>的时候，就变换到了<span
class="math inline">\(p_1\)</span>的位置，这可以表示为：</p>
<p><span class="math display">\[
\begin{aligned}
  \Delta_1ww_0&amp;=w_1\\
  \Delta_1ww_0w_0^{-1}&amp;=w_1w_0^{-q}\\
  \Delta_1w&amp;=w_1w_0^*
\end{aligned}
\]</span></p>
<p>根据旋转定理的指数型，我们只要对<span
class="math inline">\(\Delta_1w\)</span>取<span
class="math inline">\(t(0\le t\le
1)\)</span>次方，就能得到插值对应的旋转了。所以：</p>
<p><span class="math display">\[
\begin{equation}
\label{eq3}
  w_t=\text{Slerp}(w_0,w_1;t)=(w_1w_0^*)^tw_0
\end{equation}
\]</span></p>
<p>这个插值方法称为<em>Slerp</em>，但它涉及到多个四元数的乘法，而且还包含幂运算，实际应用中效率很低。我们一般的插值都是使用线性组合，而不是幂运算。</p>
<h2 id="四元数在四维空间内的夹角">四元数在四维空间内的夹角</h2>
<p>公式<span
class="math inline">\(\eqref{eq3}\)</span>低效的根本原因在于我们把插值旋转<span
class="math inline">\(w_t\)</span>直接用<span
class="math inline">\(w_0,w_1\)</span>的乘积表示出来了，但我们真正关心的是<strong>对角度和旋转轴进行插值</strong>。为此，我们需要首先研究下公式<span
class="math inline">\(\eqref{eq3}\)</span>如何表示旋转角的。</p>
<p>我们有；</p>
<p><span class="math display">\[
\begin{aligned}
  \Delta_1w&amp;=w_1w_0^*\\
  &amp;=[\cos(\theta_1),\sin(\theta_1)\mathbf{n}_1]\cdot[\cos(\theta_0),\sin(\theta_0)\mathbf{n}_0]\\&amp;
  =[\cos(\theta_1)\cos(\theta_0)+(\sin(\theta_1)\mathbf{n}_1)\cdot(\sin(\theta_0)\mathbf{n}_0),\cdots]
\end{aligned}
\]</span></p>
<p>如果我们把<span
class="math inline">\(w_0,w_1\)</span>看作两个<strong>四维向量</strong>，我们发现，<span
class="math inline">\(\Delta_1w\)</span>的实部正好就是<span
class="math inline">\(w_0,w_1\)</span>点乘的结果<span
class="math inline">\(w_0\cdot w_1\)</span>。同时，又因为<span
class="math inline">\(w_0,w_1\)</span>是两个单位向量，所以它们点乘的结果就是它们夹角的余弦，记为<span
class="math inline">\(\theta\)</span>。所以我们有<span
class="math inline">\(w_0\cdot w_1=\cos(\theta)\)</span>。</p>
<p>与此同时，我们又知道<span
class="math inline">\(\Delta_1w\)</span>也代表的是一个旋转，记旋转角为<span
class="math inline">\(\phi\)</span>，它的实部为<span
class="math inline">\(\cos(\phi)\)</span>，从而有<span
class="math inline">\(\cos(\phi)=w_0\cdot
w_1=\cos(\theta)\)</span>。在区间<span
class="math inline">\([0,\pi]\)</span>上当且只有一个解<span
class="math inline">\(\phi=\theta\)</span>。这也就意味着，<span
class="math inline">\(w_0,w_1\)</span>在四维空间中的夹角<span
class="math inline">\(\theta\)</span>，正好是它们作为四元数时旋转变化量<span
class="math inline">\(\Delta_1w\)</span>所代表旋转角度的一半，即<span
class="math inline">\(\theta=\tfrac{1}{2}(2\phi)\)</span>。基于这个事实，我们套用向量的插值公式对四元数进行插值。</p>
<h2 id="lerp-nlerp-slerp">Lerp, Nlerp, Slerp</h2>
<p>前文已经提到，我们希望对四元数进行<strong>线性插值</strong>，即表示为<span
class="math inline">\(w_t=\alpha w_0+\beta
w_1\)</span>的形式。下面介绍三种线性插值方法。</p>
<h3 id="lerp">Lerp</h3>
<p>第一种是我们熟知的线性插值<em>Lerp</em>：</p>
<p><span
class="math display">\[w_t=\text{Lerp}(w_0,w_1;t)=(1-t)w_0+tw_1\]</span></p>
<p>但是，这种插值方法得到的四元数并不是单位四元数，也就是并不能真正表示三维旋转。现在我们来验证一下：</p>
<p><span class="math display">\[
\begin{aligned}
  \|w_t\|^2&amp;=((1-t)\cos(\theta_0)+t\cos(\theta_1))^2+((1-t)\sin(\theta_0)\mathbf{n}_0+t\sin(\theta_1)\mathbf{n}_1)^2\\
  &amp;=(1-t)^2\cos^2(\theta_0)+t^2\cos^2(\theta_1)+2t(1-t)\cos(\theta_0)\cos(\theta_1)\\
  &amp;+(1-t)^2\sin^2(\theta_0)+t^2\sin^2(\theta_1)+2t(1-t)\sin(\theta_0)\sin(\theta_1)\mathbf{n}_0\cdot\mathbf{n}_1\\
  &amp;=(1-t)^2+t^2+2t(1-t)(\cos(\theta_0)\cos(\theta_1)+\sin(\theta_0)\sin(\theta_1)\mathbf{n}_0\cdot\mathbf{n}_1)
\end{aligned}
\]</span></p>
<p>显然，当<span
class="math inline">\(t\in(0,1)\)</span>时，上式不等于1，这也就意味着<em>Lerp</em>插值的结果并不是一个单位四元数。</p>
<h3 id="nlerp">Nlerp</h3>
<p>既然<em>Lerp</em>的结果不是一个单位四元数，那么除以它的模长不就可以变成单位四元数了吗？这就是所谓的<em>Nlerp</em>（Normalized
Lerp）：</p>
<p><span
class="math display">\[w_t=\text{Nlerp}(w_0,w_1;t)=\frac{(1-t)w_0+tw_1}{\|(1-t)w_0+tw_1\|}\]</span></p>
<p>但是<em>Nlerp</em>的问题在于，随着<span
class="math inline">\(t\)</span>的增大，<span
class="math inline">\(w_t\)</span>的旋转角变化幅度会发生变化，或者说，<span
class="math inline">\(w_t\)</span>的旋转角变化<strong>不是线性</strong>的。</p>
<p>如下图所示，<span class="math inline">\(t\)</span>从<span
class="math inline">\(0\)</span>变换到<span
class="math inline">\(0.25\)</span>与从<span
class="math inline">\(0.25\)</span>变化到<span
class="math inline">\(0.5\)</span>旋转角的变化幅度不一样；同样地，从<span
class="math inline">\(0.5\)</span>到<span
class="math inline">\(0.75\)</span>与从<span
class="math inline">\(0.75\)</span>到<span
class="math inline">\(1\)</span>旋转角的变化幅度也不一样。我们希望<span
class="math inline">\(w_t\)</span>能够<strong>线性地</strong>改变旋转角。</p>
<p><img data-src="/images/quaternion/1.png" /></p>
<h3 id="slerp">Slerp</h3>
<p>所以，我们想要直接对角度插值。如果<span
class="math inline">\(w_0,w_1\)</span>之间的夹角为0，那么：</p>
<p><span class="math display">\[\theta_t=(1-\theta)\cdot
0+t\theta=t\theta\]</span></p>
<p>因为对角度线性插值相当于是让向量在球面上的一个弧上旋转，所以这种插值被称为球面线性插值<em>Slerp</em>（Spherical
Lerp）。我们最开始说到的基于幂运算的插值就是我们接下来要介绍的Slerp的一种等价形式。</p>
<p>对于向量<span
class="math inline">\(\mathbf{n}_0,\mathbf{n}_1\)</span>，我们希望<span
class="math inline">\(\mathbf{n}_t\)</span>能够直接表示为二者的线性组合：</p>
<p><span
class="math display">\[\mathbf{n}_t=\alpha\mathbf{n}_0+\beta\mathbf{n}_1\]</span></p>
<p>为了求解<span
class="math inline">\(\alpha,\beta\)</span>，我们对上式两边同乘<span
class="math inline">\(\mathbf{n}_0\)</span>（设<span
class="math inline">\(\mathbf{n}_0,\mathbf{n}_1\)</span>之间的夹角为<span
class="math inline">\(\theta\)</span>）：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{n}_0\cdot\mathbf{n}_t&amp;=\mathbf{n}_0\cdot(\alpha\mathbf{n}_0+\beta\mathbf{n}_1)\\
  \mathbf{n}_0\cdot\mathbf{n}_t&amp;=\alpha+\beta\mathbf{n}_0\cdot\mathbf{n}_1\\
  \cos(t\theta)&amp;=\alpha+\beta\cos(\theta)
\end{aligned}
\]</span></p>
<p>同样地，对两边同乘<span
class="math inline">\(\mathbf{n}_1\)</span>：</p>
<p><span
class="math display">\[\cos((1-t)\theta)=\alpha\cos(\theta)+\beta\]</span></p>
<p>现在，把<span
class="math inline">\(\alpha=\cos(t\theta)-\beta\cos(\theta)\)</span>代入上式，我们就有：</p>
<p><span class="math display">\[
\begin{aligned}
  \cos((1-t)\theta)&amp;=(\cos(t\theta)-\beta\cos(\theta))\cos(\theta)+\beta\\
  \cos((1-t)\theta)&amp;=\cos(t\theta)\cos(\theta)-\beta\cos^2(\theta)+\beta\\
  \beta(1-\cos^2(\theta))&amp;=\cos((1-t)\theta)-\cos(t\theta)\cos(\theta)\\
  \beta&amp;=\frac{\cos(\theta-t\theta)-\cos(t\theta)\cos(\theta)}{\sin^2(\theta)}\\
  \beta&amp;=\frac{\cos(\theta)\cos(t\theta)+\sin(\theta)\sin(t\theta)-\cos(t\theta)\cos(\theta)}{\sin^2(\theta)}\\
  \beta&amp;=\frac{\sin(t\theta)}{\sin(\theta)}
\end{aligned}
\]</span></p>
<p>把<span class="math inline">\(\beta\)</span>代回去，就能解得<span
class="math inline">\(\alpha\)</span>：</p>
<p><span
class="math display">\[\alpha=\frac{\sin((1-t)\theta)}{\sin(\theta)}\]</span></p>
<p>于是，我们能就得到最终<em>Slerp</em>的公式：</p>
<p><span class="math display">\[
w_t=\text{Slerp}(w_0,w_1;t)=\frac{\sin((1-t)\theta)}{\sin(\theta)}w_0+\frac{\sin(t\theta)}{\sin(\theta)}w_1\quad
(\theta=\arccos(w_0\cdot w_1))
\]</span></p>
<p>现在的<em>Slerp</em>已经比最开始介绍的基于幂运算的<em>Slerp</em>快很多，但是由于它涉及了三个三角函数、一个反三角函数和一次点乘，所以效率仍然比<em>Nlerp</em>低一些。此外，如果夹角<span
class="math inline">\(\theta\)</span>很小，<span
class="math inline">\(\sin(\theta)\)</span>可能因浮点精度问题被近似为<span
class="math inline">\(0\)</span>，导致运算错误。所以在实际使用<em>Slerp</em>时，要首先判断夹角<span
class="math inline">\(\theta\)</span>是否较小，若是，则改用<em>Nlerp</em>，而由于夹角很小，<em>Nlerp</em>与<em>Slerp</em>的误差可以忽略。</p>
<p>需要注意的是，<em>Slerp</em>并不是一个“万能答案”，它的运行效率显著低于<em>Nlerp</em>。此外，<em>Nlerp</em>的角速度变化不一致并不一定是个坏处，在不同的情景下可能有不同的用处。所以，在使用插值方法的时候要根据实际情况选择，大多数时候<em>Nlerp</em>已经足够了。</p>
<h2 id="双倍覆盖问题">双倍覆盖问题</h2>
<p>之前我们介绍过，四元数<span class="math inline">\(-w\)</span>与<span
class="math inline">\(w\)</span>代表的是同一个旋转，这就导致对两个四元数的插值会有效率差距。</p>
<p>如下图所示，虽然可以从<span class="math inline">\(q_0\)</span>到<span
class="math inline">\(q_1\)</span>方向插值，但是由于<span
class="math inline">\(q_1\)</span>与<span
class="math inline">\(-q_1\)</span>代表的是同一个旋转，而<span
class="math inline">\(q_0\)</span>与<span
class="math inline">\(-q_1\)</span>的夹角更小，插值造成的误差更小，所以我们这时会选择从<span
class="math inline">\(q_0\)</span>插值到<span
class="math inline">\(-q_1\)</span>。</p>
<p><img data-src="/images/quaternion/2.png" /></p>
<p>这告诉我们，在对四元数插值之前，要检查<span
class="math inline">\(w_0,w_1\)</span>之间的夹角是否是钝角，即检查它们的点积结果是否是负数，如果是负数，就对其中一个四元数取负号，然后在新的四元数间插值。</p>
<h1 id="squad">Squad</h1>
<p><em>Slerp</em>已经是我们理想中的插值方式了：它直接对角度插值，插值角度匀速变化，运算效率尚可。但是它还有一个小问题：角度变化的速率等于夹角，即<span
class="math inline">\(\tfrac{\mathrm{d}\theta_t}{\mathrm{d}t}=\tfrac{\mathrm{d}}{\mathrm{d}t}(t\theta)=\theta\)</span>，这就意味着，当我们在多个角速度之间插值的时候，当在不同的四元数之间插值的时候，速率会发生突变，或者说在切断点处<strong>不可导</strong>。从数学上讲，函数<span
class="math inline">\(f\)</span>连续并不意味着函数的一阶导连续（前者称为<span
class="math inline">\(C^0\)</span>连续，后者称为<span
class="math inline">\(C^1\)</span>连续）。</p>
<p>为此，我们希望插值的曲线能够在高阶导处也连续，下面介绍的Squad（Spherical
and quadrangle）就是一种解决方法。</p>
<p>下图是<em>Slerp</em>和<em>Squad</em>的插值结果比较，曲线是每个四元数插值结果的角速度。可以看到：<em>Slerp</em>在四元数切换时角速度会发生突变，而<em>Squad</em>的角速度则是光滑变化的。</p>
<p><img data-src="/images/quaternion/9.png" /></p>
<h2 id="bézier曲线">Bézier曲线</h2>
<p>假设我们有一个向量序列<span
class="math inline">\(\mathbf{v}_0,\mathbf{v}_1,\cdots,\mathbf{v}_n\)</span>，我们可以分别对每一对向量<span
class="math inline">\(\mathbf{v}_i,\mathbf{v}_{i+1}\)</span>插值。如果我们使用最简单的<em>Lerp</em>插值，就会得到如下图的结果：</p>
<p><img data-src="/images/quaternion/3.png" /></p>
<p>显然这个曲线是<span class="math inline">\(C^0\)</span>连续但<span
class="math inline">\(C^1\)</span>不连续，为此，我们可以使用一个四次Bézier曲线，将中间的<span
class="math inline">\(\mathbf{v}_1,\mathbf{v}_2,\mathbf{v}_3\)</span>作为控制点来生成连续曲线。然而这种方法得到的曲线一般不会经过控制点：</p>
<p><img data-src="/images/quaternion/4.png" /></p>
<p>关于Bézier曲线的相关知识可以在<a
href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Wikipedia</a>上找到介绍。</p>
<h2 id="三次bézier曲线">三次Bézier曲线</h2>
<p>为了解决这个问题，我们想让生成的曲线（1）经过每个点和（2）一阶导数连续。因此，我们可以分段对每两个向量<span
class="math inline">\(\mathbf{v}_i,\mathbf{v}_{i+1}\)</span>使用Bézier曲线，其中我们要使用前一个向量<span
class="math inline">\(\mathbf{v}_{i-1}\)</span>和后一个向量<span
class="math inline">\(\mathbf{v}_{i+2}\)</span>生成两个控制点<span
class="math inline">\(\mathbf{s}_i,\mathbf{s}_{i+1}\)</span>去控制曲线的走势。使用<span
class="math inline">\(\mathbf{s}_i,\mathbf{v}_i,\mathbf{v}_{i+1},\mathbf{s}_{i+1}\)</span>（<span
class="math inline">\(\mathbf{v}_i,\mathbf{v}_{i+1}\)</span>是端点，<span
class="math inline">\(\mathbf{s}_i,\mathbf{s}_{i+1}\)</span>是中间的控制点），就能通过一个三次Bézier曲线来插值。</p>
<p>上述做法可以保证曲线经过每个点，但是不能保证曲线在每个点处都是<span
class="math inline">\(C^1\)</span>连续的。实际上，对于三次Bézier曲线，只要保证前一个Spline（一对向量生成的曲线）在<span
class="math inline">\(\mathbf{v}_i\)</span>的控制点与当前Spline在<span
class="math inline">\(\mathbf{v}_i\)</span>的控制点分别处于最终曲线在<span
class="math inline">\(\mathbf{v}_i\)</span>处切线<strong>对等的两侧</strong>：</p>
<p><img data-src="/images/quaternion/5.png" /></p>
<p>蓝色的线就是曲线在点<span
class="math inline">\(\mathbf{v}_i\)</span>处的切线，红色的点就是控制点，每一对控制点分别处于切线对等的两侧。</p>
<p>下面我们来具体了解如何构造一个三次Bézier曲线。</p>
<h2 id="de-casteljau算法">de Casteljau算法</h2>
<p>de
Casteljau算法可以非常直观简单地构造Bézier曲线，在这里我们只关注三次Bézier曲线的情况。</p>
<p>假设我们有四个向量<span
class="math inline">\(\mathbf{v}_0,\mathbf{v}_1,\mathbf{v}_2,\mathbf{v}_3\)</span>，de
Casteljau算法首先对每一对向量<span
class="math inline">\(\mathbf{v}_0\mathbf{v}_1,\mathbf{v}_1\mathbf{v}_2,\mathbf{v}_2\mathbf{v}_3\)</span>进行线性插值，得到<span
class="math inline">\(\mathbf{v}_{01},\mathbf{v}_{12},\mathbf{v}_{23}\)</span>这三个向量：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{v}_{01}&amp;=\text{Lerp}(\mathbf{v}_0,\mathbf{v}_1;t)\\
  \mathbf{v}_{12}&amp;=\text{Lerp}(\mathbf{v}_1,\mathbf{v}_2;t)\\
  \mathbf{v}_{23}&amp;=\text{Lerp}(\mathbf{v}_2,\mathbf{v}_3;t)
\end{aligned}
\]</span></p>
<p>之后，我们对<span
class="math inline">\(\mathbf{v}_{01}\mathbf{v}_{12},\mathbf{v}_{12}\mathbf{v}_{23}\)</span>这两对向量进行线性插值，得到<span
class="math inline">\(\mathbf{v}_{012},\mathbf{v}_{123}\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{v}_{012}&amp;=\text{Lerp}(\mathbf{v}_{01},\mathbf{v}_{12};t)\\
  \mathbf{v}_{123}&amp;=\text{Lerp}(\mathbf{v}_{12},\mathbf{v}_{23};t)\\
\end{aligned}
\]</span></p>
<p>最后，我们对<span
class="math inline">\(\mathbf{v}_{012},\mathbf{v}_{123}\)</span>进行线性插值得到<span
class="math inline">\(\mathbf{v}_{0123}\)</span>，这就是我们想要的结果（插值为<span
class="math inline">\(t\)</span>时）：</p>
<p><span
class="math display">\[\mathbf{v}_{0123}=\text{Lerp}(\mathbf{v}_{012},\mathbf{v}_{123};t)\]</span></p>
<p>整个过程可以总结为下图（<span
class="math inline">\(t=0.4\)</span>）：</p>
<p><img data-src="/images/quaternion/6.png" /></p>
<p>当我们把<span class="math inline">\(t\)</span>从<span
class="math inline">\(0\)</span>变换到<span
class="math inline">\(1\)</span>时，我们就能得到黑色的曲线。</p>
<p>三次Bézier曲线的过程可以表述为：</p>
<p><span class="math display">\[
\begin{aligned}
  \text{Bézier}(\mathbf{v}_{0},\mathbf{v}_{1},\mathbf{v}_{2},\mathbf{v}_{3};t)&amp;=f(f(f(\mathbf{v}_{0},\mathbf{v}_{1};t),f(\mathbf{v}_{1},\mathbf{v}_{2};t);t),f(f(\mathbf{v}_{1},\mathbf{v}_{2};t),f(\mathbf{v}_{2},\mathbf{v}_{3};t);t);t)\\
  &amp;=(1-t)^3\mathbf{v}_{0}+3(1-t)^2t\mathbf{v}_{1}+3(1-t)t^2\mathbf{v}_{2}+t^3\mathbf{v}_{3}\;(f=\text{Lerp})
\end{aligned}
\]</span></p>
<p>这里的<span
class="math inline">\(f\)</span>对于上面的过程来说是线性插值<em>Lerp</em>，对四元数来说则是<em>Slerp</em>。但是由于一个<em>Slerp</em>涉及四个三角函数与除法运算，上式包含了<span
class="math inline">\(7\)</span>个<em>Slerp</em>，这就会导致极大的效率问题。</p>
<h2 id="squad-1">Squad</h2>
<p>三次Bézier曲线实际上是嵌套了三层一次（one-order）插值，而Squad则使用的是一层二次插值嵌套了一层一次插值。</p>
<p>我们首先是分别对<span
class="math inline">\(\mathbf{v}_{0}\mathbf{v}_{3}\)</span>和<span
class="math inline">\(\mathbf{v}_{1}\mathbf{v}_{2}\)</span>进行插值，得到<span
class="math inline">\(\mathbf{v}_{03}\)</span>和<span
class="math inline">\(\mathbf{v}_{12}\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
  \mathbf{v}_{03}&amp;=\text{Lerp}(\mathbf{v}_{0},\mathbf{v}_{3};t)\\
  \mathbf{v}_{12}&amp;=\text{Lerp}(\mathbf{v}_{1},\mathbf{v}_{2};t)
\end{aligned}
\]</span></p>
<p>之后，我们使用<span
class="math inline">\(2t(1-t)\)</span>为参数，对<span
class="math inline">\(\mathbf{v}_{03}\mathbf{v}_{12}\)</span>进行二次插值，得到最终的<span
class="math inline">\(\mathbf{v}_{0312}\)</span>：</p>
<p><span
class="math display">\[\mathbf{v}_{0312}=\text{Lerp}(\mathbf{v}_{03},\mathbf{v}_{12};2t(1-t))\]</span></p>
<p>上述过程可以通过下图阐明（<span
class="math inline">\(t=0.4\)</span>），黑色曲线就是生成的插值曲线：</p>
<p><img data-src="/images/quaternion/7.png" /></p>
<p>当然，我们也可以把它写成递归形式：</p>
<p><span
class="math display">\[\text{Squad}(\mathbf{v}_{0},\mathbf{v}_{1},\mathbf{v}_{2},\mathbf{v}_{3};t)=\text{Lerp}(\text{Lerp}(\mathbf{v}_{0},\mathbf{v}_{3};t),\text{Lerp}(\mathbf{v}_{1},\mathbf{v}_{2};t);2t(1-t))\]</span></p>
<p>我们成功地将原先的七次<em>Lerp</em>减少到了三次，且生成的曲线与原先的曲线差别也不大，可以看下图的两个对比（左边为Bézier曲线，右边为Squad曲线：</p>
<p><img data-src="/images/quaternion/8.png" /></p>
<p>按照<em>Lerp</em>的定义对上式展开，就能得到：</p>
<p><span
class="math display">\[\text{Squad}(\mathbf{v}_{0},\mathbf{v}_{1},\mathbf{v}_{2},\mathbf{v}_{3};t)=(2t^2-2t+1)(1-t)\mathbf{v}_{0}+2(1-t)^2t\mathbf{v}_{1}+2(1-t)t^2\mathbf{v}_{2}+t(2t^2-2t+1)\mathbf{v}_{3}\]</span></p>
<p>它仍然是一个三次曲线，只不过系数不同。</p>
<p>把它应用到四元数，就能得到我们想要的四元数插值版本：</p>
<p><span
class="math display">\[\text{Squad}(q_{0},q_{1},q_{2},q_{3};t)=\text{Slerp}(\text{Slerp}(q_0,q_3;t),\text{Slerp}(q_1,q_2;t);2t(1-t))\]</span></p>
<p>我们又知道<span
class="math inline">\(\text{Slerp}(q_i,q_{i+1};t)=(q_{i+1}q_i^*)^tq_i\)</span>，所以我们又可以把上式写成指数形式：</p>
<p><span
class="math display">\[\text{Squad}(q_0,q_1,q_2,q_3;t)=(\text{Slerp}(q_1,q_2;t)\text{Slerp}(q_0,q_3;t)^*)^{2t(1-t)}\text{Slerp}(q_0,q_3;t)\]</span></p>
<p>这个形式对我们后面解出控制点非常有帮助。</p>
<h2 id="squad应用">Squad应用</h2>
<p>现在我们可以使用上式对多个单位四元数进行插值了。假设我们有一个四元数序列<span
class="math inline">\(q_0,q_1,\cdots,q_n\)</span>，我们希望对每一对四元数<span
class="math inline">\(q_i,q_{i+1}\)</span>都使用<em>Squad</em>进行插值：</p>
<p><span
class="math display">\[\text{Squad}(q_i,s_i,s_{i+1},q_{i+1};t)=\text{Slerp}(\text{Slerp}(q_i,q_{i+1};t),\text{Slerp}(s_i,s_{i+1};t);2t(1-t))\]</span></p>
<p>接下来就是要找出控制点<span
class="math inline">\(s_i,s_{i+1}\)</span>，为此我们需要前一个四元数<span
class="math inline">\(q_{i-1}\)</span>和后一个四元数<span
class="math inline">\(q_{i+2}\)</span>。</p>
<p>找出<span
class="math inline">\(s_i\)</span>的基本思路是：让<em>Squad</em>在每个点处都可导，也就是说，我们希望<span
class="math inline">\(q_{i-1}q_i\)</span>插值时在<span
class="math inline">\(t=1\)</span>处的导数，与<span
class="math inline">\(q_{i}q_{i+1}\)</span>插值时在<span
class="math inline">\(t=0\)</span>处的导数相等：</p>
<p><span
class="math display">\[\text{Squad}&#39;(q_{i-1},s_{i-1},s_i,q_i;1)=\text{Squad}&#39;(q_i,s_i,s_{i+1},q_{i+1};0)\]</span></p>
<p>注意到上面的<span class="math inline">\(s_i\)</span>在对<span
class="math inline">\(q_{i-1}q_i\)</span>和对<span
class="math inline">\(q_iq_{i+1}\)</span>插值时都是一样的，与我们之前说的位于切线两端的向量不同，因为它们并非是同一个<span
class="math inline">\(s_i\)</span>。在这里，我们假定这样的<span
class="math inline">\(s_i\)</span>只有一个，我们只需要通过代数方法求出即可。</p>
<p>通过上面的等式，我们可以求出<span
class="math inline">\(s_i\)</span>：</p>
<p><span
class="math display">\[s_i=q_i\exp\left(-\frac{\log(q^*_iq_{i-1})+\log(q^*_iq_{i+1})}{4}\right)\]</span></p>
<p>下面是上述结果的推导过程，篇幅较长，不感兴趣的读者粗看即可。所以，和原始版本的三次贝塞尔曲线（包含<span
class="math inline">\(7\)</span>次<em>Slerp</em>、每次<em>Slerp</em>包含四个三角函数）相比，<em>Squad</em>仅包含<span
class="math inline">\(3\)</span>次<em>Slerp</em>、每次<em>Slerp</em>包含四个三角函数，二者都需求出两个控制点<span
class="math inline">\(s_i,s_{i+1}\)</span>。总的来说，<em>Squad</em>效率显著高于三次Bézier曲线。</p>
<details class="note success"><summary><p>A derivation of control point <span
class="math inline">\(s_i\)</span></p>
</summary>
<p>为方便起见，我们记<span
class="math inline">\(g_i(t)=\text{Slerp}(s_i,s_{i+1};t)\text{Slerp}(q_i,q_{i+1};t)^*\)</span>，我们有：</p>
<p><span class="math display">\[
\begin{aligned}
  \frac{\mathrm{d}}{\mathrm{d}t}\text{Squad}(q_i,s_i,s_{i+1},q_{i+1};t)&amp;=\frac{\mathrm{d}}{\mathrm{d}t}\text{Slerp}(\text{Slerp}(q_i,q_{i+1};t),\text{Slerp}(s_i,s_{i+1};t);2t(1-t))\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}\left(g_i(t)^{2t(1-t)}\text{Slerp}(q_i,q_{i+1};t)\right)\\
  &amp;=\left(\frac{\mathrm{d}}{\mathrm{d}t}g_i(t)^{2t(1-t)}\right)\text{Slerp}(q_i,q_{i+1};t)\\
  &amp;+g_i(t)^{2t(1-t)}\left(\frac{\mathrm{d}}{\mathrm{d}t}\text{Slerp}(q_i,q_{i+1};t)\right)\\
  &amp;=\left(\frac{\mathrm{d}}{\mathrm{d}t}g_i(t)^{2t(1-t)}\right)\text{Slerp}(q_i,q_{i+1};t)+\\
  &amp;+g_i(t)^{2t(1-t)}\text{Slerp}(q_i,q_{i+1};t)\log(q_{i+1}q_i^*)
\end{aligned}
\]</span></p>
<p>因为<span
class="math inline">\(g_i(t)\)</span>仍然是个单位四元数，所以可以写成：</p>
<p><span
class="math display">\[g_i(t)=[\cos(\theta_{g_i(t)}),\sin(\theta_{g_i(t)})\mathbf{n}_{g_i(t)}]\]</span></p>
<p>所以我们就能求出<span
class="math inline">\(g_i(t)^{2t(1-t)}\)</span>的导数：</p>
<p><span class="math display">\[
\begin{aligned}
  \frac{\mathrm{d}}{\mathrm{d}t}g_i(t)^{2t(1-t)}&amp;=\frac{\mathrm{d}}{\mathrm{d}t}\mathrm{e}^{2t(1-t)\log(g_i(t))}\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}\mathrm{e}^{2t(1-t)[0,\mathbf{n}_{g_i(t)}\theta_{g_i(t)}]}\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}\mathrm{e}^{[0,2t(1-t)\mathbf{n}_{g_i(t)}\theta_{g_i(t)}]}\\
  &amp;=\frac{\mathrm{d}}{\mathrm{d}t}[\cos(2t(1-t)\theta_{g_i(t)}),\sin(2t(1-t)\theta_{g_i(t)})\mathbf{n}_{g_i(t)}]\\
  &amp;={\Large[}-\sin\left(2t(1-t)\theta_{g_i(t)}\right)\left((2-4t)\theta_{g_i(t)}+2t(1-t)\theta&#39;_{g_i(t)}\right),\\
  &amp;~~~~~~~~~~~\cos\left(2t(1-t)\theta_{g_i(t)}\right)\left((2-4t)\theta_{g_i(t)}+2t(1-t)\theta&#39;_{g_i(t)}\right)\mathbf{n}_{g_i(t)}+\\
  &amp;~~~~~~~~~~~\sin\left(2t(1-t)\theta_{g_i(t)}\right)\mathbf{n}&#39;_{g_i(t)}{\Large]}
\end{aligned}
\]</span></p>
<p>从而，我们把<span class="math inline">\(t=0\)</span>代入，有：</p>
<p><span
class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t}g_i(t)^{2t(1-t)}{\LARGE|}_{t=0}=[0,
2\theta_{g_i(0)}\mathbf{n}_{g_i(0)}]=2\log(s_iq_i^*)\]</span></p>
<p>我们再把这个结果代回<span
class="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\text{Squad}(q_i,s_i,s_{i+1},q_{i+1};t)\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
  \frac{\mathrm{d}}{\mathrm{d}t}\text{Squad}(q_i,s_i,s_{i+1},q_{i+1};t){\LARGE|}_{t=0}&amp;=q_i[0,
2\theta_{g_i(0)}\mathbf{n}_{g_i(0)}]+q_i\log(q_{i+1}q_i^*)\\
  &amp;=q_i(2\log(s_iq_i^*)+\log(q_{i+1}q_i^*))
\end{aligned}
\]</span></p>
<p>同样地，我们可以求出<span
class="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\text{Squad}(q_{i-1},s_{i-1},s_{i},q_{i};t)|_{t=1}\)</span>：</p>
<p><span
class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t}\text{Squad}(q_{i-1},s_{i-1},s_{i},q_{i};t){\LARGE|}_{t=1}=q_i(-2\log(s_iq_i^*)+\log(q_iq_{i-1}^*))\]</span></p>
<p>我们令两式相等，即得：</p>
<p><span class="math display">\[
\begin{aligned}
  q_i(-2\log(s_iq_i^*)+\log(q_iq_{i-1}^*))&amp;=q_i(2\log(s_iq_i^*)+\log(q_{i+1}q_i^*))\\
  4\log(s_iq_i^*)&amp;=\log(q_iq_{i-1}^*)-\log(q_{i+1}q_i^*)\\
  s_i&amp;=\exp\left(\frac{\log(q_iq_{i-1}^*)-\log(q_{i+1}q_i^*)}{4}\right)q_i
\end{aligned}
\]</span></p>
<p>最后我们再根据<span
class="math inline">\((q_1q_2)^*=q_2^*q_1^*\)</span>，单位四元数<span
class="math inline">\(q^*=q^{-1}\)</span>和<span
class="math inline">\(\log(q^*)=-\log(q)\)</span>，得到最开始提出的结果：</p>
<p><span
class="math display">\[s_i=\exp\left(-\frac{\log(q_{i-1}q^*_i)+\log(q_{i+1}q_i^*)}{4}\right)q_i=q_i\exp\left(-\frac{\log(q^*_iq_{i-1})+\log(q^*_iq_{i+1})}{4}\right)\]</span></p>

</details>
<p>你可以验证最后一个等式的正确性。</p>
<p>与两个四元数插值一样，Squad在多个四元数插值时仍然会有双重覆盖的影响，在计算控制点和插值之前，需要先选中一个四元数，检测它与其他三个四元数之间的夹角，如果是钝角就翻转。</p>
<h1
id="angleeulermatrixquaternion之间的相互转换">Angle、Euler、Matrix、Quaternion之间的相互转换</h1>
<p>我们首先总结一下表示旋转的四种方法：</p>
<ul>
<li>Angle Axis（简称为Angle）：任何一个旋转都可以表示为绕一个轴<span
class="math inline">\(\mathbf{n}\)</span>旋转<span
class="math inline">\(\theta\)</span>度，这里的旋转轴<span
class="math inline">\(\mathbf{n}\)</span>并不一定是坐标轴。</li>
<li>Euler
Angles（简称为Euler）：任何一个旋转都可以表示为绕标准坐标系的旋转，旋转顺序可以自定。</li>
<li>Matrix
Multiplication（简称为Matrix）：任何一个旋转都可以用矩阵乘法表示。</li>
<li>Quaternion
Rotation（简称为Quaternion)：任何一个旋转都可以用四元数的乘法表示。</li>
</ul>
<p>这几种表示方法实际上可以相互转化，下面将进行介绍。</p>
<h2 id="angle转化为其他形式">Angle转化为其他形式</h2>
<h3 id="angle转化为euler">Angle转化为Euler</h3>
<p>我们可以将四元数作为中间媒介进行转换，即先使用<a
href="#angle转化为quaternion">Angle转化为Quaternion</a>将Axis
Angle转化为四元数：</p>
<p><span class="math display">\[
w=[\cos(\omega/2),\sin(\omega/2)n_x,\sin(\omega/2)n_y,\sin(\omega/2)n_z]
\]</span></p>
<p>然后再通过<a
href="#quaternion转化为angle">Quaternion转化为Angle</a>将四元数转化为Euler
Angles：</p>
<p><span class="math display">\[
\begin{aligned}
  \theta&amp;=\text{atan2}\left(\frac{2ab+2cd}{\cos(\phi)},\frac{1-2b^2-2c^2}{\cos(\phi)}\right)\\
  \phi&amp;=\arcsin(-(2bd-2ac))\\
  \tau&amp;=\text{atan2}\left(\frac{2bc+2ad}{\cos(\phi)},\frac{1-2c^2-2d^2}{\cos(\phi)}\right)
\end{aligned}
\]</span></p>
<p>其中<span
class="math inline">\(a=\cos(\omega/2),b=\sin(\omega/2)n_x,c=\sin(\omega/2)n_y,d=\sin(\omega/2)n_z\)</span>。</p>
<h3 id="angle转化为matrix">Angle转化为Matrix</h3>
<p>在<a
href="https://sulley.cc/2021/06/07/%E5%90%91%E9%87%8F%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC/">向量绕任意轴旋转的简单推导</a>这篇文章中，我们已经推导出了AngleAxis对应的矩阵形式：</p>
<p><span
class="math display">\[\mathbf{R}=\mathbf{I}+\sin(\theta)\mathbf{N}+(1-\cos(\theta))\mathbf{N}^2,\;
\mathbf{N}=\begin{bmatrix}0&amp;-n_z&amp;n_y\\n_z&amp;0&amp;-n_x\\-n_y&amp;n_x&amp;0\end{bmatrix}\]</span></p>
<h3 id="angle转化为quaternion">Angle转化为Quaternion</h3>
<p>Angle与Quaternion在本质上是一致的，我们在<a
href="#三维旋转定理四元数型">三维旋转定理（四元数型）</a>一节中已经证明过了。所以，对于轴为<span
class="math inline">\(\mathbf{n}\)</span>，旋转角为<span
class="math inline">\(\theta\)</span>的Angle表示来说，只需要构造四元数<span
class="math inline">\(w=[\cos(\theta/2),\sin(\theta/2)\mathbf{n}]\)</span>即可。</p>
<h2 id="euler转化为其他形式">Euler转化为其他形式</h2>
<h3 id="euler转化为angle">Euler转化为Angle</h3>
<p>首先通过<a
href="#euler转化为matrix">Euler转化为Matrix</a>把欧拉角转化为对应的矩阵<span
class="math inline">\(R\)</span>：</p>
<p><span class="math display">\[
R=
\begin{bmatrix}
\cos(\phi)\cos(\tau) &amp;
\sin(\theta)\sin(\phi)\cos(\tau)-\cos(\theta)\sin(\tau) &amp;
\cos(\theta)\sin(\phi)\cos(\tau)+\sin(\theta)\sin(\tau)\\
\cos(\phi)\sin(\tau) &amp;
\sin(\theta)\sin(\phi)\sin(\tau)+\cos(\theta)\cos(\tau) &amp;
\cos(\theta)\sin(\phi)\sin(\tau)-\sin(\theta)\cos(\tau)\\
-\sin(\phi) &amp; \sin(\theta)\cos(\phi) &amp; \cos(\theta)\cos(\phi)
\end{bmatrix}
\]</span></p>
<p>然后再通过<a
href="#matrix转化为angle">Matrix转化为Angle</a>求解对应的（unnormalized）旋转轴<span
class="math inline">\(\mathbf{u}\)</span>与旋转角<span
class="math inline">\(\omega\)</span>：</p>
<p><span class="math display">\[\mathbf{u}=
\begin{bmatrix}
  \sin(\theta)\cos(\phi)-\cos(\theta)\sin(\phi)\sin(\tau)+\sin(\theta)\cos(\tau)\\
  \cos(\theta)\sin(\phi)\cos(\tau)+\sin(\theta)\sin(\tau)+\sin(\phi)\\
  \cos(\phi)\sin(\tau)-\sin(\theta)\sin(\phi)\cos(\tau)+\cos(\theta)\sin(\tau)
\end{bmatrix},\;
\omega=\arccos\left(\frac{\text{tr}(R)-1}{2}\right)
\]</span></p>
<h3 id="euler转化为matrix">Euler转化为Matrix</h3>
<p>在<a
href="#欧拉角坐标系与旋转顺序">欧拉角、坐标系与旋转顺序</a>一节中我们已经证明了：对于以<span
class="math inline">\(x\to y\to
z\)</span>为顺序的欧拉角旋转，旋转矩阵是：</p>
<p><span class="math display">\[
R=R_z(\tau)R_y(\phi)R_x(\theta)=
\begin{bmatrix}
\cos(\phi)\cos(\tau) &amp;
\sin(\theta)\sin(\phi)\cos(\tau)-\cos(\theta)\sin(\tau) &amp;
\cos(\theta)\sin(\phi)\cos(\tau)+\sin(\theta)\sin(\tau)\\
\cos(\phi)\sin(\tau) &amp;
\sin(\theta)\sin(\phi)\sin(\tau)+\cos(\theta)\cos(\tau) &amp;
\cos(\theta)\sin(\phi)\sin(\tau)-\sin(\theta)\cos(\tau)\\
-\sin(\phi) &amp; \sin(\theta)\cos(\phi) &amp; \cos(\theta)\cos(\phi)
\end{bmatrix}
\]</span></p>
<h3 id="euler转化为quaternion">Euler转化为Quaternion</h3>
<p>我们知道，Euler角的旋转是有顺序的，且每一次旋转都是绕标准坐标轴的旋转，所以，我们可以相应地构造出三个四元数去表示这些旋转（旋转顺序为<span
class="math inline">\(x\to y\to z\)</span>，对应角度为<span
class="math inline">\(\theta,\phi,\tau\)</span>）：</p>
<p><span class="math display">\[
\begin{aligned}
  w_x&amp;=[\cos(\theta/2),\sin(\theta/2)(1,0,0)]=[\cos(\theta/2),\sin(\theta/2),0,0]\\
  w_y&amp;=[\cos(\phi/2),\sin(\phi/2)(0,1,0)]=[\cos(\phi/2),0,\sin(\phi/2),0]\\
  w_z&amp;=[\cos(\tau/2),\sin(\tau/2)(0,0,1)]=[\cos(\tau/2),0,0,\sin(\tau/2)]
\end{aligned}
\]</span></p>
<p>将这三个四元数相乘，即得到结果：</p>
<p><span class="math display">\[
\begin{aligned}
  w&amp;=w_zw_yw_x\\
   &amp;=
   \begin{bmatrix}
     \cos(\tau/2)\\
     0\\
     0\\
     \sin(\tau/2)
   \end{bmatrix}
   \begin{bmatrix}
     \cos(\phi/2)\\
     0\\
     \sin(\phi/2)\\
     0
   \end{bmatrix}
   \begin{bmatrix}
     \cos(\theta/2)\\
     \sin(\theta/2)\\
     0\\
     0
   \end{bmatrix}\\
   &amp;=\begin{bmatrix}
     \cos(\theta/2)\cos(\phi/2)\cos(\tau/2)+\sin(\theta/2)\sin(\phi/2)\sin(\tau/2)\\
     \sin(\theta/2)\cos(\phi/2)\cos(\tau/2)-\cos(\theta/2)\sin(\phi/2)\sin(\tau/2)\\
     \cos(\theta/2)\sin(\phi/2)\cos(\tau/2)+\sin(\theta/2)\cos(\phi/2)\sin(\tau/2)\\
     \cos(\theta/2)\cos(\phi/2)\sin(\tau/2)-\sin(\theta/2)\sin(\phi/2)\cos(\tau/2)
   \end{bmatrix}
\end{aligned}
\]</span></p>
<h2 id="matrix转化为其他形式">Matrix转化为其他形式</h2>
<h3 id="matrix转化为angle">Matrix转化为Angle</h3>
<p>给定旋转矩阵<span
class="math inline">\(R=\begin{bmatrix}R_{11}&amp;R_{12}&amp;R_{13}\\R_{21}&amp;R_{22}&amp;R_{23}\\R_{31}&amp;R_{32}&amp;R_{33}\end{bmatrix}\)</span>，并假设对应的旋转轴是<span
class="math inline">\(\mathbf{n}\)</span>、旋转角度是<span
class="math inline">\(\omega\)</span>。显然，如果一个向量<span
class="math inline">\(\mathbf{u}\)</span>平行于<span
class="math inline">\(\mathbf{n}\)</span>，则<span
class="math inline">\(R\mathbf{u}=\mathbf{u}\)</span>，从而<span
class="math inline">\((R-I)\mathbf{u}=0\)</span>。</p>
<p>从特征向量的角度来看，<span
class="math inline">\(\mathbf{u}\)</span>是<span
class="math inline">\(R\)</span>的一个特征向量，它对应的特征值为<span
class="math inline">\(\lambda=1\)</span>。从而我们知道：每个旋转矩阵就有一个特征值为<span
class="math inline">\(1\)</span>。为了求出旋转轴，我们有：</p>
<p><span class="math display">\[\begin{aligned}
  0&amp;=R^\top 0+0\\
  &amp;=R^\top(R-I)\mathbf{u}+(R-I)\mathbf{u}\\
  &amp;=(R^\top R-R^\top+R-I)\mathbf{u}\\
  &amp;=(I-R^\top+R-I)\mathbf{u}\\
  &amp;=(R-R^\top)\mathbf{u}
\end{aligned}\]</span></p>
<p>从而我们有：</p>
<p><span class="math display">\[
\begin{cases}
  0=u_y(R_{12}-R_{21})+u_z(R_{13}-R_{31})\\
  0=u_x(R_{21}-R_{12})+u_z(R_{23}-R_{32})\\
  0=u_x(R_{31}-R_{13})+u_y(R_{32}-R_{23})
\end{cases}\Rightarrow
\mathbf{u}=\begin{bmatrix}
  R_{32}-R_{23}\\
  R_{13}-R_{31}\\
  R_{21}-R_{12}
\end{bmatrix}
\]</span></p>
<p>所以<span
class="math inline">\(\mathbf{n}=\mathbf{u}/\|\mathbf{n}\|\)</span>。注意到上面的推导过程在<span
class="math inline">\(R\)</span>为对称矩阵时不成立，这时候就要按照常规的求特征向量的步骤去求<span
class="math inline">\(\mathbf{u}\)</span>了。</p>
<p>既然我们已经知道了旋转轴<span
class="math inline">\(\mathbf{n}\)</span>，这时只需要找一个垂直于<span
class="math inline">\(\mathbf{n}\)</span>的向量<span
class="math inline">\(\mathbf{v}\)</span>，旋转轴就是<span
class="math inline">\(\mathbf{v}\)</span>和<span
class="math inline">\(R\mathbf{v}\)</span>的夹角。</p>
<p>我们也可以从特征值的角度出发。在三维空间内，旋转矩阵的三个特征值分别为<span
class="math inline">\(\lambda=1,\mathrm{e}^{i\omega},\mathrm{e}^{-i\omega}\)</span>，三者之和为<span
class="math inline">\(1+\mathrm{e}^{i\omega}+\mathrm{e}^{-i\omega}=1+2\cos(\omega)=\text{tr}(R)=R_{11}+R_{22}+R_{33}\)</span>，于是：</p>
<p><span
class="math display">\[\omega=\arccos\left(\frac{\text{tr}(R)-1}{2}\right)\]</span></p>
<h3 id="matrix转化为euler">Matrix转化为Euler</h3>
<p>对于旋转矩阵<span
class="math inline">\(R=\begin{bmatrix}R_{11}&amp;R_{12}&amp;R_{13}\\R_{21}&amp;R_{22}&amp;R_{23}\\R_{31}&amp;R_{32}&amp;R_{33}\end{bmatrix}\)</span>，通过上面<a
href="#euler转化为matrix">Euler到Matrix的转换</a>，我们知道<span
class="math inline">\(\sin(\phi)=-R_{31}\Rightarrow
\phi=\arcsin(R_{31})\)</span>。从而有：</p>
<p><span class="math display">\[
\begin{aligned}
  \phi&amp;=\arcsin(-R_{31})\\
  \theta&amp;=\text{atan2}\left(\frac{R_{32}}{\cos(\phi)},\frac{R_{33}}{\cos(\phi)}\right)\\
  \tau&amp;=\text{atan2}\left(\frac{R_{21}}{\cos(\phi)},\frac{R_{11}}{\cos(\phi)}\right)
\end{aligned}
\]</span></p>
<p>上式仅在<span class="math inline">\(\cos(\phi)\neq
0\)</span>，也即<span class="math inline">\(R_{31}\neq \pm
1\)</span>时才成立。当<span class="math inline">\(R_{31}=\pm
1\)</span>时，原矩阵退化为Gimbal
Lock，因此无法转化为对应的Euler角。从上面的过程来看，对一个旋转矩阵，至少有两组Euler角与它对应，在某些情况下甚至有无穷解。</p>
<h3 id="matrix转化为quaternion">Matrix转化为Quaternion</h3>
<p>给定矩阵<span
class="math inline">\(R=\begin{bmatrix}R_{11}&amp;R_{12}&amp;R_{13}\\R_{21}&amp;R_{22}&amp;R_{23}\\R_{31}&amp;R_{32}&amp;R_{33}\end{bmatrix}\)</span>，我们不难通过<a
href="#quaternion转化为matrix">Quaternion转化为Matrix</a>得到下述关系成立：</p>
<p><span class="math display">\[
\begin{aligned}
  1+R_{11}+R_{22}+R_{33}&amp;=4-4(b^2+c^2+d^2)\\
  &amp;=4-4(1-a^2)\\
  &amp;=4a^2
\end{aligned}
\]</span></p>
<p>所以我们就能解出<span class="math inline">\(a,b,c,d\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
  a&amp;=\pm\frac{1}{2}\sqrt{1+R_{11}+R_{22}+R_{33}}\\
  b&amp;=\frac{R_{32}-R_{23}}{4a}\\
  c&amp;=\frac{R_{13}-R_{31}}{4a}\\
  d&amp;=\frac{R_{21}-R_{12}}{4a}
\end{aligned}
\]</span></p>
<p>从而得到四元数<span class="math inline">\(w=[a,b,c,d]\)</span>。</p>
<h2 id="quaternion转化为其他形式">Quaternion转化为其他形式</h2>
<h3 id="quaternion转化为angle">Quaternion转化为Angle</h3>
<p>Quaternion转化为Axis Angle的结果我们已经在<a
href="#三维旋转定理四元数型">三维旋转定理（四元数型）</a>一节中给出。给定单位四元数<span
class="math inline">\(w=[a,\mathbf{b}]\)</span>，我们可以通过变换：</p>
<p><span
class="math display">\[\frac{\theta}{2}=\arccos(a),\;\mathbf{n}=\frac{\mathbf{b}}{\sin(\arccos(a))}\]</span></p>
<p>得到它的等价形式<span
class="math inline">\(w=[a,\mathbf{b}]=[\cos(\tfrac{\theta}{2}),\sin(\tfrac{\theta}{2})\mathbf{n}]\)</span>，从而，<span
class="math inline">\(\theta\)</span>即为旋转角，<span
class="math inline">\(\mathbf{n}\)</span>即为旋转轴。</p>
<h3 id="quaternion转化为euler">Quaternion转化为Euler</h3>
<p>使用<a href="#quaternion转化为matrix">Quaternion转化为Matrix</a>和<a
href="#matrix转化为euler">Matrix转化为Euler</a>的结果，我们能求出以<span
class="math inline">\(x\to y\to z\)</span>为顺序的欧拉角<span
class="math inline">\(\theta/\phi/\tau\)</span>：</p>
<p><span class="math display">\[
\begin{aligned}
  \theta&amp;=\text{atan2}\left(\frac{2ab+2cd}{\cos(\phi)},\frac{1-2b^2-2c^2}{\cos(\phi)}\right)\\
  \phi&amp;=\arcsin(-(2bd-2ac))\\
  \tau&amp;=\text{atan2}\left(\frac{2bc+2ad}{\cos(\phi)},\frac{1-2c^2-2d^2}{\cos(\phi)}\right)
\end{aligned}
\]</span></p>
<h3 id="quaternion转化为matrix">Quaternion转化为Matrix</h3>
<p>结果已经由<a
href="#三维旋转定理矩阵型">三维旋转定理（矩阵型）</a>一节给出，结果是：</p>
<p><span class="math display">\[
R=\begin{bmatrix}
  1 &amp; 0 &amp; 0 &amp; 0\\
  0 &amp; 1-2c^2-2d^2 &amp; 2bc-2ad &amp; 2ac+2bd\\
  0 &amp; 2bc+2ad &amp; 1-2b^2-2d^2 &amp; 2cd-2ab\\
  0 &amp; 2bd-2ac &amp; 2ab+2cd &amp; 1-2b^2-2c^2
\end{bmatrix}
\]</span></p>
<p>其中<span
class="math inline">\(a=\cos(\tfrac{1}{2}\theta),b=\sin(\tfrac{1}{2}\theta)n_x,c=\sin(\tfrac{1}{2}\theta)n_y,d=\sin(\tfrac{1}{2}\theta)n_z\)</span>。</p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"
role="doc-endnote"><p>https://krasjet.github.io/quaternion/quaternion.pdf<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"
role="doc-endnote"><p>https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"
role="doc-endnote"><p>http://www.euclideanspace.com/maths/geometry/rotations/conversions/index.htm<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"
role="doc-endnote"><p>http://number-none.com/product/Hacking%20Quaternions/index.html<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"
role="doc-endnote"><p>http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"
role="doc-endnote"><p>https://web.mit.edu/2.998/www/QuaternionReport1.pdf<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"
role="doc-endnote"><p>https://www.geometrictools.com/Documentation/RotationRepresentations.pdf<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"
role="doc-endnote"><p>https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Rotation_matrix_%E2%86%94_Euler_axis/angle<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《Real-Time Cameras》笔记</title>
    <url>/2022/05/05/21/40/</url>
    <content><![CDATA[<p>本文是《Real-Time Cameras: A Guide for Game Designers and
Developers》的阅读笔记，放在此备份供参阅。</p>
<span id="more"></span>
<h1 id="part-1-core-concepts">Part 1: Core Concepts</h1>
<ul>
<li>第一章：介绍了游戏应用与其中的相机系统。</li>
<li>第二章：讲述游戏相机的基础概念与发展。</li>
<li>第三章：介绍电影摄影的基础知识与应用。</li>
</ul>
<h2 id="chapter-1-game-overview">Chapter 1: Game Overview</h2>
<p>一个典型的游戏引擎（Game Engine）应当包括：</p>
<ul>
<li>资源管理系统（Resource Management）</li>
<li>玩家控制（Player Control）</li>
<li>物理模拟（Physics Simulation）</li>
<li>游戏对象逻辑（Game Object Logic）</li>
<li>图形用户界面（Graphical User Interface）</li>
<li>相机与视口管理（Camera and Viewport Management）</li>
<li>网络交流（Network Communication）</li>
<li>人工智能（AI）</li>
<li>游戏事件管理（Game Event Management）</li>
<li>渲染（Rendering）</li>
<li>对象间交流（Inter-Object Communication）<br />
</li>
<li>音频（Audio）</li>
<li>任务管理（Task Management）</li>
<li>……</li>
</ul>
<figure>
<img data-src="/images/realtime_cameras/1-1.png"
alt="游戏各系统之间的联系。" />
<figcaption aria-hidden="true">游戏各系统之间的联系。</figcaption>
</figure>
<p>游戏的每个系统都有相对固定的更新顺序，如下图所示：</p>
<figure>
<img data-src="/images/realtime_cameras/1-2.png"
alt="游戏各系统的更新顺序。" />
<figcaption aria-hidden="true">游戏各系统的更新顺序。</figcaption>
</figure>
<p>对于每个步骤的介绍如下：</p>
<ul>
<li><strong>Input</strong>：通常是每帧更新一次，但一些游戏也会每帧更新若干次，从而精准反应玩家输入。</li>
<li><strong>Think</strong>：大部分游戏逻辑得到更新，包括玩家输入、AI、游戏事件生成等。</li>
<li><strong>Move</strong>：更新物理模拟、碰撞检测等内容。</li>
<li><strong>Messaging</strong>：用于在游戏对象、游戏系统之间传递信息，比如新游戏对象的激活、开门、敌人死亡、资源加载完成、动画事件、碰撞等等。Messaging并不是一定会在Update
Loop中出现，可能会在消息发出的瞬间被处理，或者延迟处理。Messaging系统有利于不同系统之间的解耦，简化游戏录像逻辑。Messaging本质上是一种保证不同时间点游戏事件同步的技术。</li>
<li><strong>Camera</strong>：主要包含以下步骤：
<ul>
<li>移除无用的camera</li>
<li>激活需要的camera</li>
<li>决定哪个camera用于渲染</li>
<li>更新当前激活的相机</li>
<li>更新主相机</li>
<li>基于主相机更新玩家control reference frame</li>
<li>构建transformation matrices用于渲染，包括特效如shaking, FOV等</li>
</ul></li>
<li><strong>Post-Camera</strong>：更新依赖于相机的物体</li>
<li><strong>Render</strong>：有时候一个camera view也会被用于另一个camera
view的生成过程中</li>
</ul>
<p><strong>对于相机而言，Occam's
Razor法则适用：最简单的相机解决方案通常是最好的。</strong></p>
<p>相机系统的作用包括：</p>
<ul>
<li>管理活跃相机，保证其逻辑正常</li>
<li>控制相机增删</li>
<li>支持相机参数动态调整</li>
<li>为玩家操控提供参考帧（reference frames）</li>
<li>处理所有非交互式电影片段</li>
<li>管理并更新视口</li>
<li>获取frustum信息以展示view</li>
<li>提供可选的debug能力</li>
</ul>
<p>角色控制与角色移动之间的关系被称为<strong>控制参考帧（control
reference frame）</strong>。</p>
<h2 id="chapter-2-camera-fundamentals">Chapter 2: Camera
Fundamentals</h2>
<h3 id="real-world-cameras">Real-World Cameras</h3>
<p>真实世界的相机大概包含以下关键要素：</p>
<ul>
<li>Lens type</li>
<li>Capture method</li>
<li>Film stock</li>
<li>Capture rate</li>
<li>Exposure of film</li>
<li>Projection method</li>
<li>Aspect ratio</li>
</ul>
<p>真实世界相机的一些特点：</p>
<ul>
<li>缺乏交互性</li>
<li>预先决定的机位</li>
<li>相机镜头</li>
<li>场景切换</li>
<li>胶片曝光</li>
<li>后处理特效</li>
</ul>
<p>游戏相机的一些特点：</p>
<ul>
<li>模拟真实世界相机的功能</li>
<li>不需要相机实体</li>
<li>动态变化</li>
<li>允许游戏世界的不同投影</li>
<li>可变的光照与渲染</li>
<li>更多样的转场</li>
<li>允许特殊效果</li>
</ul>
<p>一些专有名词：</p>
<ul>
<li>Game system:
管理相机、应用相机、控制相机行为、生成用于渲染的信息、控制参考帧</li>
<li>Game camera: 抽象的游戏实体</li>
<li>Presentation style: 指将游戏世界投影到屏幕空间的方法</li>
<li>Camera behavior: 一人称/三人称相机，影院式/交互式相机</li>
<li>Look-at position: 相机朝向的位置</li>
<li>Desired position: 相机移动的位置</li>
<li>Orientation: 相机朝向</li>
<li>Desired orientation: 相机的目标朝向</li>
<li>Rotation: 朝向的变化量</li>
<li>View frustum: 游戏世界的可视空间</li>
<li>Viewport: 呈现在显示设备上的一种数据结构</li>
<li>Field of view: View frustum的上下/左右边界的夹角</li>
<li>Aspect ratio: 长宽比，对于standard definition television
(SDTV)来说，是4:3，对high-definition television
(HDTV)是16:9。对电影投影中使用最多的是1.85 (CinemaScope)和2.35
(anamorphic)</li>
<li>Refresh or frame rate: 刷新率</li>
<li>Refresh and motion blur:
刷新模糊指显示设备刷新率不能与计算机的输出同步，运动模糊是因为物体运动快于曝光时间</li>
<li>Display tearing: 显示撕裂</li>
<li>Player character： 玩家在游戏中控制的物体</li>
<li>Target object: 被看向的物体</li>
<li>Interpolation: 插值</li>
<li>Projection: 投影</li>
<li>Parallax: 视差</li>
<li>Transitions:
转场，包括过程化转换、插值、瞬时切换、清除、过渡等等</li>
<li>Camera constraints: 相机约束</li>
<li>Motion constraints:
运动约束，如距离、相对位置、路径、速度、加速度等等</li>
<li>Orientation constraints: 通常用于第一人称相机</li>
</ul>
<h3 id="camera-presentation-styles">Camera Presentation Styles</h3>
<p>Presentation style
通常被划分为正交（2D）或者透视（3D）渲染，有时也会使用2.5D</p>
<h3 id="camera-behaviors">Camera Behaviors</h3>
<p>主要有三种相机行为：</p>
<ul>
<li>Cinematic cameras:
非交互的、玩家不可控的相机，包括cutscene和real-time cinematic
sequences</li>
<li>First person cameras:
视野比TP游戏小，使玩家难以全面捕捉空间与环境信息，跳跃也更加困难。在实现FP相机时，建议把相机与任务的头部分开，同时使相机的朝向独立于玩家的朝向</li>
<li>Third person cameras:
允许更大的视野，适用于环境导向型游戏，但存在world navigation与collision
avoidance两个问题</li>
</ul>
<p>此外，相机也可以分为predictive和reactive两类： - Reactive:
根据游戏对象的变化而变化 - Predictive:
根据当前游戏物体预测最佳的相机位置和朝向</p>
<p>Path finding solutions: -
全局路径搜索：搜索环境中的一条路径，能够保持美学质量 -
局部路径搜索：以某种具体的物体类型为核心进行搜索 -
基于目标的搜索：在各种约束下搜索路径</p>
<h3 id="view-generation">View Generation</h3>
<p>视图生成步骤：</p>
<ul>
<li>游戏中每个活跃的物体更新内部状态</li>
<li>相机更新位置、朝向等信息</li>
<li>对游戏中待生成的每个view:
<ul>
<li>决定相机的位置和朝向</li>
<li>决定显示设备上的viewport</li>
<li>决定游戏世界中的frustum</li>
<li>给定frustum，决定哪些物体被剔除</li>
<li>对每个待渲染的物体：
<ul>
<li>变换物体</li>
<li>应用光照着色</li>
<li>2D投影</li>
<li>光栅化</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img data-src="/images/realtime_cameras/2-1.png" alt="简化的渲染流程。" />
<figcaption aria-hidden="true">简化的渲染流程。</figcaption>
</figure>
<p>在上述步骤中，与相机系统直接相关的有：view frustum, view
transform和projection transform</p>
<h3 id="player-controls">Player Controls</h3>
<p>A control reference frame refers to a relationship between changes to
the controller input and how it affects movement or other aspects of
player control.</p>
<p>在FP游戏中，control reference
frame直接对应了玩家角色面朝的方向，且通常只能绕up
axis旋转。在TP游戏中，control reference
frame基于相机与玩家的相对位置。</p>
<p>Control reference frame需要始终反应<strong>玩家的意图</strong>！</p>
<h2 id="chapter-3-cinematography">Chapter 3: Cinematography</h2>
<h3 id="nomenclature">Nomenclature</h3>
<p>电影学中的一些专有名词：</p>
<ul>
<li>Dolly: 指平行于地面的移动，dollying in是向前推进，dollying
out是向后推进，crab left是向左移动，crab right是向右移动</li>
<li>Pan/Yaw: 绕着camera up轴的旋转</li>
<li>Tilt/Pitch: 绕着camera right轴的旋转</li>
<li>Tracking: 跟着物体移动</li>
<li>Depth of field: 景深</li>
<li>Color fade: 颜色渐变</li>
<li>Lens flare: 镜头眩光</li>
<li>Cut-away shot: 切换到另一个镜头用于强调原场景中的某个元素</li>
<li>Insert shot: 切换到场景中的细节部分，比如人物特写</li>
<li>Jump cut: 瞬间切换</li>
<li>180 degree rule/line of action: 二人镜头应该让相机保持在同一侧</li>
<li>Point of view shot: 第一视角镜头</li>
<li>Crane shot: 第三人称视角</li>
<li>Reaction shot: 拍摄人物反应的镜头</li>
<li>Reverse shot: 与前一个镜头角度相反，但仍遵循180度法则</li>
<li>30 degree rule: 当使用jump
cut时，新镜头与上个镜头的角度差应该大于30度，否则会让观众认为是场景的物体发生了移动而非相机</li>
<li>Forced perspective:
强制透视指一系列技术让观众产生错误的视觉效果，如大小、位置关系</li>
</ul>
<h3 id="dynamically-generated-moviesreplay-cameras">Dynamically
Generated Movies/Replay Cameras</h3>
<p>为了实现回放，可以记录初始游戏状态和玩家操作，然后模拟行为。一些回放系统还支持观测者视角。</p>
<p>有三种形式的回放相机：reproduction, scripted, dynamically
generated:</p>
<ul>
<li>Reproduction cameras/keyframed cameras:
在固定的时间间隔记录位置和朝向信息，实现简单但可能依赖于其他非keyframed游戏事件</li>
<li>Scripted cameras:
是可交互与预定义的结合。Replay相机的位置可以采用下述的形式：
<ul>
<li>Discrete camera behaviors: 此类相机perform jump
cuts或者预定义相机位置之间的插值</li>
<li>Path-based motion: 使用设计师预定义的相机路径</li>
<li>Slaved motion: 根据特定物体设置相机位置
类似地，相机的朝向（甚至FOV）可以采用如下的形式：</li>
<li>Fixed orientations: 固定朝向</li>
<li>Pre-defined orientations: 预定义朝向</li>
<li>Object tracking: 跟踪游戏物体调整朝向</li>
<li>Object framing:
保证游戏物体保持与显示设备一致的相对距离，此时物体的显示大小可以通过改变FOV调整</li>
</ul></li>
<li>Dynamically generated cameras:
在回放的时候动态生成相机，如死亡视角、高亮操作等等
<ul>
<li>死亡视角相机：可以通过一个围绕角色的stationary相机实现，或者使用一些预定义的相机位置/朝向</li>
<li>重生相机：当玩家进入/重进游戏时播放的相机</li>
</ul></li>
</ul>
<p>一些常用的相机特效：</p>
<ul>
<li>Reorientation changes:
引入朝向误差，模拟人类持相机的行为，但要注意摇晃的幅度</li>
<li>Camera shake:
相机抖动通常在渲染过程中实现而非游戏世界中，因为这不会改变相机的实际位置，注意在第三人称游戏中应当控制相机抖动的幅度和频率</li>
<li>Roll: 用于营造失控的感觉，比如用在赛车游戏中</li>
<li>FOV/DOF: 注意DOF不要频繁使用</li>
</ul>
<h3 id="scripting">Scripting</h3>
<p>Scripting通常指设计师手动指定相机的位置和朝向，要么在编辑器中进行编辑，要么使用Maya等工具编辑后直接导入</p>
<p>一个典型的scripting system应当包括：</p>
<ul>
<li>调整相机位置和朝向</li>
<li>转场</li>
<li>相机插值</li>
<li>FOV变化</li>
</ul>
<p>Scripting system最好还支持编辑时预览，尽管非常困难</p>
<h3 id="editing">Editing</h3>
<p>编辑就是把所有的shot重新组织、拼接的过程，主要包含以下内容：</p>
<ul>
<li>Shot selection: 镜头选择</li>
<li>Framing/composition:
电影业通常对镜头的摆放有非常具体的标准以达到特定的情感效果，即使镜头离物体的距离固定，物体在屏幕中的位置也会极大影响呈现的效果，通常遵循三分法则（rule
of thirds）</li>
<li>Transitions: 有几种常见的转场方式：
<ul>
<li>Jump cut: 遵循30度法则</li>
<li>Cross fade or dissolve: 此类转场可以降低渲染性能要求</li>
<li>Iris transition: 以屏幕一点为圆心向四周展开</li>
<li>Wipe(s): 擦拭转场</li>
<li>Viewport transitions: 视口转场</li>
</ul></li>
</ul>
<figure>
<img data-src="/images/realtime_cameras/3-1.png"
alt="Rule of thirds示意。" />
<figcaption aria-hidden="true">Rule of thirds示意。</figcaption>
</figure>
<h3 id="tools">Tools</h3>
<p>如果电影镜头使用游戏引擎进行渲染，即用常规游戏环境制作镜头，则最好让编辑器支持直接控制cinematic
sequences，包括：</p>
<ul>
<li>直接对相机位置和朝向的控制</li>
<li>通过另一个物体控制相机</li>
<li>控制相机之间变化</li>
<li>通过相机触发游戏事件</li>
<li>镜头的转场</li>
<li>控制FOV</li>
<li>即时预览</li>
<li>额外的编辑和debug工具</li>
</ul>
<p>上述属性都可以通过一条曲线完成（类似Unity），横坐标是elapsed
time，纵坐标是具体值</p>
<h1 id="part-2-design-principles">Part 2: Design Principles</h1>
<h2 id="chapter-4-camera-design">Chapter 4: Camera Design</h2>
<h3 id="interactive-2d-camera-systems">Interactive 2D Camera
Systems</h3>
<p>2D游戏通常使用tile
map，每个tile都是一个小图片，且使用hash存储，因此极大节省内存</p>
<p>2D相机的主要功能之一是让角色一直位于屏幕可视范围，比如可以使用scrolling，即让背景做相对运动。下面是一些常见的scrolling类型：</p>
<ul>
<li>Continuous: 背景的scrolling随着游戏连续进行</li>
<li>Character-relative: 相机的运动与角色的运动同步</li>
<li>Directional lag: 期望的相机位置基于角色运动的方向</li>
<li>Burst: 期望的相机位置只有当角色到达某个位置或距离时才变化</li>
<li>Screen-relative: 只有在角色超出预定义的边界时相机才开始移动</li>
<li>Region-based: 当角色超过相对于世界的边界时相机才开始移动</li>
</ul>
<p>有时候相机的位置要独立于角色位置。对共用一个viewport的多人游戏来说，所有角色的位置共同决定了相机的位置。解决方案：</p>
<ul>
<li>允许相机zoom out</li>
<li>限制玩家移动</li>
<li>分屏</li>
<li>允许玩家在屏幕外移动</li>
<li>传送玩家</li>
</ul>
<h3 id="cinematic-2d-camera-systems">Cinematic 2D Camera Systems</h3>
<p>2D cinamatic camera system的一些典型特征包括：</p>
<ul>
<li>Viewport panning control: 控制运动路径</li>
<li>Zoom in/out: 放大缩小</li>
<li>Object tracking: 目标跟踪</li>
<li>Keep an object within screen bounds or other arbitrary
viewport-based constraint: 带有限制的移动</li>
</ul>
<h3 id="interactive-3d-camera-systems">Interactive 3D Camera
Systems</h3>
<p>交互式3D相机系统的难点在于提供一个上下文合适的视角，包括艺术性与游戏性，特征包括：</p>
<ul>
<li>渲染投影类型（透视、正交）</li>
<li>决定相机期望位置（navigation）</li>
<li>相机移动的方式</li>
<li>决定相机期望朝向</li>
<li>相机旋转的方式</li>
<li>相机其他属性的动态改变（FOV, etc）</li>
<li>相机插值</li>
<li>Fail-safe handling</li>
<li>多视口/分屏</li>
</ul>
<h3 id="cinematic-3d-camera-systems">Cinematic 3D Camera Systems</h3>
<p>当设计3D cinematic camera system的时候有几个有用的建议：</p>
<ul>
<li>Duplicate controls and functionality from modeling packages:
复用现有建模包中的功能，让艺术家能够用得舒服、更有效率</li>
<li>Develop a common terminology: 尽可能用标准的专业术语</li>
<li>Consider pre-rendering cinematic sequences:
用游戏引擎渲染sequence</li>
<li>Distinguish non-interactive sequences from regular game play:
要让玩家意识到在播放cinematic
sequences时不能再操纵角色了，比如调整aspect ratio</li>
<li>Allow an early out after viewing scene once:
让观众有机会跳过cinematic sequence</li>
</ul>
<h3 id="d-camera-systems">2.5D Camera Systems</h3>
<p>2.5D相机系统有自身的优势，比如让游戏玩家更容易理解和接受游戏</p>
<h3 id="display-devices">Display Devices</h3>
<p>让游戏分辨率适应显示分辨率的方法：</p>
<ul>
<li>Resize: 通过render buffer和viewport匹配显示设备的分辨率</li>
<li>Pan and scan: 裁剪</li>
<li>Stretch: 伸缩</li>
</ul>
<h3 id="camera-design-process">Camera Design process</h3>
<p>首先，游戏的整体体验/玩法需要制定下来，然后再制定相机的宏观设计框架。相机设计的总体流程是：</p>
<ul>
<li>Examine high-level design goals:
明确在游戏的不同部分相机有何相同之处，是否需要单个representation
style，玩家有怎样的体验</li>
<li>Evaluate player character abilities:
玩家怎么移动、怎么与环境交互</li>
<li>Determine scope of environments:
游戏场景是怎样的，要提前根据场景做camera prototyping</li>
<li>Define base camera behaviors: 尽快确定相机的基础功能</li>
<li>Determine area-specific requirements: 明确特殊区域</li>
<li>Technical evaluation of cameras:
关注处理器开销、内存开销、脚本能力、Debug能力</li>
</ul>
<p>在相机设计的时候可以问一些问题，这有助于我们更好地设计：</p>
<ul>
<li>Player abilities and controls
<ul>
<li>角色怎么移动的？加速度是什么？是否能跳/飞？</li>
<li>角色的移动能力是否最终确定了？</li>
<li>相机与玩家的关系是怎样的？</li>
<li>是否应该保持与玩家朝向相对固定的朝向？</li>
<li>玩家想要看到什么？</li>
<li>相机应该关注角色还是角色前的某个点？</li>
<li>是否有必须可视的部分？</li>
<li>除了角色之外是否还有其他物体必须可视？</li>
<li>相机的朝向是否需要改变？</li>
<li>玩家角色怎样被控制？</li>
</ul></li>
<li>Environmental concerns: 场景设计应该围绕玩法和相机限制
<ul>
<li>角色在怎样的场景中移动？开放还是封闭，宽敞还是狭窄？</li>
<li>场景是否影响相机的位置和朝向？</li>
<li>相机是否应该被放在场景外？如是，如果在常规玩法中切换？</li>
<li>相机是否会在动态变化的场景中跟随玩家？受到阻挡怎么办？</li>
<li>相机是否应当避免复杂物体？</li>
<li>相机是否应当限制在具体的路径或表面？</li>
<li>哪种presentation style更好？</li>
<li>在场景中相机插值是否还生效？</li>
<li>是否有必要给相机加上特定的碰撞体？</li>
</ul></li>
<li>Technical concerns
<ul>
<li>是否有技术限制？包括渲染性能问题等</li>
<li>如果相机会穿透物体，是否支持透明化？</li>
<li>是否需要fail-safes以处理未预料的意外情况，比如关门？</li>
<li>是否允许操纵相机？</li>
<li>场景是否可能遮挡玩家而无法解决？此时场景是否需要进行改变？</li>
<li>是否支持相机插值？如何避免插值间的遮挡？</li>
</ul></li>
</ul>
<p>对于相机的要求、限制应该在项目早期就明确，除非是个别例外，并且要避免在项目开展后大改相机系统。因此，要在项目商讨环节把需求都明确清楚</p>
<p>团队中的camera
designer不仅需要负责相机表现，而且也需要负责大部分情况下的相机解决方案。Lead
camera
designer需要具备美学sense，包括游戏内容的呈现和玩家操作、感知的表现，此外，他还需要推动团队提高认知</p>
<h3 id="camera-design-guidelines">Camera Design Guidelines</h3>
<p>一些相机设计的建议：</p>
<ul>
<li>Attempt to keep the player character in view (3rd person
cameras)</li>
<li>Prevent the camera passing through (or close to) game objects or
physical environmental features</li>
<li>Do not require the player to manipulate the camera simply to play
the game -- unless it is a design requirement</li>
<li>Allow camera manupulation when possible or dictated by game design
requirements</li>
<li>Minimize unintentional camera motion whenever possible</li>
<li>Ensure camera motion is smooth</li>
<li>Limit the reorientation speed of the camera</li>
<li>Limited roll should be allowed in most regular game cameras</li>
<li>Do not allow the camera to pass outside the game world</li>
<li>Retain the camera position with respect to the player when instantly
moving th camera to a new position (3rd person cameras)</li>
<li>Do not focus directly on the player character when it is moving</li>
<li>Retain control reference frame after rapid or instantaneous camera
motion</li>
<li>Avoid enclosed spaces with complex geometry (3rd person
cameras)</li>
</ul>
<h2 id="chapter-5-camera-solutions">Chapter 5: Camera Solutions</h2>
<h3 id="game-genre-camera-solutions">Game Genre Camera Solutions</h3>
<ul>
<li>FPS游戏：目标是提供沉浸式的体验
<ul>
<li>位置：一般与玩家视角同步，但并不是玩家眼睛的位置，因为武器、手臂等必要元素通常不能从眼睛位置可视</li>
<li>朝向：通常与人眼可视方式一样，即free-look，有时候可帮助玩家自动调整垂直方向的朝向</li>
<li>武器或手臂位置：武器与手臂通常可见</li>
<li>与外部观测的不同：多人游戏中其他玩家看到的角色可能不同</li>
<li>与三人称之间的切换：常用jump cut实现切换</li>
<li>Zoom effects</li>
<li>Lack of peripheral vision</li>
<li>Aiming position</li>
<li>Motion sickness</li>
<li>Camera shaking</li>
<li>Cmaera bob: 角色运动时相机的轻微移动</li>
<li>Idle wandering</li>
<li>Scale: 人物在高速移动时往往会scale
尽管相机和人物之间保持相对距离，但是相机也对影响人物移动的因素相当敏感，比如在复杂的地形上，角色可能被垂直提高一段距离，这通常不到一秒钟的时间，但是仍然会对相机产生影响，导致glitch现象，这可以通过增加垂直方向的damping解决，这只有在角色穿越崎岖地表时才生效。注意一人称的damping值要比三人称小</li>
</ul></li>
<li>Character/action
adventure游戏：可以根据角色的技能决定相机的行为，比如大致分为两类：地面与飞行</li>
<li>Stealth: 相机会随着使用物品或武器而变化</li>
<li>3D platform: 主要分为两种形式：free form与pre-determined
<ul>
<li>free-form: 相机的位置与距离可以由玩家操控</li>
<li>pre-determined: 严重依赖于特定的Game
play，同时也要兼顾相机的效果</li>
</ul></li>
<li>RPG: 常用三人称相机</li>
<li>Scrolling</li>
<li>Sports: TV-style presentation may be very desired
<ul>
<li>Single-participants sports: 相机只需要focus on玩家或者单个物体</li>
<li>Two or four-participant sports: 联机or分屏</li>
<li>Team sports: 预留一个control
command标识当前正在控制哪个角色以及哪些角色可以被控制</li>
<li>Court and indoor sports:
对球类运动而言，难点在于追踪及可视球；对桌类运动而言，要提供整个桌面的视野并简化玩家操作</li>
<li>Outdoor sports:
对于场地运动，可以提供能够自主操作的相机；自由运动；轨道运动</li>
<li>Abstract sports</li>
</ul></li>
<li>Racing games:
可提供额外的视角以观测其他人的位置，增大FOV可以制造物体快速通过玩家的感觉</li>
<li>Ground vehicles</li>
<li>RTS</li>
<li>Flight simulation: 一个重要的方面是是否允许相机随着飞机一起roll
<ul>
<li>Realistic flight models: 此类游戏通常从驾驶舱或飞机后侧观察</li>
<li>Non-realistic flight models</li>
<li>Artificial horizon: 可以用仪器监控飞机的pitch或banking</li>
<li>Sensation of motion:
可以用云层或航迹云增强飞机的速度感；航天器可以用小的残骸增强速度感；也可以通过音效、FOV等方式</li>
</ul></li>
<li>Adventure: present a very cinematic experience to the player</li>
<li>Puzzle/party games/board games</li>
<li>Fighting/close combat:
场景一般很简单以便于相机摆放，需要一些相机移动突出角色的操作</li>
</ul>
<h3 id="multi-player-camera-solutions">Multi-Player Camera
Solutions</h3>
<p>多人共享屏幕时，相机设计会有很大难度，有时候可以通过alternate
players解决，但多数情况下并不适用。一般来说可以有两种解决方法：</p>
<ul>
<li>分屏</li>
<li>单屏包含所有玩家</li>
</ul>
<p>下面是对相关技术的介绍：</p>
<ul>
<li>Single-screen techniques: 格斗游戏、合作游戏中常见
<ul>
<li>相机的位置很难确定</li>
<li>通常相机位置固定在一个离游戏世界表面相对的高度，而与玩家移动无关</li>
<li>相机位置可能导致朝向的迅速变化</li>
</ul></li>
<li>Split-screen techniques
<ul>
<li>每个玩家的分屏区域一样大</li>
<li>根据活跃玩家动态分屏</li>
<li>为了提升性能，尽量让所有玩家都处于同一个环境中</li>
<li>尽量减少玩家获取的信息</li>
<li>避免把重要的物体放在设备屏幕边缘</li>
</ul></li>
<li>Transitioning from full-screen to split-screen
<ul>
<li>保持相机相对距离相同</li>
<li>UI元素要重新排布</li>
<li>FOV要根据aspect ratio重新调整</li>
</ul></li>
<li>Transitioning from split-screen to full-screen
<ul>
<li>玩家移动地足够近的时候</li>
<li>UI元素要等transition完成时再移动</li>
<li>相机相对位置保持不变</li>
<li>FOV调整</li>
</ul></li>
</ul>
<h2 id="gamera-scripting">Gamera Scripting</h2>
<h3 id="what-is-meant-by-scripting">What is Meant by Scripting</h3>
<p>定义与控制物体加偶和的过程被称为scripting，在游戏中，指控制游戏事件发生的事件与物体之间的交互。Scripting允许设计师在没有程序员介入的情况下完成迭代</p>
<h3 id="types-of-scripting">Types of Scripting</h3>
<p>我们希望构建一个与游戏类型无关的scripting系统，主要由两个方面组成：scripting
language和event messaging</p>
<h4 id="scripting-languages">Scripting languages</h4>
<ul>
<li>Text-based scripting languages:
包括pre-compiled和interpreted两类</li>
<li>General-purpose programming languages: 编程语言</li>
<li>Custom scripting languages</li>
<li>Finite state machines</li>
<li>Visual scripting languages</li>
</ul>
<h4 id="event-messaging">Event messaging</h4>
<p>Event
messaging要求定义不同物体之间的关系。典型的能够发送消息的事件包括：</p>
<ul>
<li>关卡开始</li>
<li>物体加载</li>
<li>游戏暂停</li>
<li>进入或退出volume</li>
<li>玩家受到伤害</li>
<li>物体到达路径终点</li>
<li>玩家状态改变</li>
</ul>
<p>能够被事件发送的典型消息包括：</p>
<ul>
<li>Start</li>
<li>Stop</li>
<li>Activate object</li>
<li>Delete object</li>
<li>Query state</li>
</ul>
<h3 id="script-objects">Script Objects</h3>
<p>用于定义物体的属性和行为</p>
<h3 id="scriptable-game-hints">Scriptable game hints</h3>
<p>Game hints are script objects that provide one possible type of
runtime mechanism by which designers can override player properties,
game controls or camera properties according to events</p>
<ul>
<li>Camera hints: 改变相机的属性或移动，可以被重载的相机属性包括：
<ul>
<li>相机行为</li>
<li>位置朝向</li>
<li>相对距离</li>
<li>看向点</li>
<li>移动速度</li>
<li>FOV</li>
</ul></li>
<li>Player hints
<ul>
<li>Prevent motion of the player</li>
<li>Relocate player position</li>
<li>Change player movement characteristics</li>
<li>Flags to indicate special kinds of game play</li>
</ul></li>
<li>Control hints
<ul>
<li>Disable specific controls or sets of player controls</li>
<li>Specify the control reference time and the time to interpolate to
that new reference time</li>
</ul></li>
</ul>
<p>很多时候事件需要有先后顺序，一个sequenced event
manager可以用来定义事件的先后顺序。</p>
<h3 id="camera-scripting">Camera Scripting</h3>
<h4 id="camera-scripting-methods">Camera scripting methods</h4>
<ul>
<li>Pre-defined camera scripting</li>
<li>Dynamic camera scripting: 只调整需要的相机属性</li>
</ul>
<h4 id="dcamera-control">DCamera control</h4>
<ul>
<li>Third person scripting: 用专门的script objects去调整FOV、Focal
Length，filter or rendering effects, fog distance等</li>
<li>First person scripting: 有一些情况也需要对FP相机进行动态控制，比如
<ul>
<li>Traversing up or down ramps or other significantly sloped surfaces:
在上下坡的时候线相机要和坡度一致 <img
src="/images/realtime_cameras/6-6.png"
alt="根据玩家位置自动pitch。" /></li>
<li>Jumping: 在高距离跳跃时，能够对准落脚点的方向，但幅度不宜过大 <img
src="/images/realtime_cameras/6-7.png"
alt="玩家跳跃时自动pitch。" /></li>
<li>View locking: 锁定目标时相机要朝向目标点 <img
src="/images/realtime_cameras/6-8.png" alt="玩家锁定目标。" /></li>
</ul></li>
<li>Non-interactive movie scripting:
最常用的就是位置和朝向的scripting</li>
</ul>
<p>一些经验法则：</p>
<ul>
<li>Apply Occam's Razor: 使用最简单scripting方案，这便于随时修改</li>
<li>Allow for different ways that the camera event may be triggered:
比如有时候只用trigger volume可能不够</li>
<li>Allow previewing of camera motion and orientation: 支持预览</li>
<li>Assess camera scripting requirements early in the design
process</li>
<li>Make the scripting development cycle as efficient as possible:
提高预览和扩展能力</li>
<li>Mimic the behaviors of the tools used by artists where possible:
降低艺术家（设计师）的学习成本</li>
<li>Allow for game play changes: camera scripting system:
游戏玩法改变时能够轻松地修改camera</li>
</ul>
<h3 id="scripting-tools">Scripting Tools</h3>
<h4 id="world-editor-support">World editor support</h4>
<p>必须支持script objects的放置与操作，而且还要支持message passing,
state transition, event trigger和其他物体间的关系</p>
<h4
id="communication-between-target-platform-and-development-pc">Communication
between target platform and development PC</h4>
<p>要获得运行物体的状态</p>
<h4 id="messagingevent-logging">Messaging/event logging</h4>
<p>对消息和事件进行记录</p>
<h4 id="object-properties-debugging">Object properties debugging</h4>
<p>当游戏运行时要动态检查物体的属性</p>
<h4 id="replay">Replay</h4>
<p>最简单的方法是内置video recording</p>
<h4 id="console-window">Console window</h4>
<p>支持打印文本消息，通过GM指令查看想要的文本消息</p>
<h3 id="scripting-debugging">Scripting Debugging</h3>
<p>常见的debugging方法：</p>
<ul>
<li>Script statement execution/filter:
对任意给定的script，展示每个状态执行的历史记录</li>
<li>Debug message logging: 单独展示日志</li>
<li>Message filtering: 增加过滤功能以更好地debug</li>
<li>Object state: 展示物体的状态</li>
<li>FSM state changes: 展示当前的state和历史state</li>
<li>Animation state and event management:
记录当前的动画状态和插值状态，记录事件</li>
</ul>
<h1 id="part-3-camera-engineering">Part 3: Camera Engineering</h1>
<h2 id="chapter-7-position-and-orientation">Chapter 7: Position and
Orientation</h2>
<h3 id="coordinate-schemes">Coordinate Schemes</h3>
<p>有几种不同的坐标空间：</p>
<ul>
<li>World Space: 从世界空间到相机空间再到屏幕空间</li>
<li>Camera Space: 以相机为原点</li>
<li>Screen Space: Camera Space通过正交变换而来</li>
<li>Local Space: 以角色为原点</li>
<li>Object Relative: 相机为原点，三个轴根据某个物体到相机的位置而定</li>
</ul>
<h3 id="desired-position">Desired Position</h3>
<p>在相机移动的过程中需要关注与目标点的距离</p>
<h4 id="first-person-camera-positioning">First person camera
positioning</h4>
<p>大多数情况下，相机的desired
position就是角色眼睛的位置，此时增加一点dvertical
amping会有用。在玩家遇到崎岖地形或与物体碰撞时，需要smooth
out轻微的相机运动</p>
<h4 id="third-person-camera-positioning">Third person camera
positioning</h4>
<p>有三种策略决定相机位置：</p>
<ul>
<li>Automated: 相机完全自动化</li>
<li>Player control: 交由玩家操作相机，但要让环境始终保持在视野中</li>
<li>Hybrid: 交给玩家部分自主权</li>
</ul>
<h3 id="desired-position-determination-methods">Desired Position
Determination Methods</h3>
<p>相机位置应该独立于朝向，尽管后者常常依赖于前者。下面是一些决定desired
position的方法</p>
<h4 id="stationary">Stationary</h4>
<p>主要有两种stationary cameras: fixed position 和 dynamic fixed
position:</p>
<ul>
<li>Fixed position:
相机位置固定但可以自由调整朝向，通常限制了朝向的范围。但此类相机会使目标离相机太远或者丢失视野</li>
<li>Dynamic fixed position: 通常由其他活跃的相机决定，中间由jump
cut或interpolation决定</li>
</ul>
<h4 id="slavedtracking">Slaved/tracking</h4>
<p>相机的offset可以采取以下的几种形式：</p>
<ul>
<li>World-relative offset: 在世界坐标内保持相对距离 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>World-relative angular offset: 在世界坐标中通过角度定义相对距离
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="title">offset</span>(<span class="params"><span class="number">0.0f</span>, cosf(pitch</span>) * distance, <span class="title">sinf</span>(<span class="params">pitch</span>) * distance)</span>;</span><br><span class="line"><span class="comment">// construct a rotation matrix around the world up-axis</span></span><br><span class="line">Mat3 rotation = Mat3::ZRotation(yaw);</span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>World object relative:
根据主物体和另一个物体之间的距离决定相机位置，这种方法可以帮助处理人物在相机和另一物体中间的情况
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Mat3 rotation = Mat3::LookAt(GetTargetObject()-&gt;GetPosition().DropZ(), mWorldPosition.DropZ());</span><br><span class="line"><span class="comment">// note that the reference frame is often 2D, but is not required to be</span></span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>Local offset: 与world relative
offset类似，只不过offset被转换到了局部空间 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Mat3 rotation = mScriptObject-&gt;GetMatrix(); <span class="comment">// based on the orientation of the script object</span></span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>Local angualar offset: 类似world-relative angular
offset，不过offset被转换到了局部空间 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="title">offset</span>(<span class="params"><span class="number">0.0f</span>, cosf(pitch</span>) * distance, <span class="title">sinf</span>(<span class="params">pitch</span>) * distance)</span>;</span><br><span class="line">Mat3 rotation = mScriptObject-&gt;GetMatrix();</span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
<li>Character-relative offset:
在局部坐标内根据角色的朝向决定相机的位置，在三人称相机中最为常用，被称为“追背相机
(chase camera)”, 一般不会变化Roll</li>
<li>Character-relative angular offset:
在局部坐标内根据角色朝向和三个旋转角度、距离决定相机位置，通常会限制相机旋转速度的变化率</li>
<li>Object-relative offset:
不考虑目前物体的朝向，而仅考虑elevation和distance，the vector from the
target object toward the current camera position defines the coordinate
space used to calculate the desired position，相机的朝向通常由玩家操纵
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Mat3 rotation = Mat3::LookAt(GetPosition().DropZ(), GetTargetObject()-&gt;GetPosition().DropZ(), mWorldPosition);</span><br><span class="line"><span class="comment">// only elevation (here pitch) and distance are required</span></span><br><span class="line"><span class="function">Vec3 <span class="title">offset</span>(<span class="params"><span class="number">0.0f</span>, cosf(pitch</span>) * distance, <span class="title">sinf</span>(<span class="params">pitch</span>) * distance)</span>;</span><br><span class="line">mOffset = rotation * offset;</span><br><span class="line">Vec3 desiredPosition = GetTargetObject()-&gt;GetPosition() + mOffset;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="path">Path</h4>
<p>有几种不同类型的路径：</p>
<ul>
<li>Linear: 直线路径</li>
<li>Circular/elliptical/spiral: 环状路径 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">X = a * cos(theta);</span><br><span class="line">Y = b * sin(theta);</span><br></pre></td></tr></table></figure></li>
<li>Spline: 通常一系列control points定义</li>
</ul>
<p>下面是决定路径位置的方法：</p>
<ul>
<li>Non-interactive situations: 在movie
sequences中通常由一个时间到位置的映射决定</li>
<li>The position of the player character relative to another object</li>
<li>Player position relative to a defined path</li>
<li>A specified distance away from the closest position on the path to
the player: 改方法需要注意相机移动的平滑性</li>
</ul>
<p><strong>Splines.</strong> 可以用brute
force的方法去计算spline的长度，代码如下 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">length</span>(<span class="params"><span class="number">0.0f</span></span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; controlPoints.Size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  Vec3 pathPosition = EvaluateSegment(i, <span class="number">0.0f</span>);</span><br><span class="line">  <span class="comment">// start of i&#x27;th segment</span></span><br><span class="line">  controlPoints[i].mLength = length;</span><br><span class="line">  <span class="comment">// save length at the control point</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; i &lt; kMaxSegmentSlices; ++j)</span><br><span class="line">  <span class="comment">// includes next control point</span></span><br><span class="line">  &#123;</span><br><span class="line">    Vec3 newPosition = EvaluateSegment(i, j/kMaxSegmentSlices);</span><br><span class="line">    Vec3 delta = newPosition - pathPosition;</span><br><span class="line">    length += delta.Magnitude();</span><br><span class="line">    <span class="comment">// add the &quot;length&quot; of this slice</span></span><br><span class="line">    pathPosition = newPosition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   <span class="comment">// length now holds the approximate total length</span></span><br></pre></td></tr></table></figure></p>
<p>一种更快且准确的方法是用多项式逼近</p>
<p><strong>Mapping functions.</strong>
最简单的是从时间到长度的线性映射，此时相机的速度不变，导致abrupt开始或结束。一种常见的方法是使用一个二维spline曲线（Hermite
curves)，用户可以定义控制点和切线控制曲线的形状</p>
<h4 id="surface-constrained">Surface constrained</h4>
<p>在一些情况下，相机可能限制在一个隐式的平面上，比如一个flat平面，一个椭球、圆柱等等，该平面的大小和朝向可能是动态的</p>
<p>下面是一些常见的surface类型：</p>
<ul>
<li>Sphere: 容易受gimbal lock影响</li>
<li>Plane</li>
<li>Cylinder</li>
<li>Cone</li>
<li>Extruded spline plane</li>
<li>Spline cylinder</li>
</ul>
<h4 id="volume-constrained">Volume constrained</h4>
<p>相机与圆柱体的碰撞检测：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vec3 direction = currentPosition - cylinder.GetPosition();</span><br><span class="line">direction.SetZ(<span class="number">0.0f</span>);</span><br><span class="line"><span class="built_in">float</span> radius = direction.Magnitude();</span><br><span class="line"><span class="keyword">if</span> (radius &gt; kMaxRadius)</span><br><span class="line">  radius = kMaxRadius;</span><br><span class="line">direction = direction.AsNormalized() * radius;</span><br><span class="line">Vec3 newPosition = cylinder.GetPosition() + direction;</span><br><span class="line">newPosition.SetZ(currentPosition.GetZ());</span><br></pre></td></tr></table></figure>
<h4 id="framing">Framing</h4>
<p>该方法在屏幕空间上保持目标角色的位置，这可以通过移动相机、修改FOV、伸缩viewport等方法实现</p>
<h4 id="object-framing-relative">Object-framing relative</h4>
<p>该方法不仅考虑物体在屏幕空间中的小，而且也考虑它和另一个物体之间的相对距离，一些因素包括：</p>
<ul>
<li>Object screen size</li>
<li>Multiple objects must be kept on screen</li>
<li>Distance between objects</li>
<li>Relative position to other objects</li>
<li>Relative position to the screen (not rendered size)</li>
<li>Orientation with respect to the camera</li>
<li>Distance aiming/ranged weapons</li>
</ul>
<h4 id="axis-rotationalspindle">Axis rotational/spindle</h4>
<p>相机围绕游戏世界中的一个轴旋转、平移，适用于玩家需要围着一个物体导航的情况，或限制在一个圆柱物体的情况</p>
<p>一些影响相机位置的因素：</p>
<ul>
<li>Angular offset relative to the reference vector or the axis
origin</li>
<li>Axial offset relative to the current player positionn or the axis
origin</li>
<li>Radial offset relative to the spindle axis or current player
radius</li>
</ul>
<p>此外，我们也可以改变相机的朝向：</p>
<ul>
<li>Look at the spindle axis along a projected vector from the current
camera position</li>
<li>Look away from the spindle along a projected vector that passes
through the camera position as above</li>
<li>Apply an angular offset either toward or away from the spindle
relative to the target object</li>
</ul>
<p>玩家位置相对于spindle axis的半径可以作为mapping
function的输入，当玩家移动半径更小时，相机移动得更高</p>
<h3 id="common-position-problems">Common Position Problems</h3>
<ul>
<li>期望位置和一个物体碰撞，或者太近以至于物体穿透相机的近平面</li>
<li>期望位置离环境中的边界物体太近以至于有环境外的视野</li>
<li>期望位置离目标对象太远，玩家没有好的视野</li>
<li>环境复杂相机不能提供好的视野</li>
</ul>
<h3 id="orientation">Orientation</h3>
<p>旋转有四种表示方法：欧拉角、变换矩阵、轴角和四元数</p>
<h3 id="desired-orientation-determination-methods">Desired Orientation
Determination Methods</h3>
<h4 id="constant-orientation">Constant orientation</h4>
<p>朝向不变，但是位置可以移动。可以变式为constant elevation
cameras，即只有pitch可以改变</p>
<p>这种相机可以用在：</p>
<ul>
<li>Player controlled remote cameras</li>
<li>Dynamic positioning of replay cameras</li>
<li>Dynamic positioning of caemras for non-interactive game play
sequences</li>
</ul>
<h4 id="tracking-a-target-object-or-position">Tracking a target object
or position</h4>
<p>相机达到期望朝向的方法取决于目标物体的移动和相机的重朝向速度，此类相机一般保持固定的pitch</p>
<h4 id="look-at-offset">Look-at offset</h4>
<p>许多三人称游戏使用一个固定的look-at offset</p>
<h4 id="locked-look-at-position">Locked look-at position</h4>
<p>玩家的朝向也会随便改变</p>
<h4 id="target-object-position-prediction">Target object position
prediction</h4>
<h4 id="object-framing">Object framing</h4>
<p>一个很好的例子是格斗游戏，双方玩家都希望自己和对方都能呈现在屏幕上，当玩家距离增加的时候，相机要么拉远，要么增大FOV，但是频繁切换FOV通常不可取</p>
<p>回放相机通常会从不同的视角呈现玩家行为</p>
<h4 id="idle-wandering">Idle wandering</h4>
<p>A semi-random camera reorientation while the player character is
idle</p>
<h4 id="automated-orientation-control">Automated orientation
control</h4>
<p>在没有玩家操作的情况下自动帮助相机转向：</p>
<ul>
<li>Automated control over camera pitch when the player is jumping:
从玩家起跳时开始相机可以向下看</li>
<li>Automated pitch control when traversing environmental features: This
is applied to present a view facing up or down a ramp, staircase or
other incline as appropriate so that players have a better view of what
they are moving toward,
在有洞穴或悬崖的地方，相机应该自动看向以给予提示</li>
<li>Automated pitch control during combat or interactions:
自动调整pitch以提示可交互的物体</li>
<li>Automated reorientation of the player or a camera toward a target
position: 锁定到目标物体</li>
<li>Repositioning and reorientation of the camera to face the same
direction as the player character</li>
<li>Transitions from first to third person cameras:
要保证当相机移动地充分远的时候才渲染物体，避免穿帮，此时可通过fade角色解决此问题</li>
<li>Transitions from third to first person cameras: 可通过cut
transition实现</li>
</ul>
<h3 id="reorientation-methods">Reorientation Methods</h3>
<h4 id="applying-rotations">Applying rotations</h4>
<p>有几种方法去应用旋转：</p>
<ul>
<li>Constant angular velocity:
匀速变动旋转角，但是开始和结束会有突变</li>
<li>Acceleration and deceleration: 应用加速度与减速度</li>
<li>Angular velocity damping: 用damp使开始结尾更皮规划</li>
<li>Free-look damping: 用bump和其他的ease
functions防止因noise导致的相机朝向变动</li>
<li>Twist reduction</li>
</ul>
<h4 id="reorientation-lag">Reorientation lag</h4>
<p>通常我们希望相机朝向的变化能有一些延迟（lag），同时保持平滑</p>
<p>很多游戏没有任何延迟，这有两个影响：第一，相机直接看向角色会导致玩家不能提前看见角色的移动，第二，相机非常依赖角色的移动，任何小的扰动就会影响相机表现</p>
<p>因此需要使小的移动没有影响，并且使用damp。当插值的时候，可以限制每帧允许的旋转角度。此外，lag还可以通过用springs或feedback
controller实现</p>
<h4 id="offsets">Offsets</h4>
<p>一个常被忽略的点是look-at position和target
object之间的关系。如果直接看向角色，那么就容易丢失玩家想要看的东西。可以用一些视觉提示帮助玩家瞄准目标对象，比如highlight敌人，或者lock-on
to the target object</p>
<h4 id="smoothing-and-damping">Smoothing and damping</h4>
<p>常用的平滑方法是limit the angular velocity of the camera
proportionally to the angle between the current and desired
orientations，这可以表示为一个简单的三角函数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Real32 <span class="keyword">const</span> <span class="title">kDampingAngle</span>(<span class="params"><span class="number">30.0f</span> * gkRadiansPerDegree</span>)</span>;</span><br><span class="line">Real32 angle = acosf(CVector3f::Dot(currentOrientation, desiredOrientation));</span><br><span class="line">Real32 <span class="keyword">const</span> kDampingFactor = Cmath::Limit(angle / kDampingAngle, <span class="number">1.0f</span>); <span class="comment">// linearly proportional</span></span><br><span class="line">Real32 angularLimit = angularSpeed * deltaTime * kDampingFactor;</span><br><span class="line">CQuaternion newOrientation = CQuaternion::LookAt(currentOrientation, desiredOrientation, angularLimit);</span><br></pre></td></tr></table></figure>
<p>始终记住我们有两个矛盾的要求：平滑移动和保持角色合理视角</p>
<h4 id="springs-and-pid-controllers">Springs and PID controllers</h4>
<p>In practice, tuning the characteristics of the controller to achieve
this behavior can be time-consuming but very worthwhile</p>
<h3 id="free-look">Free-Look</h3>
<h4 id="first-person-free-look">First person free-look</h4>
<p>很多一人称游戏采用circle
strafing技术允许玩家free-look，有些游戏也只允许垂直方向的朝向变化，当然也要限制最大角度</p>
<h4 id="third-person-free-look">Third person free-look</h4>
<p>用一个圆锥体围绕look-at点，并使用一个弹簧在没有输入指令的时候令相机能够回到初始位置</p>
<h4 id="free-look-orientation-determination">Free-look orientation
determination</h4>
<p>决定free-look朝向通常有两种方法：self-centering和non-centering</p>
<ul>
<li>Self-centering free-look:
玩家输入会让相机朝向改变，通常把遥感值映射为相机朝向的速度</li>
<li>Non-centering free-look: 在没有玩家输入时相机会保持现在的朝向</li>
</ul>
<h4 id="common-orientation-problems">Common orientation problems</h4>
<p>一些常见的相机朝向的问题：</p>
<ul>
<li>Gimbal lock: 当相机forward与世界up
axis平行时发生，要么不让相机平行于up axis，要么用四元数构造变换矩阵</li>
<li>Vertical twist: 当使用三人称相机时，如果相机朝向接近平行于up
axis则会出现这个问题，表现为相机快速围绕up
axis旋转，常发生于相机在墙角的情况，此时可以限制相机围绕up
axis的旋转速度，或者禁止相机朝向改变直到相机离玩家足够远</li>
<li>Roll: 飞行模拟游戏会经常使用roll</li>
<li>Orientation noise: 使用high-pass filter移除不想要的朝向变化</li>
<li>Rapid orientation changes:
当允许玩家快速移动/改变朝向，或玩家在相机下方或上方移动时，相机的朝向就会快速改变，带给玩家糟糕的体验</li>
<li>Frustum culling of the player character:
三人称游戏必须首先考虑frame玩家，切通常相机直接看向玩家前进的方向，但也要让玩家保持在view
frustum中</li>
</ul>
<h2 id="chapter-8-navigation-and-occulusion">Chapter 8: Navigation and
Occulusion</h2>
<p>Dynamic determination of how the camera should reach its desired
position is referred to here as <strong>navigation</strong></p>
<h3 id="the-cemera-as-an-ai-game-object">The Cemera as an AI Game
Object</h3>
<p>需要假定环境是封闭的，即有碰撞表面</p>
<h3 id="navigation-techniques">Navigation Techniques</h3>
<p>相机的寻路需要考虑环境限制</p>
<h4 id="dynamic-navigation-techniques">Dynamic navigation
techniques</h4>
<p>主要包括以下方法：</p>
<ul>
<li>Ray casting:
用射线决定是否存在遮挡物体，但是可能会有效率问题，此外，可以增加射线覆盖更大区域。另一种方法是使用ray-casting
hysteresis，即在多个update中累积ray
cast信息，并生成一个可能碰撞的概率图，从而减少每次更新的ray
cast数量。Ray
cast可以用于帮助相机移动。要对物体进行分类以区别哪些需要ray casting
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For all ray casts</span><br><span class="line">  if ray cast successful</span><br><span class="line">    No influence applied</span><br><span class="line">  if ray cast fails</span><br><span class="line">    Scale influence factor by distance of ray cast collision from target</span><br><span class="line">    Add influence to desired camera position</span><br><span class="line">End</span><br></pre></td></tr></table></figure></li>
<li>Volume projection:
该方法把一个volume从相机位置投影到目标位置，用来确定相机的移动是否合法</li>
<li>Sphere/cylinder collisions:
碰撞体的半径应该比近平面距离略大，理论上，碰撞体应该完全包含近平面frustum的四个顶点。在第一人称游戏中，可以不用给相机加碰撞体，因为一般有角色碰撞体即可，但是也要保证近平面被角色碰撞体包围</li>
<li>Dynamic path finding: High-level
solution负责volume之间的整体移动，low-level
solution负责避免碰撞。相机AI不同之处在于移动往往很短，因此更要关注low-level的需求</li>
<li>Dynamic path generation: 不同于path finding，path
generation使用的是游戏中动态生成的信息，所以生成的path可能会动态改变</li>
<li>Visibility and rendering solutions:
这种技术首先决定相机据目标物体的位置，基于一些其他限制，得到可能的相机位置点，对于每个可能的位置，令相机朝向角色，就可以看当前视角是否存在遮挡。决定好位置吼，就可以计算一条移动路径，但是也要注意路径中的遮挡和碰撞</li>
<li>Colliders:
在相机周围添加collider，每个collider都会发射射线，如果有遮挡出现，则移动相机位置
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stl::vector&lt;Vec3&gt; influence; </span><br><span class="line"><span class="comment">// might be useful as a class</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; colliders.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  influence.<span class="built_in">push_back</span>(colliders[i].offset * colliders[i].<span class="built_in">GetWeighting</span>());</span><br><span class="line">  <span class="comment">// the weighting depends on line of sight and/or</span></span><br><span class="line">  <span class="comment">// other factors such as the relative collider position</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// will need to get an average or similar</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetCentriod</span>(influence);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="pre-defined-navigation-techniques">Pre-defined navigation
techniques</h4>
<p>一些常见的pre-defined navigation技术：</p>
<ul>
<li>Pre-defined paths: 预先做好路径，根据玩家操作在路径上移动和朝向</li>
<li>Path motion behaviors: 有几种方法去限制相机的移动
<ul>
<li>Constrained path camera: 相机被固定在path上以避免碰撞</li>
<li>Follow path camera: 相机固定在path上，但移动方式可以有多种方式</li>
</ul></li>
<li>Pre-defined volumes</li>
<li>Attractors/repulsors:
相机会被其他pre-defined的位置、区域、物体所吸引/排斥，吸引力/排斥力的大小取决于相机离该物体的距离和朝向。在合适的时候用attractors/repulsors可以帮助相机避免穿模和在狭窄地区顺利通过，而不需要hand-scripted</li>
<li>Flow fields: Flow
fields是向量的稀疏数列，通常稀疏地分布在2D平面或者3D
Volume内。当相机穿过flow
field时，离相机近的向量会对相机朝向的方向施加一个力。Flow
field常用于一个额外的因子而不是单个因素</li>
<li>Influence maps: 类似flow field，但是通过目标对象离influence
map的相对距离决定而非camera本身，influence
map中的每个点都是相机的可选位置</li>
<li>Potential fields: 基于electrostatic
forces，即对一个物体施加的力的效果取决于发力点和目标物体之间的距离，类似attractors/repulsors</li>
</ul>
<h3 id="occulision">Occulision</h3>
<h4 id="occulusion-determination">Occulusion determination</h4>
<ul>
<li>Ray casting: 通常使用三个部分进行遮挡检测——头部、躯体和脚部</li>
<li>Volume casting</li>
<li>Rendering techniques:
<ul>
<li>Flat-shading using identifiers as color values:
待进行遮挡检测的物体使用flat
shading和一个标识颜色，环境物体使用不同的颜色渲染，然后可以通过display
buffer检测物体的遮挡部分</li>
<li>Z-buffer analysis: 直接用depth buffer进行检测</li>
<li>Rendering hardware occulusion queries</li>
</ul></li>
</ul>
<h4 id="occulusion-prediction-methodologies">Occulusion prediction
methodologies</h4>
<p>可以用一个predictive相机预测遮挡</p>
<h3 id="line-of-sight">Line of Sight</h3>
<h4 id="resolving-line-of-sight-problems">Resolving line of sight
problems</h4>
<p>可能有时候相机不能快速移动保持对目标物体的LOS，下面是一些可能的解决方案：</p>
<ul>
<li>Prevention: 手动调整相机位置让它避免出现loss of LOS</li>
<li>Graphical changes:
可以把遮挡物体透明掉或去掉，也可以着重突出角色（如描边、改变颜色、增加indicator）</li>
<li>Finding a desirable position:
可以以角色为中心旋转，或者使用visibility
octree信息，一旦一个位置被发现，则直接把相机relocate到该位置</li>
<li>Teleportation/jump cut:
可以把相机沿着LOS的方向移动，直到没有遮挡（注意要考虑相机的近平面位置与collision
volume）</li>
<li>Retaining control orientation: 相机移动后注意保持相同的retaining
control orientation</li>
</ul>
<h4 id="path-generation">Path generation</h4>
<p>该方法生成一条路径，相机沿着路径移动直到遮挡消失，生成的路径不仅要避免碰撞，并且也要符合美学要求：</p>
<ul>
<li>Follow character movement:
记录玩家移动的路径并让相机沿着路径移动</li>
<li>Ledge avoidance:
玩家从悬崖边缘下落时相机可能因为无法穿透物体而出现问题，解决方案可能有：
<ul>
<li>Pre-defined scripting solutions for all ledge situations</li>
<li>Use pre-defined solutions for difficult to resolve cases, especially
in confined spaces: 可以用stationary cameras或者spline paths</li>
<li>Teleport the camera to a new position if LOS fails due to the ground
being between the camera and its target: 这可能需要检测剪玩家的高度</li>
<li>Use player movement hysteresis to provide an approximate path taken
by the player character or target object</li>
<li>Interrogate the surrounding geometry to dynamically choose a path
based on the last position at which the player was visible to the
camera: 该位置给出了关于ledge的位置信息用于camera
path，但要保证相机不能离物体太近，也不能让相机垂直朝向</li>
</ul></li>
<li>Vertical column avoidance: Predictive cameras一般能解决该问题</li>
<li>Pre-computed solutions</li>
</ul>
<h4 id="avoiding-loss-of-los">Avoiding loss of LOS</h4>
<p>如果不能避免loss of LOS，我们可以采取一些方法进行弥补：</p>
<ul>
<li>Instant movement: 有时候很实用</li>
<li>Fade out the obscuring geometry or objects: 会降低玩家沉浸感</li>
<li>Do not render obscuring gheometry or objects at all:
可以用一个timer，只有时间到了才取消渲染</li>
<li>Render a graphical representation regardless of occlusion</li>
<li>Visibility pre-computation</li>
</ul>
<h4 id="fail-safes">Fail-safes</h4>
<p>Fail-safe检测可以分为三类：</p>
<ul>
<li>Per-update: 在一些情况下必须在每个update进行fail-safe检测
<ul>
<li>Geometry interpenetration of the camera near plane:
可以用一个足够大的collision volume避免</li>
<li>An invalid (non-normalized) camera transformation matrix:
此时可以orthonormalize或者reconstruct矩阵，或者可以回到上次正确的旋转矩阵</li>
<li>The camera is external to the game world</li>
<li>Excessive rotation required aounrd the world up-axis in one update:
限制旋转角度</li>
</ul></li>
<li>Frequent: 有时候每隔几次update进行一次fail-safe检测
<ul>
<li>LOS to garte object extremities</li>
<li>Distance from desired position</li>
</ul></li>
<li>Infrequent: 每隔几秒检测一次
<ul>
<li>Significant occlusion of player character (3rd person view
only)</li>
<li>Camera distance from target is too far: 会让目标看起来太小</li>
</ul></li>
</ul>
<p>一旦触发fail-safe condition，最好是立刻将相机移动到新的safe
position，通常是jump
cut。另一个方法是把相机移动回过去的已知点直到满足条件</p>
<h2 id="chapter-9-motion-and-collision">Chapter 9: Motion and
Collision</h2>
<h3 id="camera-movement-sequence">Camera Movement Sequence</h3>
<p>我们可以按照下述过程移动相机：</p>
<ul>
<li>Determine the desired position</li>
<li>Constrain the desired position accordingly</li>
<li>Generate a prospective movement toward the desired position</li>
<li>Test to see if the prosepctive movement will cause collision
(optional)</li>
<li>Resolve the collision (optional)</li>
<li>Generate and validate an alternative movement (optional if first
move fails)</li>
<li>Move the camera to the new position</li>
</ul>
<h4 id="character-motion">Character motion</h4>
<p>首先看看人物移动会怎样影响第一人称和第三人称相机</p>
<ul>
<li>First person cameras:
注意相机位置通常不是眼睛位置，因此要注意fov和aspect
ratio。有时候玩家跨越世界物体时可能造成traversal
jitter，因此可以增加vertical damping <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A typical damping scheme for aviuding unwanted noise in the verticasl </span></span><br><span class="line"><span class="comment">// motion of the camera is to simply limit the amount allowed per update.</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">kMaxZMotionPerSecond</span> <span class="params">(<span class="number">0.25f</span>)</span></span>;</span><br><span class="line">  <span class="comment">// desired maximum motion</span></span><br><span class="line"><span class="type">float</span> zMotion = newPosition.<span class="built_in">GetZ</span> () - oldPosition.<span class="built_in">GetZ</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> maxZMotion = kMaxZMotionPerSecond * deltaTime;</span><br><span class="line">zMotion = Math::<span class="built_in">Limit</span> (zMotion, maxZMotion);</span><br><span class="line">newPosition.<span class="built_in">SetZ</span> (oldPosition.<span class="built_in">GetZ</span> () + zMotion);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The smoothing is relatively harsh: the amount of vertical motion applied</span></span><br><span class="line"><span class="comment">// is constant and thus will possibly have discontinuities.</span></span><br><span class="line"><span class="comment">// An alternative is to use a critically damped using spring or PID controller.</span></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> zMotion = newPosition.<span class="built_in">GetZ</span> () - oldPosition.<span class="built_in">GetZ</span> ();</span><br><span class="line">verticalSpring.<span class="built_in">SetLength</span> (<span class="built_in">AbsF</span>(zMotion));</span><br><span class="line"><span class="comment">// update the spring length</span></span><br><span class="line"><span class="comment">// Here the target spring length is zero, and need not</span></span><br><span class="line"><span class="comment">// be set each time. Typically the spring length is unsigned,</span></span><br><span class="line"><span class="comment">// so that must be dealt with.</span></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> newZMotion = verticalSpring.<span class="built_in">Update</span> (deltaTime);</span><br><span class="line"><span class="keyword">if</span> (zMotion &gt; <span class="number">0.0f</span>)</span><br><span class="line">  newPosition.<span class="built_in">SetZ</span> (newPosition.<span class="built_in">GetZ</span>() - newZMotion);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  newPosition.<span class="built_in">SetZ</span> (newPosition.<span class="built_in">GetZ</span>() + newZMotion);</span><br></pre></td></tr></table></figure></li>
<li>Third person cameras: 必须解决相机加速小于角色的问题（motion
lag），和相机减速小于角色的问题（overshooting）</li>
</ul>
<h4 id="movement-methods">Movement methods</h4>
<p>一些移动相机的方法包括：</p>
<ul>
<li>Instantaneous motion: 直接把相机移动到期望的位置，但要注意：
<ul>
<li>可能也要改变朝向</li>
<li>可能需要检测新的位置是否离环境物体太近、没有在物体内</li>
<li>尽可能保持control reference frame</li>
<li>尽可能把所有该类型的变换定义为一个函数</li>
<li>如果出现多普勒效应，则应限制相机移动的最大速度</li>
</ul></li>
<li>Locked</li>
<li>Proportional controller: 该方法在目标也移动的时候表现不好
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> deltaPosition = desiredPosition - currentPosition;</span><br><span class="line"><span class="comment">// the distance at which velocity damping is applied</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">kDampDistance</span> <span class="params">(<span class="number">5.0f</span>)</span></span>;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> K = Math::<span class="built_in">Limit</span> (deltaPosition.<span class="built_in">Magnitude</span>() / kDampDistance, <span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// Limit constant to 0..1 based on distance</span></span><br><span class="line">Vec3 <span class="type">const</span> cameraVelocity = deltaPosition.<span class="built_in">AsNormalized</span> () * K;</span><br><span class="line">Vec3 <span class="type">const</span> newPosition = currentPosition + cameraVelocity * deltaTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can help solve the problem of the camera being left behind by adding a </span></span><br><span class="line"><span class="comment">// portion of the target object&#x27;s velocity into the original equation.</span></span><br><span class="line">Vec3 targetVelocity = (desiredPosition - previousDesiredPosition) / deltaTime;</span><br><span class="line">Vec3 = cameraVelocity = (deltaPosition.<span class="built_in">AsNormalized</span> () * K * deltaTime) + (targetVeclocity * T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// To have smooth motion we need to accelerate the camera over time </span></span><br><span class="line"><span class="comment">// with a limiter to provide some degree of lag in the motion.</span></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> acceleration = Math::<span class="built_in">Limit</span> ( (desiredVelocity - currentVelocity), kMaxAcceleration);</span><br><span class="line">Vec3 <span class="type">const</span> currentVelocity += acceleration * deltaTime;</span><br><span class="line">Vec3 <span class="type">const</span> desiredPosition = currentPosition + (currentVelocity * deltaTime);</span><br></pre></td></tr></table></figure></li>
<li>Physical simulations</li>
<li>Springs:
当目标物体朝相机移动或突然停止时，相机可能出现overshooting问题，我们希望critical
damping，即无论目标物体怎么动，都不会出现overshooting</li>
<li>PID controllers: proportional integral derivative (PID)
controllers，把feedback应用到控制器中减少当前值和期望值的错误量
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The usage of PID controller</span></span><br><span class="line">Vec3 <span class="type">const</span> currentDelta = currentPosition - desiredPosition;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> currentDistance = currentDelta.<span class="built_in">Magnitude</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> newDistance = PIDController.<span class="built_in">Update</span> (desiredDistance, currentDistance, deltaTime);</span><br><span class="line">Vec3 <span class="type">const</span> currentPosition = desiredPosition + (currentDelta.<span class="built_in">AsNormalized</span> () * newDistance);</span><br></pre></td></tr></table></figure></li>
<li>Circular movement: 相机的运动由reference
point到当前位置和期望位置之间的夹角决定，因此需要计算其角速度，有两个方法计算：
<ul>
<li>Constant angular velocity: 不管半径多大，以固定的角速度旋转</li>
<li>Constant linear velocity: 保持固定线性速度 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A typical implementation of moving a camera by constant angular velocity might be:</span></span><br><span class="line">Vec3 cameraBearing = <span class="built_in">Vec3</span> (currentPosition - referencePoint);</span><br><span class="line">Vec3 desiredBearing = <span class="built_in">Vec3</span> (desiredPosition - referencePoint);</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> radius = cameraBearing.<span class="built_in">Magnitude</span> ();</span><br><span class="line">cameraBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line">desiredBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> angularMotion = angularVelocity * deltaTime; </span><br><span class="line">  <span class="comment">// rads/update</span></span><br><span class="line">Quat <span class="type">const</span> q = Quat::<span class="built_in">ShortestRotationArcClamped</span> (cameraBearing, desiredBearing, angularMotion);</span><br><span class="line">Vec3 <span class="type">const</span> newBearing = q * cameraBearing; </span><br><span class="line">  <span class="comment">// rotate the original bearing</span></span><br><span class="line">Vec3 <span class="type">const</span> newPosition = referencePoint + (newBearing * radius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of constant linear velocity might be:</span></span><br><span class="line">Vec3 cameraBearing = <span class="built_in">Vec3</span> (currentPosition - referencePoint);</span><br><span class="line">Vec3 desiredBearing = <span class="built_in">Vec3</span> (desiredPosition - referencePoint);</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> radius = cameraBearing.<span class="built_in">Magnitude</span> ();</span><br><span class="line">cameraBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line">desiredBearing.<span class="built_in">Normalize</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> arcLength = linearVelocity * deltaTime;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> angularMotion = <span class="built_in">acosf</span> (arcLength / radius); </span><br><span class="line">  <span class="comment">// units/update</span></span><br><span class="line">Quat <span class="type">const</span> q = Quat::<span class="built_in">ShortestRotationArcClamped</span> (cameraBearing, desiredBearing, angularMotion);</span><br><span class="line">Vec3 <span class="type">const</span> newBearing = q * cameraBearing; </span><br><span class="line">  <span class="comment">// rotate the original bearing</span></span><br><span class="line">Vec3 <span class="type">const</span> newPosition = referencePoint + (newBearing * radius);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Interpolation:
考虑在两个相机的速度之间插值，为了避免discontinuity，要让加速度匹配而不仅仅是速度</li>
</ul>
<h4 id="smoothing-and-damping-techniques">Smoothing and damping
techniques</h4>
<p>Damping方法通常要用ease
functions，把一个输入值（0到1之间）映射到相同区间，只不过是非线性映射且开始和结尾的导数为零</p>
<ul>
<li>Motion damping: 可以通过添加vertical damping减少颠簸感</li>
<li>Motion filters: 用一个低通滤波过滤噪音 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> movementDelta = newPosition - currentPosition;</span><br><span class="line"><span class="keyword">if</span> (movementDelta.<span class="built_in">Magnitude</span> () &gt; kMovementThreshold) &#123;</span><br><span class="line">  currentPosition = newPosition;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ignoring small changes may cause the camera never to move at all!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面是一种改进的方法（使用finite impulese response and infinite impulse
response filters）： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> movementDelta = newPosition - currentPosition;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">close_enough</span> (movementDelta, Vec3::<span class="built_in">Zero</span> ())) &#123;</span><br><span class="line">  <span class="type">float</span> distance = movementDelta.<span class="built_in">Magnitude</span> ();</span><br><span class="line">  distance = mMovementFilter.<span class="built_in">Update</span> (distance);</span><br><span class="line">  currentPosition += movementDelta.<span class="built_in">AsNormazlied</span> () * distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="motion-constraints">Motion constraints</h4>
<p>一般有下述几种相机约束：</p>
<ul>
<li><p>Vertical motion constraint:
用于避免不想要的图形效果如穿模，比如避免水面穿帮可以用下面的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">kMinimumZDistance</span> <span class="params">(<span class="number">0.1f</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">zDistance</span> <span class="params">(currentPosition.GetZ () - waterPlane.GetZ ())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span> (zDistance) &lt; kMinimumZDistance)</span><br><span class="line">&#123;</span><br><span class="line">  currentPosition.<span class="built_in">SetZ</span> (waterPlane.<span class="built_in">GetZ</span> () + Math::<span class="built_in">Sign</span> (zDistance) * kMinimumZDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
显然，上述代码的问题在于相机在进入水面后会出现不连续移动，但这无法避免，但可以用特效过渡</p></li>
<li><p>Render geometry proximity: 用collision volume解决</p></li>
<li><p>Distance constraints:
可以让相机和玩家保持固定的距离或最小/最大距离，但是可能会有问题
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3 <span class="type">const</span> unconstrainedOffset = currentPosition - desiredPosition;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> currentDistance = inverseDirection.<span class="built_in">Magnitude</span> ();</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> newDistance = Math::<span class="built_in">Clamp</span> (kMinDistance, currentDistance, kMaxDistance);</span><br><span class="line">Vec3 <span class="type">const</span> newOffset = unconstrainedOffset.<span class="built_in">AsNormalized</span> () * newDistance;</span><br><span class="line">currentPosition = desiredPosition + newOffset;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Planaer constraints <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CPlane <span class="type">const</span> <span class="title">plane</span> <span class="params">(normal, constant)</span></span>;</span><br><span class="line"><span class="function">Vec3 <span class="title">cameraPosition</span> <span class="params">(GetCurrentPosition ())</span></span>;</span><br><span class="line"><span class="type">float</span> <span class="type">const</span> planeDistance = Vec3::<span class="built_in">Dot</span> (plane.<span class="built_in">GetNormal</span> (), cameraPosition) - plane.<span class="built_in">GetConstant</span> ();</span><br><span class="line"><span class="keyword">if</span> (planeDistance &lt; kMinDistance)</span><br><span class="line">&#123;</span><br><span class="line">  cameraPosition += plane.<span class="built_in">GetNormal</span> () * (planeDistance - kMinDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Surface constraints</p></li>
<li><p>Volume constraints</p></li>
</ul>
<h4 id="player-camera-control">Player camera control</h4>
<p>一个原则： &gt; The player should be not REQUIRED to manipulate the
camera simply to play the game, unless explicitly dictated by the game
design.</p>
<p>If camera-relative, the sheer act of moving the camera changes the
control reference frame and "pulls the rug out from under the player's
feet". Sadly, some games seem to treat this behavior as acceptable. It
is not. Changing the control reference frame without player knowledge is
counter to good game play practice.</p>
<ul>
<li>Maunipulation of the camera position:
有时候允许玩家直接操纵相机，分为2D和3D相机
<ul>
<li>2D相机: 2D游戏通常会限制相机的移动以防看到游戏外的场景</li>
<li>3D相机: 在不同相机之间切换可以使用插值或jump cut</li>
</ul></li>
<li>Observer cameras: 提供观察者相机，即可以随意自由移动的相机</li>
<li>Camera motion validation: 一些游戏不允许操纵相机位置</li>
<li>Positional control constraints:
Character-relative相机通常保持在玩家身后的一定区域内，一般不会让相机面朝角色。相机移动要尽可能平滑和慢以避免player
disorientation</li>
</ul>
<h4 id="camera-position-control-schemes">Camera position control
schemes</h4>
<p>主要有两种方法决定相机位置：</p>
<ul>
<li>Character-relative:
类似unity的free-look相机，但需要加一些限制，比如相机的移动范围是一个cylindrical而不是整个球面、相机在人物朝向的身后一定范围内。一些相机允许半自动的移动，比如移动向一个危险区域时</li>
<li>World-relative:
此时相机的朝向和玩家朝向没关系，比如RTS、运动、3D平台游戏中的相机</li>
</ul>
<h4 id="manipulation-of-camera-orientation">Manipulation of camera
orientation</h4>
<ul>
<li>First person cameras</li>
<li>Third person cameras:</li>
</ul>
<h4 id="automated-camera-positioning-and-orientation">Automated camera
positioning and orientation</h4>
<p>除了cinematic
sequences之外，也有一些情况会需要相机自动改变位置和朝向：</p>
<ul>
<li>In response to player controller usage: 玩家自由选择视角</li>
<li>In response to game play requirements:
在三人称游戏中，有时候我们想保证某个物体一直在视野内，有时候，会通过相机给玩家辅助（比如在跳跃时增加pitch）</li>
</ul>
<h4 id="debug-camera-control">Debug camera control</h4>
<p>该相机需要在不影响游戏的情况完全由用户操作，同时，如果能在降低游戏运行速度的情况能以正常速度操作debugging
camera，则会非常有利于debug</p>
<h3 id="camera-collisions">Camera Collisions</h3>
<h4 id="the-importance-of-camera-collisions">The importance of camera
collisions</h4>
<p>Camera collision可能引起的问题：</p>
<ul>
<li>The collision prevents the camera from moving to its desired
position</li>
<li>Discontinuous motion may be caused by collisions</li>
<li>Occulusion of the target object</li>
<li>Camera near plane intersects with geometry</li>
</ul>
<h4 id="collision-determination">Collision determination</h4>
<ul>
<li>Object collisions</li>
<li>Environmental collisions: 有两种数据——render mesh和collision
mesh</li>
<li>Collision primitives: 通常来说，相机会被表示为球体用于碰撞检测</li>
</ul>
<h4 id="collision-geometry-design">Collision geometry design</h4>
<p>下面是一些设计场景的tips:</p>
<ul>
<li>Avoid tightly confined spaces</li>
<li>Allow sufficient space for the camera</li>
<li>Steep steps</li>
<li>Ledges/overhangs</li>
<li>Low ceilings</li>
<li>Doorways:
第一，玩家可能移动太快以至于门在玩家和相机之间关闭，此时可以让门保持开启直到相机穿过；第二，玩家可能沿着门缝移动并导致相机无法跟随玩家，此时可以让相机沿着门缝的轴移动；第三，玩家可能站在门缝里，此时要避免相机因玩家旋转而与物体相交</li>
<li>Use the simplest collision mesh possible</li>
<li>Separate collision mesh for the camera</li>
<li>Chamfer all corners: 为此可以让相机沿着collision表面滑动</li>
</ul>
<h4 id="collision-resolution">Collision resolution</h4>
<p>当我们检测到发生碰撞时，就需要决定相机怎么办，可以有以下几种策略：</p>
<ul>
<li>Do not move: 此时如果人物移动就可能会有问题</li>
<li>Partial move: 尝试向期望方向移动，如果还是有碰撞则不动</li>
<li>Alternative movement: 改变相机的移动方向</li>
<li>Jump cut: 重新计算desired position并立即切换过去</li>
</ul>
<h4 id="disabling-collision-detection">Disabling collision
detection</h4>
<p>有时候我们不需要相机的碰撞检测。比如第一人称和第三人称视角的切换、path-based
cameras。总之取决于期望的相机效果</p>
<h4 id="avoiding-camera-collisions">Avoiding camera collisions</h4>
<p>可以动态生成一条相机跟随的路径，或者统一采用半透明的方式。在三人称游戏中，当玩家在墙角或无法移动的地区时，相机可能和角色碰撞，此时可以切换到第一人称中，或者旋转相机调整相机位置</p>
<ul>
<li>Future position of player</li>
<li>Predicting potential collisions</li>
<li>Collision prediction</li>
<li>Object repulsion</li>
<li>Movement toward the camera</li>
</ul>
<h2 id="chapter-10-camera-mathematics">Chapter 10: Camera
Mathematics</h2>
<p>摄像机的一些数学：</p>
<ul>
<li>Camera position
<ul>
<li>Offset within the local space of an object</li>
<li>Angular offsets relative to game objects</li>
<li>Valid position determination</li>
<li>Spline curves</li>
</ul></li>
<li>Camera orientation
<ul>
<li>Representation</li>
<li>Look-at</li>
<li>Shortest rotation arc</li>
<li>Roll removal</li>
<li>Twist reduction</li>
<li>Determining angles between desired orientations</li>
</ul></li>
<li>Camera motion
<ul>
<li>Proximity</li>
<li>Damping functions</li>
<li>Springs</li>
<li>Interpolation</li>
</ul></li>
<li>Rendering
<ul>
<li>Camera space/world space/screen space conversions</li>
<li>FOV conversion</li>
<li>Frustum construction</li>
<li>Perspective projection</li>
<li>Orthographic projection</li>
<li>Isometric projection</li>
<li>Axonometric projection</li>
</ul></li>
<li>General camera math
<ul>
<li>Digital filters</li>
<li>Spline curves</li>
<li>Interpolation</li>
</ul></li>
<li>Camera math problems and fixes
<ul>
<li>Floating-point accuracy and precision</li>
<li>Epsilon usage</li>
<li>Base conversion</li>
</ul></li>
</ul>
<h3 id="common-mathematical-techniques">Common Mathematical
Techniques</h3>
<h4 id="look-at">Look-at</h4>
<p>此时通过一个旋转矩阵或四元数把当前的相机朝向变换到新的朝向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat4 <span class="type">const</span> <span class="title">Mat4::LookAt</span> <span class="params">(Vec3 <span class="type">const</span>&amp; source, Vec3 <span class="type">const</span>&amp; dest, Vec3 <span class="type">const</span>&amp; worldUpVector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Vec3 viewDirection = <span class="built_in">Vece</span> (dest - source).<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  <span class="type">float</span> dot = Vec3::<span class="built_in">Dot</span> (viewDirection, worldUpVector); </span><br><span class="line">  Vec3 unnormalizedUp = worldUpVector - (dot * vewDirection); <span class="comment">// 相机的unnormalized Up axis</span></span><br><span class="line">  Vec3 up = unnormalizedUp.<span class="built_in">AsNormalized</span> ();  <span class="comment">// 相机的up axis</span></span><br><span class="line">  Vec3 right = Vec3::<span class="built_in">Cross</span> (up, viewDirection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// matrix ordering depends on row/column major</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Mat4</span> (</span><br><span class="line">    right[X], viewDirection[X], up[X], source[X],</span><br><span class="line">    right[Y], viewDirection[Y], up[Y], source[Y],</span><br><span class="line">    right[Z], viewDirection[Z], up[Z], source[Z]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上面的变换矩阵是把世界空间中的点变换到相机在（0,0）点的位置</p>
<h4 id="roll-removal">Roll removal</h4>
<p>为了移除roll，我们需要重新计算view transform的right
axis同时保持当前的forward vector，然后可以通过叉乘决定up vector</p>
<h4 id="twist-reduction">Twist reduction</h4>
<p>在三人称相机中，当物体在相机上方或者下方的时候，可能导致相机快速旋转。一个方法是检测相机绕着forward
vector旋转的速度，但是只有在forward vector几乎在和world up
axis平行的时候</p>
<h4 id="world-space-to-screen-space-conversion">World space to screen
space conversion</h4>
<p>取决于projection算法</p>
<ul>
<li>Orthographic projection <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint32 <span class="type">const</span> ScreenX = ObjectX - ViewportX; <span class="comment">// assumes top left corner is (0,0)</span></span><br><span class="line">uint32 <span class="type">const</span> ScreenY = ViewPortY - ObjectY; <span class="comment">// depends on the direction of +Y</span></span><br></pre></td></tr></table></figure>
如果viewport是显示设备的子集，或者viewport涉及缩放，则必须考虑这些因素：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint32 <span class="type">const</span> ScreenX = Viewport.ScreenX + (ObjectX - Viewport.WorldX);</span><br><span class="line">uint32 <span class="type">const</span> ScreenY = Viewport.ScreenY + (Viewport.WorldY - ObjectY);</span><br></pre></td></tr></table></figure></li>
<li>Isometric projection <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint32 <span class="type">const</span> ScreenX = (ObjectX - Viewport.WorldX) * <span class="number">2</span>;</span><br><span class="line">uint32 <span class="type">const</span> ScreenY = Viewport.WorldY - ObjectY;</span><br></pre></td></tr></table></figure></li>
<li>Perspective projection</li>
</ul>
<h4 id="screen-space-to-cameraworld-space-conversion">Screen space to
camera/world space conversion</h4>
<p>通常来说，神都会被设置为相机的近平面，或者一个特定的距离相机的距离</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">ConvertToWorldSpace</span> <span class="params">(Mat4 <span class="type">const</span>&amp; cameraTransform, Vec3 <span class="type">const</span>&amp; screenPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Vec3 <span class="type">const</span> viewSpace = <span class="built_in">GetProjectionMatrix</span> ().<span class="built_in">Inverted</span> ().<span class="built_in">MultiplyOneOverW</span> (screenSpacePosition);</span><br><span class="line">  Vec3 <span class="type">const</span> worldSpace = cameraTransform * viewSpace;</span><br><span class="line">  <span class="keyword">return</span> worldSpace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fov-conversion">FOV conversion</h4>
<p>考虑把HFOV转化为VFOV，假设我们知道了近平面距离和aspect
ratio，与HFOV</p>
<p>我们定义变量<code>alpha</code>和<code>beta</code>：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">alpha = HFOV / <span class="number">2</span></span><br><span class="line">beta = VFOV / <span class="number">2</span></span><br><span class="line"><span class="built_in">tan</span> (alpha) = (viewport width / <span class="number">2</span>) / near plane distance</span><br><span class="line"><span class="built_in">tan</span> (beta) = (viewport height  / <span class="number">2</span>) / near plane distance</span><br></pre></td></tr></table></figure></p>
<p>从而有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tan</span> (alpha) * near plane distance = viewport width / <span class="number">2</span></span><br><span class="line">Near plane distance = (viewport width / <span class="number">2</span>) / <span class="built_in">tan</span> (alpha)</span><br><span class="line"><span class="built_in">tan</span> (beta) * near plane distance = viewport height / <span class="number">2</span></span><br><span class="line">Near plane distance = (viewport height / <span class="number">2</span>) / <span class="built_in">tan</span> (beta)</span><br></pre></td></tr></table></figure>
<p>进而有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(viewport width / <span class="number">2</span>) * <span class="built_in">tan</span> (beta) = (viewport height / <span class="number">2</span>) * <span class="built_in">tan</span> (alpha)</span><br><span class="line"><span class="built_in">tan</span> (beta) = [(viewport height / <span class="number">2</span>) / (viewport width / <span class="number">2</span>)] * <span class="built_in">tan</span> (alpha)</span><br><span class="line"><span class="built_in">tan</span> (beta) = aspect ratio * <span class="built_in">tan</span> (alpha)</span><br><span class="line">VFOV = <span class="number">2</span> * <span class="built_in">arctan</span> (<span class="built_in">tan</span> (HFOV / <span class="number">2</span>) * aspect ratio)</span><br></pre></td></tr></table></figure>
<p>所以，只要知道了aspect ratio和其中一个FOV，就可以求出另一个FOV</p>
<h3 id="quaternions">Quaternions</h3>
<p>四元数的好处在于可以很方便地插值，且没有Gimbal Lock问题。</p>
<h3 id="bump-and-ease-functions">Bump and Ease Functions</h3>
<p>Bump和ease
functions都用来保证开始和结束的平滑，ease函数分为ease-in和ease-out函数，ease-in函数也叫damping函数。下面讨论几个简单的函数来生成S型曲线</p>
<h4 id="exponentials">Exponentials</h4>
<p>使用简单的三次函数： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> exp = <span class="number">3</span>t^<span class="number">2</span> - <span class="number">2</span>t^<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="proportional">Proportional</h4>
<p>Proportional ease
function使用当前值和期望值之间的差值作为输入，常用一个damping range：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> deltaValue = desiredValue - currentValue;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(deltaValue) &lt; kRange&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> factor = Math::<span class="built_in">Limit</span> (deltaValue / kRange, <span class="number">1.f</span>);</span><br><span class="line">  currentValue += kSpeed * factor * deltaTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proportional damping
function实现简单且高效，但是可能不如其他方法平滑。另一种方法是根据经过的时间计算factor：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">dampingFactor</span> <span class="params">(<span class="number">1.0f</span> - elapsedTime / totalTime)</span></span>;</span><br><span class="line">interpolant += (destinationValue - interpolant) * dampingFactor * deltaTime;</span><br><span class="line"><span class="keyword">return</span> interpolant;</span><br></pre></td></tr></table></figure></p>
<h4 id="spherical-linear-interpolation">Spherical linear
interpolation</h4>
<p>球面线性插值</p>
<h4 id="transcendentals">Transcendentals</h4>
<p>用三角函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">angle = (pi * time factor) - (pi / 2);  // in radians, -pi/2 ... pi/2</span><br><span class="line">time factor = (sinf(angle) + 1) / 2</span><br></pre></td></tr></table></figure>
<h3 id="springs">Springs</h3>
<p>当实现相机移动的时候我们常常碰到相机overshoot的问题，这是因为目标在不断移动，阻止相机足够快地改变方向、速度以避免被目标对象自身抢占位置，但同时我们也不想相机过快移动，这就导致了矛盾</p>
<p>此时我们可以使用弹簧方案，基于下述的方程：</p>
<p><span class="math display">\[F=-K*X\]</span></p>
<p><span
class="math inline">\(K\)</span>是弹性常量，一个正数表示弹簧的弹性，<span
class="math inline">\(X\)</span>是弹簧伸缩度，这样我们可以写出下面的伪代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3 deltaPosition = desiredPosition - currentPosition;</span><br><span class="line">Vec3 movementDirection = deltaPosition.<span class="built_in">AsNormalized</span> ();</span><br><span class="line"><span class="type">float</span> extension = deltaPosition.<span class="built_in">Magnitude</span> ();</span><br><span class="line"><span class="type">float</span> force = -kSpringConstant * extension; <span class="comment">// for a unit mass, this is acceleration, F = ma</span></span><br><span class="line">Vec3 newVelocity = currentVelocity + (movementDirection * force);</span><br><span class="line"><span class="keyword">new</span> Position = currentPosition + (currentVelocity * deltaTime);</span><br></pre></td></tr></table></figure></p>
<p>弹簧方案的一个问题是设置弹簧的弹性常量，并且会出现震荡现象，这可以用两种思路解决：</p>
<ul>
<li>使用damped spring，控制施加的力使得弹簧接近但永远不会超过目标</li>
<li>使用feedback controller</li>
</ul>
<h3 id="digital-filters">Digital Filters</h3>
<p>在控制器输入或相机移动中，我们想要移除小的震荡，此时可用滤波器</p>
<h4 id="low-pass">Low pass</h4>
<p>低通滤波让低频信号通过，而过滤高频信号</p>
<h4 id="high-pass">High pass</h4>
<p>与低通滤波相反</p>
<h4 id="band">Band</h4>
<p>移除某个频率范围之外的信号</p>
<h4 id="finite-impulse-response">Finite impulse response</h4>
<p>有限脉冲响应滤波在计算当前值的时候结合之前的输入值，因为易于实现，所以与IIR滤波相比更倾向于FIR滤波</p>
<p>History
buffer中的每一项都有一个对应的滤波系数，对应了该项目的影响有多大，即改变对输入值的响应度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">float</span> <span class="type">const</span> firCoefficients[] = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// these values greatly influence the filter</span></span><br><span class="line">  <span class="comment">// response and may be adjusted accordingly</span></span><br><span class="line">  <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">2.f</span>, <span class="number">3.f</span>, <span class="number">4.f</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CFIRFilter::Initialize</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// setup the coefficients for desired response</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mHistoryBuffer.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    mCoefficients[i] = firCoefficients[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CFIRFilter::Update</span> <span class="params">(<span class="type">float</span> <span class="type">const</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// copy the entries in the history buffer up by one</span></span><br><span class="line">  <span class="comment">// position (i.e. lower entries are more recent)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mHistoryBuffer.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// not efficient! Can use circular buffer</span></span><br><span class="line">    mHistoryBuffer[i + <span class="number">1</span>] = mHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  mHistoryBuffer[<span class="number">0</span>] = input;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">fir</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// now accumulate the values from the history</span></span><br><span class="line">  <span class="comment">// buffer multiplied by the coefficients</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &gt; mHistoryBuffer.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    fir += mCoefficients[i] * mHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="infinite-impulse-response">Infinite impulse response</h4>
<p>不同于FIR，IIR也加入了之前的输出值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">CIIRFilter::Initialize</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mInputCoefficients[<span class="number">0</span>] = <span class="number">0.5f</span>;</span><br><span class="line">  mInputCoefficients[<span class="number">1</span>] = <span class="number">0.3f</span>;</span><br><span class="line">  mOutputCoefficients[<span class="number">0</span>] = <span class="number">0.5f</span>;</span><br><span class="line">  mOutputCoefficients[<span class="number">1</span>] = <span class="number">0.3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">CIIRFilter::Update</span> <span class="params">(<span class="type">float</span> <span class="type">const</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mInputHistoryBuffer.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// not efficient! Can use circular buffer</span></span><br><span class="line">    mInputHistoryBuffer[i + <span class="number">1</span>] = mInputHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  mInputHistoryBuffer[<span class="number">0</span>] = input;</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> result = </span><br><span class="line">    mInputCoefficients[<span class="number">0</span>] * mInputHistoryBuffer[<span class="number">0</span>] +</span><br><span class="line">    mInputCoefficients[<span class="number">1</span>] * mInputHistoryBuffer[<span class="number">1</span>] +</span><br><span class="line">    mOutputCoefficients[<span class="number">0</span>] * mOutputHistoryBuffer[<span class="number">0</span>] +</span><br><span class="line">    mOutputCoefficients[<span class="number">1</span>] * mOutputHistoryBuffer[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mOutputHistoryBuffer.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// not efficient! Can use circular buffer</span></span><br><span class="line">    mOutputHistoryBuffer[i + <span class="number">1</span>] = mOutputHistoryBuffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  mOutputHistoryBuffer[<span class="number">0</span>] = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spline-curves">Spline Curves</h3>
<p>Spline由一系列控制点和对应的tangent
vector控制，每个segment通常由两个控制点组成，每个控制点有1~2个切线向量。相邻两个segment之间共享的控制点叫做joint</p>
<h4 id="camera-spline-usage">Camera spline usage</h4>
<p>相机Spline的通常用法是定义一条路径，再用一个evaluation函数将时间映射到路径上的位置。二维spline通常用来表示物体的属性，三维spline通常用来表示空间位置</p>
<h4 id="cubic-polynomials">Cubic polynomials</h4>
<p>三次多项式可以表示为：</p>
<p><span class="math display">\[Y=Ax^3+Bx^2+Cx+D\]</span></p>
<p>有时候需要给定<span class="math inline">\(Y\)</span>解出<span
class="math inline">\(x\)</span></p>
<h4 id="spline-types">Spline types</h4>
<p>下面介绍几种不同的spline types:</p>
<ul>
<li>Linear: 一系列直线，用下面的代码计算位置 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">Linear</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + ((<span class="number">1.f</span> - time) * <span class="built_in">Vec3</span> (b - a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Piecewise Hermite:
Hermite曲线要求两个控制前和两个切线，每个控制点一条切线。我们也可以为每个控制点引入两条切线——in-tangent和out-tangent，很多动画系统用这种方法
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Vec3 <span class="title">Hermit</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; startTangent, Vec3 <span class="type">const</span> &amp; endTangent, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (u &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t2</span> <span class="params">(time * time)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t3</span> <span class="params">(t2 * time)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate basis functions</span></span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> a0 = (t3 * <span class="number">2.0f</span>) - (<span class="number">3</span> * t2) + <span class="number">1.0f</span>;</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> a1 = (<span class="number">-2.0f</span> * t3) + (<span class="number">3.0f</span> * t2);</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> b0 = t3 - (<span class="number">2.0f</span> * t2) + u;</span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> b1 = t3 - t2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use cubic basis functions with points and tangents</span></span><br><span class="line">  <span class="function">Vec3 <span class="type">const</span> <span class="title">result</span> <span class="params">((a0 * a) + (a1 * b) + (b0 * startTangent) + (b1 * endTangent))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Catmull-Rom: Catmull-Rom spline
C1连续、局部控制，但是并不位于控制点形成的convex hull中
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">CatmullRom</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">if</span> (time &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="type">const</span> t2 = time * time;</span><br><span class="line">    <span class="type">float</span> <span class="type">const</span> t3 = t2 * time;</span><br><span class="line"></span><br><span class="line">    Vec3 <span class="type">const</span> result = (a * (<span class="number">-0.5f</span> * t3 + t2 - <span class="number">0.5f</span> * time) +</span><br><span class="line">                         b * (<span class="number">1.5f</span> * t3 - <span class="number">2.5f</span> * t2 + <span class="number">1.0f</span>) +</span><br><span class="line">                         c * (<span class="number">1.5f</span> * t3 + <span class="number">2.0f</span> * t2 + <span class="number">0.5f</span> * time) +</span><br><span class="line">                         d * (<span class="number">0.5f</span> * t3 - <span class="number">0.5f</span> * t2));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Rounded Catmull-Rom: 能够决定两个控制点中间曲线的速度
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">RoundedCatmullRom</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">if</span> (time &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find velocities at b and c</span></span><br><span class="line">  Vec3 <span class="type">const</span> cb = c - b;</span><br><span class="line">  <span class="keyword">if</span> (!cb.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  Vec3 ab = a - b;</span><br><span class="line">  <span class="keyword">if</span> (!ab.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    ab = <span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  Vec3 bVelocity = cb.<span class="built_in">AsNormalized</span> () - ab.<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  <span class="keyword">if</span> (bVelocity.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    bVelocity.<span class="built_in">Normalize</span> ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bVelocity.<span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  Vec3 dc = d - c;</span><br><span class="line">  <span class="keyword">if</span> (!dc.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    dc = <span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  Vec3 bc = -cb;</span><br><span class="line">  Vec3 cVelocity = dc.<span class="built_in">AsNormalized</span> () - bc.<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  <span class="keyword">if</span> (cVelocity.<span class="built_in">IsNormalizable</span> ())</span><br><span class="line">    cVelocity.<span class="built_in">Normalize</span> ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    bVelocity = <span class="built_in">Vec3</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> <span class="type">const</span> cbDistance = cb.<span class="built_in">Magnitude</span> ();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CatmullRom</span> (b, c, bVelocity * cbDistance, cVelocity * cbDistance, time);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Kochanek-Bartels splines: KB spline是CR
spline的扩展，因为引入了其他的参数来控制spline的曲率。有三个参数：
<ul>
<li>Bias:
控制每个tangent的方向，-1使曲线提早buckle，+1使曲线buckle到末尾</li>
<li>Tension: 控制每个tangent vector的长度，
+1导致更紧的曲线，-1导致更圆的曲线，如果大于+1则产生环</li>
<li>Continuity:
控制tangents之间的角度，-1使曲线向里buckel，+1使边角朝向相反方向
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">KBSpline</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">float</span> <span class="type">const</span> tension, <span class="type">float</span> <span class="type">const</span> continuity, <span class="type">float</span> <span class="type">const</span> bias)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// tension, continuity ans bias defined per segment</span></span><br><span class="line">  Vec3 <span class="type">const</span> ab = <span class="built_in">Vec3</span> (b - a).<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  Vec3 <span class="type">const</span> cd = <span class="built_in">Vec3</span> (d - c).<span class="built_in">AsNormalized</span> ();</span><br><span class="line">  Vec3 <span class="type">const</span> inTangent = ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> - continuity) * (<span class="number">1.f</span> + bias)) * <span class="number">0.5f</span> * ab +</span><br><span class="line">  ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> + continuity) * (<span class="number">1.f</span> - bias)) * <span class="number">0.5f</span> * cd;</span><br><span class="line">  Vec3 <span class="type">const</span> outTangent = ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> + continuity) * (<span class="number">1.f</span> + bias)) * <span class="number">0.5f</span> * ab +</span><br><span class="line">  ((<span class="number">1.f</span> - tension) * (<span class="number">1.f</span> - continuity) * (<span class="number">1.f</span> - bias)) * <span class="number">0.5f</span> * cd;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">PiecewiseHermite</span> (b, c, inTangent, outTangent, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果所有参数都为零，则退化为CR spline</li>
</ul></li>
<li>Bézier: 二次贝塞尔曲线方程为</li>
</ul>
<p><span class="math display">\[a(1-t)^2+b(2t)(1-t)+ct^2\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">QuadraticBezier</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">oneMinusTime</span> <span class="params">(<span class="number">1.f</span> - time)</span></span>;</span><br><span class="line">  Vec3 <span class="type">const</span> bezier = (a * oneMinusTime * oneMinusTime) + (b * <span class="number">2.f</span> * time * oneMinusTime) + (c * time * time);</span><br><span class="line">  <span class="keyword">return</span> bezier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三次贝塞尔曲线方程为：</p>
<p><span
class="math display">\[a(1-t)^3+b(3t)(1-t)^2+c(3t^2)(1-t)+dt^3\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">CubicBezier</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">oneMinusTime</span> <span class="params">(<span class="number">1.f</span> - time)</span></span>;</span><br><span class="line">  Vec3 <span class="type">const</span> bezier = (a * oneMinusTime * oneMinusTime * oneMinusTime) + (b * <span class="number">3.f</span> * time * oneMinusTime * oneMinusTime) + (c * <span class="number">3.f</span> * time * time * oneMinusTime) + (d * time * time * time);</span><br><span class="line">  <span class="keyword">return</span> bezier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Uniform cubic B-spline: B spline是一种泛化的Bezier
spline，一个好处是它有local
control，即：每个控制点只会影响整个曲线的一小部分，它使用下述的blending
function</li>
</ul>
<p><span class="math display">\[S_i(t)=\frac{1}{6}\begin{bmatrix}
  t^3 &amp; t^2 &amp; t &amp; 1
\end{bmatrix}
\begin{bmatrix}
  -1 &amp; 3 &amp; -3 &amp; 1\\
  3 &amp; -6 &amp; 3 &amp; 0\\
  -3 &amp; 0 &amp; 3 &amp; 0\\
  1 &amp; 4 &amp; 1 &amp; 0
\end{bmatrix}
\begin{bmatrix}
  P_{i-3}\\
  P_{i-2}\\
  P_{i-1}\\
  P_i
\end{bmatrix}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3 <span class="type">const</span> <span class="title">BSpline</span> <span class="params">(Vec3 <span class="type">const</span> &amp; a, Vec3 <span class="type">const</span> &amp; b, Vec3 <span class="type">const</span> &amp; c, Vec3 <span class="type">const</span> &amp; d, <span class="type">float</span> <span class="type">const</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t2</span> <span class="params">(time * time)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="type">const</span> <span class="title">t3</span> <span class="params">(t2 * time)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Vec3 <span class="type">const</span> <span class="title">result</span> <span class="params">((a * (-t3 + (<span class="number">3</span> * t2) + (<span class="number">-3</span> * time) + <span class="number">1</span>)) +</span></span></span><br><span class="line"><span class="params"><span class="function">                   (b * ((<span class="number">3</span> * t3) + (<span class="number">-6</span> * t2) + <span class="number">4</span>)) +</span></span></span><br><span class="line"><span class="params"><span class="function">                   (c * ((<span class="number">-3</span> * t3) + (<span class="number">3</span> * t2) + (<span class="number">3</span> * time) + <span class="number">1</span>)) +</span></span></span><br><span class="line"><span class="params"><span class="function">                   (d * t3))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> (result / <span class="number">6.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Non-uniform rational B-spline</li>
</ul>
<h4 id="continuity">Continuity</h4>
<p>C0是位置连续，C1是速度连续，C2是加速度连续。所以C1或更高的连续会在视觉上效果更好，C2或更高的连续会有更平滑的移动</p>
<h4 id="spline-definitions">Spline definitions</h4>
<p>为了充分地定义spline curve，我们需要几个机制：</p>
<ul>
<li>一个能够在游戏世界放置控制点的编辑器，甚至可以在游戏运行的时候生成</li>
<li>Spline evaluation type</li>
<li>跨国spline的总的时间或一个映射函数</li>
<li>一个可视化展示spline curve的界面，随参数改变动态变化</li>
</ul>
<h4 id="spline-evaluation">Spline evaluation</h4>
<p>可以预先计算整个spline的长度，然后用一个线性长度作为spline上的位置。如果再搭配速度damping则会产生比较平滑的效果</p>
<h4 id="control-point-generation">Control point generation</h4>
<ul>
<li>单个控制点：总是返回这个点</li>
<li>两个控制点：要提供额外的tangent信息，否则无法确定曲线</li>
<li>三个控制点：可以外推第四个控制点</li>
</ul>
<h4 id="parameterized-arc-length">Parameterized arc length</h4>
<p>积分法</p>
<h4 id="total-spline-length">Total spline length</h4>
<p>总长度是各个spline弧长度的和，往往采用数值方法近似曲线长度</p>
<h4 id="closest-position">Closest position</h4>
<p>计算spline上离某个位置最近的点往往很有用，但问题是可能有多个解，这时候就需要对这些解做个排序，比如考虑相机的前一个位置或者LOS，或者相机的角速度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Determine the nornal at each end of the segment and by using similar triangles</span><br><span class="line">Determine the length on the segment</span><br><span class="line">If length within 0..1 then</span><br><span class="line">  Convert linear 0..1 into a parametric value</span><br><span class="line">  With parametric value 0..1 find the position within the arc using the usual spline evaluation</span><br><span class="line">  Check position against source position for LOS and other factors</span><br><span class="line">  If OK, determine the physical distance between two points and compare to current &quot;best&quot;</span><br><span class="line">Else</span><br><span class="line">  Not within segment, so proceed to next segment</span><br></pre></td></tr></table></figure>
<h4 id="spline-editing">Spline editing</h4>
<p>开发能够编辑spline的工具</p>
<h3 id="interpolation">Interpolation</h3>
<p>线性插值在一对数据点中生成新数据，piecewise插值则是由几个连续的数据点去生成。相机朝向往往用非线性插值</p>
<h3 id="camera-property-interpolation">Camera Property
Interpolation</h3>
<h4 id="position-interpolation">Position interpolation</h4>
<p>位置插值应该是基于当前的位置和目标位置，用这个距离相比于原来的距离</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3 interpFactor = CMath::<span class="built_in">Clamp</span> (<span class="number">0.0f</span>, interpTimer/maxInterpTime, <span class="number">1.0f</span>);</span><br><span class="line">Vec3 currentDeltaPosition = desiredPosition - <span class="built_in">GetTranslation</span> ();</span><br><span class="line">Vec3 newPosition = <span class="built_in">GetTranslation</span> () + (currentDeltaPostion * interpFactor);</span><br><span class="line"><span class="comment">// when interpTimer reaches maxInterpTime, the camera reaches the destination</span></span><br></pre></td></tr></table></figure>
<h4 id="orientation-interpolation">Orientation interpolation</h4>
<p>朝向插值通常不涉及roll，即使需要考虑roll，也会单独处理</p>
<p>由于小的朝向改变会引起巨大的视觉变化，所以一定要确保朝向插值的平滑。线性插值并不保证对象一定在视野里。如果朝向改变很大，要限制角速度，或者使用jump
cut。朝向插值也要保证路径最短</p>
<ul>
<li>Orientation interpolation by angle: NLerp, Slerp,
Squad。基于角度的插值的一个缺点是：相机可能会看得远离目标物体，取决于变化的速度。这可能发生在原相机和目标相机都看向同一点，此时在插值的过程中相机会偏离目标点</li>
<li>Orientation interpolation by target position:
可以用基于目标位置的插值保证目标始终在视野内，但此时朝向速度的变化非常重要</li>
<li>Orientation interpolation characteristics:
当前朝向和期望朝向之间的角度要随着插值越来越小，可以通过两个方法实现：（1）反向计算从目标朝向到当前朝向；（2）保证当前插值角小于等于前一步插值角，如果因为目标朝向改变导致角度增大，则使用前一个插值相机的朝向，一旦插值相机朝向接近目标朝向，则把朝向锁定</li>
<li>Roll interpolation:
用最短方向插值roll，但一般来说roll只用于短时间的相机效果</li>
</ul>
<h4 id="fov-interpolation">FOV interpolation</h4>
<p>如果没有其他渲染效果，那么只改变FOV就显得很突兀，快速的FOV改变会让玩家不适，这时候一个jump
cut反而更好。zoom in也是通过FOV实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> targetFOV = <span class="built_in">GetTargetFOV</span> ();</span><br><span class="line"><span class="type">float</span> deltaFOV = mFOV - targetFOV;</span><br><span class="line"><span class="type">float</span> newFOV = targetFOV + (deltaFOV * deltaTime);</span><br><span class="line"><span class="type">float</span> newDeltaFOV = newFOV - targetFOV;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">absF</span>(newDeltaFOV) &lt; <span class="built_in">absF</span>(deltaFOV))</span><br><span class="line">&#123;</span><br><span class="line">  mFOV = newFOV; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="viewport-interpolation">Viewport Interpolation</h3>
<p>改变显示设备的大小，通常用于cinematic sequences和regular game
play之间的转换。比如从2.35:1到1.33:1</p>
<h3 id="player-control-interpolation">Player Control Interpolation</h3>
<h4 id="first-person-cameras">First person cameras</h4>
<p>control interpolation通常用于从一个第一人称control reference
frame变化到一个fixed control reference frame比如object orbiting</p>
<h4 id="third-person-cameras">Third person cameras</h4>
<p>在很多情况下，我们要保证如果相机出现巨大移动，则玩家控制不会马上改变</p>
<p>一个问题是如何处理玩家移动比相机移动快的问题，而且玩家绕着相机垂直轴的任何移动会导致相机绕着该轴的快速转动</p>
<h3 id="interpolation-choices">Interpolation Choices</h3>
<p>首先要问现有的数据是kay value还是control
values；第二，要考虑插值方法的效率和效果；第三，要考虑插值结果的平滑性；最后，也要考虑不同插值方法需要的数据量</p>
<h4 id="linear-interpolation">Linear interpolation</h4>
<p>线性插值只需要三个参数：source value, destination
value和interpolation method</p>
<p>Destination value往往会随时间改变，我们就需要考虑到destination
value的变化率，当插值的变化率不匹配目标值的变化率时，不连续就会发生</p>
<p>插值方法需要考虑是否要用固定的时间完成插值。不考虑变化率会在开始和结束时产生不连续现象</p>
<h4 id="piecewise-interpolation">Piecewise interpolation</h4>
<p>通常有多于两个数据点进行插值，一种策略是把它们视为独立的interpolation
segments： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">foundTime</span> <span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; valueTimes.<span class="built_in">Size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (valueTimes[i+<span class="number">1</span>] &gt; time)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">float</span> timeDelta = valueTimes[i+<span class="number">1</span>] - valueTimes[i];</span><br><span class="line">    timeFactor = (time - valueTimes[i]);</span><br><span class="line">    segment = i;</span><br><span class="line">    source = values[i];</span><br><span class="line">    destination = values[i+<span class="number">1</span>];</span><br><span class="line">    foundTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (foundTime)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Interpolate</span> (source, destination, timeFactor);</span><br></pre></td></tr></table></figure></p>
<p>此外，也可以在每对数据点中假设均匀时间区间，但会有比较大的问题</p>
<h3 id="methods-of-interpolation">Methods of Interpolation</h3>
<h4 id="linear-time-interpolation">Linear time interpolation</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interpolated value = source + ((destination - source) * t)</span><br></pre></td></tr></table></figure>
<h4 id="parametric-functions">Parametric functions</h4>
<p>比如ease函数</p>
<h4 id="spherical-linear-interpolation-1">Spherical linear
interpolation</h4>
<p>用于角的插值</p>
<h3 id="potential-interpolation-problems">Potential Interpolation
Problems</h3>
<h4 id="aesthetic-problems">Aesthetic problems</h4>
<p>一些视觉上的问题包括：</p>
<ul>
<li>Geometry interpenetration</li>
<li>Discontinuities</li>
<li>Interpolation noise</li>
<li>Target object framing</li>
<li>Large orientation changes</li>
<li>Large interpolation distances</li>
</ul>
<h4 id="mathematical-problems">Mathematical problems</h4>
<p>数学上的问题一般是由浮点误差导致的：</p>
<ul>
<li>Co-linear (or exactly opposed) orientation</li>
<li>Coincident positions: 0为除数</li>
<li>Floating-point inaccuracy</li>
</ul>
<h3 id="interruption-of-interpolation">Interruption of
Interpolation</h3>
<p>有可能在一个插值过程中触发了另一个插值，这时候可以从当前值开始直接开始新的插值</p>
<h3 id="transitions">Transitions</h3>
<h4 id="position-during-transitions">Position during transitions</h4>
<h4 id="orientation-during-transitions">Orientation during
transitions</h4>
<p>有两种方法在transition的过程中控制插值相机的朝向，如果source和des相机没有reorienting，那么简单的线性插值或slerp可以处理得很好，但如果有一个或者两个都reorient就会有问题。一个方法是计算从目标值到当前值之间得剩余量（比如角度），如果新的插值大于当前值，则忽略</p>
<h3 id="camera-math-problems">Camera Math Problems</h3>
<h4 id="floating-point-precision">Floating-point precision</h4>
<p>相机系统一般用单精度浮点数，所以不能表示很大的数</p>
<h4 id="epsilon-usage">Epsilon usage</h4>
<p>要根据用途改变epsilon的值</p>
<h4 id="compiler-differences">Compiler differences</h4>
<p>编译器也有不同</p>
<h4 id="hardware-fpu-differences">Hardware FPU differences</h4>
<h4 id="vector-normalization">Vector normalization</h4>
<h4 id="matrix-concatenation-floating-point-drift">Matrix concatenation
floating-point drift</h4>
<p>在应用旋转矩阵后，正交化该矩阵以保证浮点精确度</p>
<h3 id="periodic-camera-mathematical-fixes">Periodic Camera Mathematical
Fixes</h3>
<p>最好在渲染之前检查当前的相机变换是不是正确的，包括：</p>
<ul>
<li>变换矩阵的每个元素不包含异常值，比如NaN</li>
<li>变换矩阵的每个向量都是单位向量</li>
<li>Up-vector和游戏内的Up-vector一致</li>
<li>必要时移除roll</li>
<li>必要时限制相机快速的reorientation</li>
</ul>
<p>如果矩阵不能被修复，则使用上一帧的矩阵；记得多正交化矩阵</p>
<h2 id="chapter-11-implementation">Chapter 11: Implementation</h2>
<h3 id="game-engine-architecture">Game Engine Architecture</h3>
<h4 id="game-update-loop">Game update loop</h4>
<p>大多数相机逻辑都要在其他逻辑之后执行，典型的执行顺序是：</p>
<ul>
<li>Process input</li>
<li>Process pre-logic on game objects</li>
<li>Process main logic (AI, etc.) on game objects</li>
<li>Move game objects and resolve collisions</li>
<li>Process all camera logic</li>
<li>Process post-camera logic for objects (such as dependencies on
camera position, orientation, etc.)</li>
<li>Process all viewport logic</li>
<li>Render scene for each viewport</li>
</ul>
<h4 id="game-system-managers">Game system managers</h4>
<p>一些管理系统包括：</p>
<ul>
<li>Camera manager:
跟踪所有的相机，传递输入、确保每个都得到正确更新</li>
<li>Object manager: 管理游戏中的每个对象，保证逻辑处理顺序正确</li>
<li>Message manager</li>
<li>Audio manager: 通过它控制音效的变化</li>
<li>Input manager: 将输入信息传递给所有需要的游戏对象</li>
</ul>
<h4 id="delta-time">Delta time</h4>
<p>现在游戏通常将逻辑层与渲染层分开，这有利于CPU处理和GPU渲染，游戏逻辑可能以固定的速率更新，也可能以动态的速度更新，从而，相邻两次更新的时间间隔不一定一致，经过的时间就称为delta
time</p>
<h4 id="input-processing">Input processing</h4>
<p>很多相机需要把输入值传递给它们，这通常由相机管理器实</p>
<h3 id="camera-system-architecture">Camera System Architecture</h3>
<h4 id="viewport-manager">Viewport manager</h4>
<p>主要工作是包含所有在场景内需要渲染的东西，处理控制器输入、渲染、masking、buffer管理、aspect
ratio等等，能够被其他游戏系统用于访问关于当前活跃相机的相机系统。数据结构是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CViewportManager</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> int32 TViewportHandle;</span><br><span class="line">    <span class="function">TViewportHandle <span class="type">const</span> <span class="title">CreatViewport</span> <span class="params">(EViewportType)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeleteViewport</span> <span class="params">(TViewportHandle <span class="type">const</span> viewport)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span> <span class="params">(<span class="type">float</span> <span class="type">const</span> deltaTime)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ProcessInput</span> <span class="params">(CInput <span class="type">const</span> &amp; input)</span></span>;</span><br><span class="line">    <span class="function">CViewport <span class="type">const</span> &amp; <span class="title">GetViewport</span> <span class="params">(TViewportHandle <span class="type">const</span> handle)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了显示媒介之后，我们需要描述投影，因此VM需要：</p>
<ul>
<li>Accessors for viewports</li>
<li>Render all viewports</li>
<li>Input handler</li>
<li>Create a new viewport</li>
<li>Activate or deactivate an existing viewport</li>
<li>Delete an existing viewport</li>
<li>Transition (morph) between two viewports</li>
<li>Change viewport properties</li>
<li>Assign an active camera for a viewport</li>
</ul>
<p>每个Viewport都控制了所有需要渲染的信息，比如相机、控制器输入、surface
locatio and
size、渲染模式等等，甚至还包含了用于多种输出设备渲染需要的信息</p>
<p>VM还处理不同viewport之间的过渡，通常用于玩家在菜单界面、暂停时，或者画中画。Transition可能包括：</p>
<ul>
<li>Cut</li>
<li>Wipe</li>
<li>Cross fade</li>
<li>Morphing</li>
</ul>
<h4 id="render-manager">Render manager</h4>
<p>从当前的viewports和cameras获取数据并渲染，此外会移除frustum外的的物体，决定渲染顺序，应用后处理</p>
<h4 id="camera-manager">Camera manager</h4>
<p>CM的主要责任是扮演所有相机的控制器，生成相机新实例、处理转场、插值、优先级、控制器输入、replay
modes和时间控制</p>
<p>CM有Update函数，处理步骤是：</p>
<ul>
<li>决定哪个相机需要开始或结束</li>
<li>更新活动相机的逻辑（插值相机最后）</li>
<li>传递控制器输入</li>
<li>更新audio系统的位置和速度信息</li>
<li>设置渲染环境</li>
</ul>
<h4 id="camera-update-loop">Camera update loop</h4>
<p>相机一般是下面的更新逻辑：</p>
<ul>
<li>Updating active cameras</li>
<li>Update camera scripting</li>
<li>Input processing</li>
<li>Pre-think logic</li>
<li>Think ordering</li>
<li>Cinematic camera deferral: 一般来说，cinematic cameras会在一个update
loop的最开始start，而在update loop的最后结束</li>
<li>Post-think logic</li>
<li>Update audio logic</li>
<li>Debug camera</li>
<li>Render setup</li>
</ul>
<h4 id="hint-manager">Hint manager</h4>
<p>每个CM都有一个与之关联的camera hint manager (CHM)</p>
<h4 id="shake-manager">Shake manager</h4>
<p>相机震动一般发生在渲染阶段而不是实际移动相机，因为这可能导致相机穿过物体。Shake
transform在局部相机空间中计算应用在渲染之前</p>
<p>相机震动有三个组件：</p>
<ul>
<li>Sine wave</li>
<li>Amplitude mapping: 把时间映射为每个axis上的振幅</li>
<li>Random noise</li>
</ul>
<h3 id="game-cameras">Game Cameras</h3>
<h4 id="inherited-camera-behaviors">Inherited camera behaviors</h4>
<p>可以用下面的层级去实现相机类：</p>
<ul>
<li>Actor</li>
<li>Camera</li>
<li>Third Person
<ul>
<li>Slaved</li>
<li>Observer</li>
<li>Path</li>
<li>Surface</li>
<li>Stationary</li>
<li>Transition</li>
<li>Interpolation</li>
<li>Debug</li>
</ul></li>
<li>First Person</li>
</ul>
<h4 id="component-based-camera-behaviors">Component-based camera
behaviors</h4>
<p>不用类继承的方式，另一种方法是使用component-based相机。任何相机的属性都可以拆分为一些可交换的组件，称为behavior，这些behavior能够在运行时组合或交换以产生很多相机变体。一些behavior包括：</p>
<ul>
<li>Determination of the desired position of the camera</li>
<li>Movement toward the desired position including both collision
determination and response</li>
<li>Orientation determination</li>
<li>Rotation toward a desired orientation</li>
<li>Interpolation</li>
<li>Field of view</li>
<li>The rendering effects to apply to this particular camera's view</li>
</ul>
<p>尽管单个component从设计上讲是独立的，但是可能某个特定的component，比如orientation，依赖于其他component的状态，所以需要有特定的component更新顺序</p>
<h4 id="cinematic-cameras">Cinematic cameras</h4>
<p>通常会把cinematic camera与game
camera分开考虑，有自己独立的viewport</p>
<h4 id="debug-camera">Debug camera</h4>
<p>只用于render</p>
<h3 id="scripting-system-implementation">Scripting System
Implementation</h3>
<h4 id="camera-script-objects">Camera script objects</h4>
<p>有时候需要动态改变相机行为，这就是scripting，一些script
objects包括：</p>
<ul>
<li>Camera hints: camera hints通常只是简单的data
repositories，并不要求实际逻辑，除了活跃状态的更新</li>
<li>Trigger volumes</li>
<li>Rendering/lighting effects:
一些渲染效果可以通过给相机发消息实现，或者相机检验游戏状态，或者激活带有特殊效果的相机</li>
<li>Message replay: 引入relay可以使只有一个script object更新</li>
<li>Sequenced event timer:
定义多个游戏事件，它们按照特定的顺序和时间间隔发生</li>
<li>Generic path: 只用一个script object定义path且能够evaluate</li>
</ul>
<h4 id="ordering-of-scripting-logic">Ordering of scripting logic</h4>
<p>如果scripting
logic引起任何需要发送的消息，则它们会立即发送给接收者，但是可能此时接收者已经执行了自己的逻辑，所以要等到下个update时才能做出对当前消息的反应，可以把message
cache</p>
<h4 id="messaging">Messaging</h4>
<p>当事件发生时，需要通知其他游戏物体事件的发生，这一般用messaging
system实现。实际的消息只包含了与该事件有关的信息，比如发送消息的物体、消息本身、其他可能触发该消息的物体</p>
<p>比如当玩家进入trigger volume时，会让对应的script
object发送一个enter消息、是谁发送的消息</p>
<h4 id="prioritization">Prioritization</h4>
<p>可用一个整数代表优先级，也可以用属性表示优先级，比如和玩家之间的距离</p>
<h4 id="interpolation-1">Interpolation</h4>
<p>可以用一个专门的interpolation camera管理相机插值</p>
<h3 id="performance-considerations">Performance Considerations</h3>
<h4 id="amortization">Amortization</h4>
<p>一般用于缓存几个update内的中间值，但相机移动需要立即执行。在采用amortization之前，需要考虑哪些属性不需要每次update都更新，哪些属性需要立即更新</p>
<h4 id="preprocessing">Preprocessing</h4>
<p>大多数的相机CPU消耗都用于ray
casting或碰撞检测，预处理，如沿着特定轨道的相机移动，可以减少CPU开销</p>
<h3 id="tools-support">Tools Support</h3>
<h4 id="world-editor">World editor</h4>
<p>大多数常用的属性都以易用的界面实现，比如camera path definition,
camera hint placement，property editing， pre-defined macros of script
objects:</p>
<ul>
<li>Placement/orientation of cameras</li>
<li>Camera property editing</li>
<li>View from the camera while manupulating</li>
<li>Editing in-game then transferring data back</li>
<li>Limit properties shown to those appropriate for behavior</li>
<li>Paths -- automatic waypoint dropping and connections</li>
<li>Volumes: this is the ability to define 3D regions for various
camera-related functionality</li>
<li>Surfaces: defining surfaces for cameras to move on, for example</li>
<li>Links to target objects: identifying target objects for particular
cameras</li>
<li>Control of position/orientation/roll/fov over time (spline
editor)</li>
<li>Evaluation of target object or interpolant derivation over time:
shows where an object will be located over time in case it has an impact
on the camera behavior</li>
</ul>
<h4 id="camera-collision-mesh">Camera collision mesh</h4>
<p>Camera有自己的collision geometry会更方便，因为可以允许动态改变</p>
<h3 id="camera-debugging-techniques">Camera Debugging Techniques</h3>
<h4 id="interactive-debugging">Interactive debugging</h4>
<p>Interactive debugging包括：</p>
<ul>
<li>Internal property interrogation: 直接看相机数据</li>
<li>Separate debugging camera: 维护一个单独的debug
camera，只在开发环境中使用。当使用debug
camera时，支持某些行为很有用，包括：把角色放置在当前相机位置、展示当前相机位置、从当前相机位置投射射线决定环境属性、暂停游戏运行允许操纵debug
camera、捕捉当前渲染buffer并导出</li>
<li>Control of the update rate of the game:
改变游戏的更新率，尤其是单词更新</li>
<li>General camera state: 跟踪一些相机的事项，包括：state information
(active, interpolating, under player control, etc.), script messaging,
changes to active camera hints/game cameras, occlusion state and the
amount of time occluded, fail-safe activation, invalid camera properties
including the validity of the transformation matrix</li>
<li>Visual representation of camera properties:
可视化相机的一些属性，比如用wireframe sphere or
cube展示相机移动，相机朝向、期望看向点、期望朝向</li>
<li>Property hysteresis: 有时候需要查看相机属性的历史记录，比如camera
position (known as breadcrumbs), camera orientation (display orientation
changes as points on the surface of a unit sphere)</li>
<li>Movement constraints: movement path drawing, based on spline curve
evaluations and represented by an approximation of line segments;
movement surface drawing</li>
<li>Line of sight:
沿着forward画线，同时用颜色标记状态，比如红色表示受到阻挡，还可以显示阻挡物体的材质，比如stone,
ceiling等等</li>
<li>Behavior-specific rendering</li>
<li>Script debugging: script statment execution/filtering, debug message
logging, messaging filtering, object state</li>
</ul>
<h4 id="data-logging">Data logging</h4>
<p>注意logging对游戏性能的影响，一个优化是cache日志信息直到某个不影响游戏性能的时间点</p>
<p>在获取log之后，除了直接阅读文本之外，还可以采用可视化的手段，把数据导入游戏复盘相机数据</p>
<h4 id="game-replaying">Game replaying</h4>
]]></content>
      <categories>
        <category>游戏 - 游戏理论</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>相机</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101疑难点及作业详解</title>
    <url>/2022/10/08/11/01/</url>
    <content><![CDATA[<p>很早之前就想跟着做完GAMES101，但是拖延症一直让我拖到了现在，我决定不再鸽下去！本篇Blog主要记录在GAMES101学习中遇到的疑难问题，整理Bonus
Material，以及详解每一课的作业（含提高题）。如有任何错误、遗漏，欢迎读者指出赐教！</p>
<span id="more"></span>
<h1 id="作业一">作业一</h1>
<h2 id="main.cpp">main.cpp</h2>
<p>本次作业只需要实现<code>main.cpp</code>中的几个函数：<code>get_view_matrix</code>，<code>get_model_matrix</code>和<code>get_projection_matrix</code>，只需要按照课上讲的内容实现就行了，基本没有难度。下面是代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_view_matrix</span><span class="params">(Eigen::Vector3f eye_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f view = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line">    Eigen::Matrix4f translate;</span><br><span class="line"></span><br><span class="line">    translate &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -eye_pos[<span class="number">0</span>], </span><br><span class="line">                 <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -eye_pos[<span class="number">1</span>], </span><br><span class="line">                 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -eye_pos[<span class="number">2</span>], </span><br><span class="line">                 <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    view = translate * view;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_model_matrix</span><span class="params">(<span class="type">float</span> rotation_angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f model = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    model &lt;&lt; std::<span class="built_in">cos</span>(rotation_angle / <span class="number">180.0f</span> * MY_PI), -std::<span class="built_in">sin</span>(rotation_angle / <span class="number">180.0f</span> * MY_PI), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             std::<span class="built_in">sin</span>(rotation_angle / <span class="number">180.0f</span> * MY_PI), std::<span class="built_in">cos</span>(rotation_angle / <span class="number">180.0f</span> * MY_PI),  <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">             <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line">    Eigen::Matrix4f perspective = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line">    Eigen::Matrix4f orthogonal = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t = std::<span class="built_in">tan</span>(eye_fov / <span class="number">180.0f</span> * MY_PI / <span class="number">2.0f</span>) * std::<span class="built_in">abs</span>(zNear);</span><br><span class="line">    <span class="type">float</span> r = aspect_ratio * t;</span><br><span class="line"></span><br><span class="line">    perspective &lt;&lt; zNear, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, zNear, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, zNear + zFar, -zNear * zFar,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    orthogonal &lt;&lt;  <span class="number">1.0</span> / r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">1.0</span> / t, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">2.0</span> / (zNear - zFar), <span class="number">0</span>,</span><br><span class="line">                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    projection = orthogonal * perspective;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="提高题绕任意轴旋转">提高题：绕任意轴旋转</h2>
<p>本次作业的提高题是实现向量绕任意轴旋转的旋转矩阵，推导过程见<a
href="https://sulley.cc/2021/06/07/08/38/">这篇博文</a>。下面的代码是文章中描述的矩阵形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_rotation</span><span class="params">(Vector3f axis, <span class="type">float</span> angle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> rotationRad = angle / <span class="number">180.0f</span> * MY_PI;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3f N = Eigen::Matrix3f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    N &lt;&lt; <span class="number">0</span>, -<span class="built_in">axis</span>(<span class="number">2</span>), <span class="built_in">axis</span>(<span class="number">1</span>),</span><br><span class="line">         <span class="built_in">axis</span>(<span class="number">2</span>), <span class="number">0</span>, -<span class="built_in">axis</span>(<span class="number">0</span>),</span><br><span class="line">         -<span class="built_in">axis</span>(<span class="number">1</span>), <span class="built_in">axis</span>(<span class="number">0</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix3f R = Eigen::Matrix3f::<span class="built_in">Identity</span>() + std::<span class="built_in">sin</span>(rotationRad) * N + (<span class="number">1</span> - std::<span class="built_in">cos</span>(rotationRad)) * N * N;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f rotation = Eigen::Matrix4f::<span class="built_in">Identity</span>();</span><br><span class="line"></span><br><span class="line">    rotation.<span class="built_in">block</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>) = R;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotation; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="作业二">作业二</h1>
<p>本次作业的要求是实现光栅化与MSAA。作业需要完成：</p>
<ul>
<li>为每个三角形创建2D Bounding Box；</li>
<li>判断点是否在三角形内；</li>
<li>判断深度值并更新深度缓存、颜色缓存；</li>
<li>使用MSAA抗锯齿。</li>
</ul>
<h2 id="insidetriangle函数">insideTriangle函数</h2>
<p>首先是判断点<code>(x,y)</code>是否在三角形内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    Vector3f pointA = _v[<span class="number">0</span>];</span><br><span class="line">    Vector3f pointB = _v[<span class="number">1</span>];</span><br><span class="line">    Vector3f pointC = _v[<span class="number">2</span>];</span><br><span class="line">    <span class="function">Vector3f <span class="title">pointO</span><span class="params">(x, y, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    Vector3f OA = pointA - pointO;</span><br><span class="line">    Vector3f OB = pointB - pointO;</span><br><span class="line">    Vector3f OC = pointC - pointO;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> signOAB = OA.<span class="built_in">x</span>() * OB.<span class="built_in">y</span>() - OA.<span class="built_in">y</span>() * OB.<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">float</span> signOBC = OB.<span class="built_in">x</span>() * OC.<span class="built_in">y</span>() - OB.<span class="built_in">y</span>() * OC.<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">float</span> signOCA = OC.<span class="built_in">x</span>() * OA.<span class="built_in">y</span>() - OC.<span class="built_in">y</span>() * OA.<span class="built_in">x</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> signOAB &gt;=<span class="number">0</span> &amp;&amp; signOBC &gt;=<span class="number">0</span> &amp;&amp; signOCA &gt;=<span class="number">0</span> || signOAB &lt;=<span class="number">0</span> &amp;&amp; signOBC &lt;=<span class="number">0</span> &amp;&amp; signOCA &lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的方法就是分别考察<span class="math inline">\(OA\times
OB\)</span>,<span class="math inline">\(OB\times OC\)</span>和<span
class="math inline">\(OC\times OA\)</span>的<span
class="math inline">\(z\)</span>值是否相同。因为我们只需要考察<span
class="math inline">\(z\)</span>值，所以不用真的去计算叉乘，只需要根据公式算出<span
class="math inline">\(z\)</span>值，然后比较是否相同即可。</p>
<h2 id="rasterize_triangle函数">rasterize_triangle函数</h2>
<p>下面是<code>rasterize_triangle</code>函数代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="type">int</span> x_min = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, x_max = -(<span class="number">1</span> &lt;&lt; <span class="number">5</span>), y_min = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, y_max = -(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">x</span>() &lt; x_min) x_min = t.v[i].<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">x</span>() &gt; x_max) x_max = t.v[i].<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">y</span>() &lt; y_min) y_min = t.v[i].<span class="built_in">y</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">y</span>() &gt; y_max) y_max = t.v[i].<span class="built_in">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> x = x_min; x &lt;= x_max; ++x)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> y = y_min; y &lt;= y_max; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">                <span class="type">float</span> z_interpolated = <span class="built_in">compute_interpolated_depth</span>(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>, t);</span><br><span class="line">                <span class="keyword">if</span> (z_interpolated &lt; depth_buf[<span class="built_in">get_index</span>(x, y)])</span><br><span class="line">                &#123;</span><br><span class="line">                    depth_buf[<span class="built_in">get_index</span>(x, y)] = z_interpolated;</span><br><span class="line">                    <span class="built_in">set_pixel</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>), t.<span class="built_in">getColor</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了代码简洁性，把计算深度插值单独提出去当一个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> rst::rasterizer::<span class="built_in">compute_interpolated_depth</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Triangle&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> coefficients = <span class="built_in">computeBarycentric2D</span>(x, y, t.v);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> alpha, beta, gamma;</span><br><span class="line">    std::<span class="built_in">tie</span>(alpha, beta, gamma) = coefficients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(alpha / t.v[<span class="number">0</span>].<span class="built_in">z</span>() + beta / t.v[<span class="number">1</span>].<span class="built_in">z</span>() + gamma / t.v[<span class="number">2</span>].<span class="built_in">z</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，原来代码框架提供的深度插值有误，正确的应是上面的版本（因为之前已经对<code>w</code>进行了归一化，使用原来版本的插值得到的是屏幕空间中的插值而非真实的深度插值）。推导过程详见<a
href="https://sulley.cc/2021/08/14/23/31/">矫正透视投影插值及属性插值详解</a>。</p>
<h2 id="提高题实现msaa">提高题：实现MSAA</h2>
<p>MSAA是把每个像素再拆分成几个小像素，每个小像素单独维护各自的深度和颜色，最后在计算大像素颜色的时候，只需要平均一下其内部小像素的颜色即可，深度则采取具有最小深度值小像素的深度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> dx[<span class="number">4</span>] = &#123;<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.75</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.25</span>, <span class="number">0.75</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="type">int</span> x_min = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, x_max = -(<span class="number">1</span> &lt;&lt; <span class="number">5</span>), y_min = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, y_max = -(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">x</span>() &lt; x_min) x_min = t.v[i].<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">x</span>() &gt; x_max) x_max = t.v[i].<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">y</span>() &lt; y_min) y_min = t.v[i].<span class="built_in">y</span>();</span><br><span class="line">        <span class="keyword">if</span> (t.v[i].<span class="built_in">y</span>() &gt; y_max) y_max = t.v[i].<span class="built_in">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> x = x_min; x &lt;= x_max; ++x)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> y = y_min; y &lt;= y_max; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">get_index</span>(x, y) * <span class="number">4</span>;</span><br><span class="line">            <span class="type">bool</span> need_recompute_color = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">float</span> pixel_depth = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(x + dx[i], y + dy[i], t.v))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">                    <span class="type">float</span> z_interpolated = <span class="built_in">compute_interpolated_depth</span>(x + dx[i], y + dy[i], t);</span><br><span class="line">                    <span class="keyword">if</span> (z_interpolated &lt; depth_sample[index + i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        depth_sample[index + i] = z_interpolated;</span><br><span class="line">                        frame_sample[index + i] = t.<span class="built_in">getColor</span>();</span><br><span class="line">                        <span class="comment">// need_recompute_color is set to true if one sample depth updates</span></span><br><span class="line">                        need_recompute_color = <span class="literal">true</span>; </span><br><span class="line">                        pixel_depth = std::<span class="built_in">min</span>(pixel_depth, z_interpolated);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (need_recompute_color)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3f color = (frame_sample[index] + frame_sample[index + <span class="number">1</span>] + frame_sample[index + <span class="number">2</span>] + frame_sample[index + <span class="number">3</span>]) / <span class="number">4.0f</span>;</span><br><span class="line">                depth_buf[<span class="built_in">get_index</span>(x, y)] = std::<span class="built_in">min</span>(pixel_depth, depth_buf[<span class="built_in">get_index</span>(x, y)]); <span class="comment">// in fact, depth_buf is now useless when using MSAA</span></span><br><span class="line">                <span class="built_in">set_pixel</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>), color);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用MSAA时要注意的是，并不是当前大像素的深度没有更新，其颜色就不用更新。这是因为大像素的颜色是由其内部的小像素的颜色平均而来，只要其中一个小像素的颜色改变了，大像素的颜色就要重新计算。而小像素颜色的变化是由小像素深度的变化引起的，<strong>所以，在考虑当前大像素时，只要其中任意一个小像素的深度更新了，那么就需要重新计算大像素的颜色</strong>。</p>
<p>布尔值<code>need_recompute_color</code>就用来记录当前大像素是否需要重新计算颜色，它只有在<code>insideTriangle(x + dx[i], y + dy[i], t.v)</code>为<code>True</code>（即当前小像素在三角形内），和<code>z_interpolated &lt; depth_sample[index + i]</code>时（即小像素的深度值得到更新）才为<code>True</code>。</p>
<p>代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (need_recompute_color)</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f color = (frame_sample[index] + frame_sample[index + <span class="number">1</span>] + frame_sample[index + <span class="number">2</span>] + frame_sample[index + <span class="number">3</span>]) / <span class="number">4.0f</span>;</span><br><span class="line">    depth_buf[<span class="built_in">get_index</span>(x, y)] = std::<span class="built_in">min</span>(pixel_depth, depth_buf[<span class="built_in">get_index</span>(x, y)]); <span class="comment">// in fact, depth_buf is now useless when using MSAA</span></span><br><span class="line">    <span class="built_in">set_pixel</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">1.0f</span>), color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
把当前大像素内所有小像素的颜色平均起来，就是最终呈现在屏幕上的颜色。</p>
<p>下面的两图对比了无MSAA和有MSAA的效果，可以看到没有MSAA时，蓝色三角形有明显锯齿，而加了MSAA之后，锯齿得到了显著改善。</p>
<p><img data-src="/images/games101/2-1.png" width = "800" height = "500" alt="无MSAA"/>
<img data-src="/images/games101/2-2.png" width = "800" height = "500" alt="有MSAA"/></p>
<h1 id="作业三">作业三</h1>
<p>本次作业要求实现：</p>
<ul>
<li>Normal、Color、Texture Interpolation;</li>
<li>Blinn-Phong Reflection Model / Texture Mapping / Bump Mapping /
Displacement Mapping;</li>
<li>Bilinear Interpolation.</li>
</ul>
<p>实际上只完成作业要求并不困难，更为重要的是要理解整套渲染的逻辑。因此，下面将按照渲染处理流程解析代码框架，在这个过程中完成作业。</p>
<h2 id="the-main-function-in-main.cpp">The <code>main</code> function in
<code>main.cpp</code></h2>
<h3 id="loading-triangles-from-.obj-file">Loading triangles from
<code>.obj</code> file</h3>
<p>整个程序从<code>main.cpp</code>的<code>main</code>函数开始执行，前几行读取了<code>.obj</code>模型文件，每个模型文件都包含了若干个三角形的每个顶点的位置坐标、法向量和纹理坐标。下面的代码把这些三角形存储为一个数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> mesh:Loader.LoadedMeshes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mesh.Vertices.<span class="built_in">size</span>();i+=<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Instantiate a new triangle</span></span><br><span class="line">            Triangle* t = <span class="keyword">new</span> <span class="built_in">Triangle</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Store the position</span></span><br><span class="line">                t-&gt;<span class="built_in">setVertex</span>(j,<span class="built_in">Vector4f</span>(mesh.Vertices[i+j].Position.X,mesh.Vertices[i+j].Position.Y,mesh.Vertices[i+j].Position.Z,<span class="number">1.0</span>));</span><br><span class="line">                <span class="comment">// Store the normal</span></span><br><span class="line">                t-&gt;<span class="built_in">setNormal</span>(j,<span class="built_in">Vector3f</span>(mesh.Vertices[i+j].Normal.X,mesh.Vertices[i+j].Normal.Y,mesh.Vertices[i+j].Normal.Z));</span><br><span class="line">                <span class="comment">// Store the texture coordinate</span></span><br><span class="line">                t-&gt;<span class="built_in">setTexCoord</span>(j,<span class="built_in">Vector2f</span>(mesh.Vertices[i+j].TextureCoordinate.X, mesh.Vertices[i+j].TextureCoordinate.Y));</span><br><span class="line">            &#125;</span><br><span class="line">            TriangleList.<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果你有兴趣，可以打开<code>OBJ_Loader.h</code>查看如何加载模型。</p>
<h3 id="building-a-rasterizer-and-setting-up-the-shader">Building a
rasterizer and setting up the shader</h3>
<p>下一步就是构建一个光栅化器，然后设置想要的Shader：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Instantiate the rasterizer</span></span><br><span class="line"><span class="function">rst::rasterizer <span class="title">r</span><span class="params">(<span class="number">700</span>, <span class="number">700</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> texture_path = <span class="string">&quot;hmap.jpg&quot;</span>;</span><br><span class="line">r.<span class="built_in">set_texture</span>(<span class="built_in">Texture</span>(obj_path + texture_path));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the default shader</span></span><br><span class="line">std::function&lt;Eigen::Vector3f(fragment_shader_payload)&gt; active_shader = phong_fragment_shader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    command_line = <span class="literal">true</span>;</span><br><span class="line">    filename = std::<span class="built_in">string</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following lines set different shaders according to the input parameter</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; std::<span class="built_in">string</span>(argv[<span class="number">2</span>]) == <span class="string">&quot;texture&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rasterizing using the texture shader\n&quot;</span>;</span><br><span class="line">        active_shader = texture_fragment_shader;</span><br><span class="line">        texture_path = <span class="string">&quot;spot_texture.png&quot;</span>;</span><br><span class="line">        r.<span class="built_in">set_texture</span>(<span class="built_in">Texture</span>(obj_path + texture_path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; std::<span class="built_in">string</span>(argv[<span class="number">2</span>]) == <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rasterizing using the normal shader\n&quot;</span>;</span><br><span class="line">        active_shader = normal_fragment_shader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; std::<span class="built_in">string</span>(argv[<span class="number">2</span>]) == <span class="string">&quot;phong&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rasterizing using the phong shader\n&quot;</span>;</span><br><span class="line">        active_shader = phong_fragment_shader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; std::<span class="built_in">string</span>(argv[<span class="number">2</span>]) == <span class="string">&quot;bump&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rasterizing using the bump shader\n&quot;</span>;</span><br><span class="line">        active_shader = bump_fragment_shader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; std::<span class="built_in">string</span>(argv[<span class="number">2</span>]) == <span class="string">&quot;displacement&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rasterizing using the bump shader\n&quot;</span>;</span><br><span class="line">        active_shader = displacement_fragment_shader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体每个shader的实现在<code>main.cpp</code>中，在下文会详解。在这里只需要知道每个shader都是用不同的方法给每个像素着色即可。具体使用的shader存储在<code>active_shader</code>中，它接受一个类型为<code>fragment_shader_payload</code>的参数，存储的是当前像素点的一些信息（比如颜色、在view_space中的位置、法向量、纹理坐标等，view_space的含义下文解释），并返回一个<code>Vector3</code>类型的变量，代表当前像素要着色的RGB颜色。</p>
<p>可以把<code>fragment_shader_payload</code>理解为当前待着色的像素的信息，充当一个存储区，而不同的shader就根据自身的算法从<code>fragment_shader_payload</code>里调取需要的信息进行着色计算，返回最终的颜色。</p>
<h3 id="constructing-mvp-transformation-and-draw-the-image">Constructing
MVP transformation and draw the image</h3>
<p><code>main</code>函数的最后几行就是构建MVP变换矩阵，然后调用光栅化器的<code>draw</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r.<span class="built_in">clear</span>(rst::Buffers::Color | rst::Buffers::Depth);</span><br><span class="line">r.<span class="built_in">set_model</span>(<span class="built_in">get_model_matrix</span>(angle));</span><br><span class="line">r.<span class="built_in">set_view</span>(<span class="built_in">get_view_matrix</span>(eye_pos));</span><br><span class="line">r.<span class="built_in">set_projection</span>(<span class="built_in">get_projection_matrix</span>(<span class="number">45.0</span>, <span class="number">1</span>, <span class="number">0.1</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">r.<span class="built_in">draw</span>(TriangleList);</span><br></pre></td></tr></table></figure>
<h3 id="the-projection-matrix">The projection matrix</h3>
<p>不要忘了把作业二中的projection matrix代码拷贝过来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Matrix4f <span class="title">get_projection_matrix</span><span class="params">(<span class="type">float</span> eye_fov, <span class="type">float</span> aspect_ratio, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Matrix4f projection;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d = <span class="number">1</span> / <span class="built_in">tan</span>((eye_fov/<span class="number">2</span>) * MY_PI / <span class="number">180</span>); </span><br><span class="line">    <span class="type">double</span> A = -(zFar + zNear) / (zFar - zNear); </span><br><span class="line">    <span class="type">double</span> B = <span class="number">-2</span> * zFar * zNear / (zFar - zNear); </span><br><span class="line">    projection &lt;&lt; d / aspect_ratio, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>, d, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, A, B, </span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="the-draw-function-in-rasterizer.cpp">The <code>draw</code>
function in <code>rasterizer.cpp</code></h2>
<p>在<code>main</code>函数中，我们已经准备好了每个三角形的信息、要用的着色器和MVP变换矩阵，下面就是要根据这些信息计算屏幕空间中每个像素的颜色。</p>
<h3 id="transform-each-vertex-into-the-view-space">Transform each vertex
into the view space</h3>
<p>由于上面的每个三角形中的顶点都是在世界坐标中，第一步要做的就是用MVP变换矩阵把它们转换到另外的空间中。</p>
<p>这里尤其需要注意的是，我们实际上有<strong>三个</strong>不同的空间，或者说坐标系：</p>
<ul>
<li>View space: 这是顶点经过MV变换后的坐标，点<span
class="math inline">\(p\)</span>经过MV变换后的点<span
class="math inline">\(VMp\)</span>（注意顺序）实际上<strong>位于相机的局部坐标系中（camera's
local space）</strong>，我们称之为view space。</li>
<li>Projection space: 这是顶点经过完整的MVP变换后的坐标，也即<span
class="math inline">\(p\to PVMp\)</span>，此时点<span
class="math inline">\(p\)</span>的深度值会被透视投影改变，所以<strong>此时的深度并不代表点在真实三维空间中的深度，而是为了模拟人眼效果做出的变换</strong>，这也就是为什么我们要保留点在view
space中的信息，因为在view space中的深度值才是点在真实世界中的值。</li>
<li>Screen space:
这是点经过视口变换后得到的坐标，此时点的深度值不再重要，我们只关心它的<span
class="math inline">\((x,y)\)</span>，也即在屏幕上的位置。</li>
</ul>
<p>值得注意的是，某原始三维空间（未经过任何变换）中的点，与它在view
space/projection space/screen
space中的点是能对应起来的，在计算的时候，要注意把它们当成一个整体考虑。比如原始三维空间中的点<span
class="math inline">\(p\)</span>，其在view space/projection space/screen
space中的点分别为<span
class="math inline">\(p&#39;,p&#39;&#39;,p&#39;&#39;&#39;\)</span>，那么就要把<span
class="math inline">\((p,p&#39;,p&#39;&#39;,p&#39;&#39;&#39;)\)</span>联系起来考虑，不要孤立地看任何一个点。</p>
<p>回到代码中，下面的代码首先得到了整个MVP变换矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix4f mvp = projection * view * model;</span><br></pre></td></tr></table></figure>
<p>而<code>draw</code>函数整体是一个大循环，对每个三角形进行计算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; t:TriangleList)</span><br><span class="line">&#123;</span><br><span class="line">    Triangle newtri = *t;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码把每个顶点变换到view space中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*      Compute `viewspace_pos`, which represents the camera&#x27;s local space coordinates without projection transformation  */</span></span><br><span class="line"><span class="comment">/*      This position will then be used for shading.                                                                      */</span></span><br><span class="line">        std::array&lt;Eigen::Vector4f, 3&gt; mm &#123;</span><br><span class="line">                (view * model * t-&gt;v[<span class="number">0</span>]),</span><br><span class="line">                (view * model * t-&gt;v[<span class="number">1</span>]),</span><br><span class="line">                (view * model * t-&gt;v[<span class="number">2</span>])</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        std::array&lt;Eigen::Vector3f, 3&gt; viewspace_pos;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">transform</span>(mm.<span class="built_in">begin</span>(), mm.<span class="built_in">end</span>(), viewspace_pos.<span class="built_in">begin</span>(), [](<span class="keyword">auto</span>&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> v.<span class="keyword">template</span> <span class="built_in">head</span>&lt;<span class="number">3</span>&gt;();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>此时<code>viewspace_pos</code>里存的就是三角形三个顶点在view
space中的坐标。</p>
<h3 id="transform-each-vertex-into-the-projection-space">Transform each
vertex into the projection space</h3>
<p>当然我们还需要把每个顶点转变到projection space中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*      Compute `v` with mvp transformation   */</span></span><br><span class="line">        Eigen::Vector4f v[] = &#123;</span><br><span class="line">                mvp * t-&gt;v[<span class="number">0</span>],</span><br><span class="line">                mvp * t-&gt;v[<span class="number">1</span>],</span><br><span class="line">                mvp * t-&gt;v[<span class="number">2</span>]</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>此时，<code>v</code>里存的就是三角形三个顶点在projection
space的坐标。更关键的是下面的几行代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*      Now `vec.w()` records the original `z` value before applying projection transformation    */</span></span><br><span class="line"><span class="comment">/*      Note that it is different from the formulation in Assignment 2                            */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; vec : v) &#123;</span><br><span class="line">            vec.<span class="built_in">x</span>() /= vec.<span class="built_in">w</span>();</span><br><span class="line">            vec.<span class="built_in">y</span>() /= vec.<span class="built_in">w</span>();</span><br><span class="line">            vec.<span class="built_in">z</span>() /= vec.<span class="built_in">w</span>();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在这里，每个顶点都除以其向量的<code>w</code>分量，使其得到正确的坐标，而这里的<code>w</code>，正是view
space中的<code>z</code>值，也就是经过MV变换后的深度值！此处没有对<code>w</code>分量归一化是因为后面插值时还需要用到view
space中的<code>z</code>值，也就是点在真实空间中的深度值。</p>
<h3 id="transform-the-normal-into-the-view-space">Transform the normal
into the view space</h3>
<p>既然顶点已经被变换到view
space中了，那么每个顶点的法向量也需要变换到<strong>view
space</strong>中，这可以用下面的代码描述：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*      Transform the world space normal vectors into camera&#x27;s local space coordinates.       */</span></span><br><span class="line"><span class="comment">/*      Need a little bit mathematics.                                                        */</span></span><br><span class="line">        Eigen::Matrix4f inv_trans = (view * model).<span class="built_in">inverse</span>().<span class="built_in">transpose</span>();</span><br><span class="line">        Eigen::Vector4f n[] = &#123;</span><br><span class="line">                inv_trans * <span class="built_in">to_vec4</span>(t-&gt;normal[<span class="number">0</span>], <span class="number">0.0f</span>),</span><br><span class="line">                inv_trans * <span class="built_in">to_vec4</span>(t-&gt;normal[<span class="number">1</span>], <span class="number">0.0f</span>),</span><br><span class="line">                inv_trans * <span class="built_in">to_vec4</span>(t-&gt;normal[<span class="number">2</span>], <span class="number">0.0f</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，法向量并不能简单像顶点那样直接进行MV变换，即乘以矩阵<span
class="math inline">\(VM\)</span>，而是乘了<span
class="math inline">\(((VM)^{-1})^\top\)</span>，推导如下：</p>
<p>假设变换前的法向量是<span
class="math inline">\(n\)</span>，它的任意切线是<span
class="math inline">\(v\)</span>，变换矩阵是<span
class="math inline">\(P=VM\)</span>，变换后的法线和切线分别是<span
class="math inline">\(n&#39;,v&#39;\)</span>，其中<span
class="math inline">\(v&#39;=Pv\)</span>，那么下面的式子成立：</p>
<p><span class="math display">\[n^\top v=n^\top(P^{-1}P)v=(n^\top
P^{-1})(Pv)=0\]</span> <span
class="math display">\[n&#39;^\top(Pv)=0\]</span></p>
<p>令上面两式相等，则有：</p>
<p><span class="math display">\[\left((n^\top
P^{-1})-n&#39;^\top\right)(Pv)=0\]</span></p>
<p>由于<span class="math inline">\(v\)</span>是任意切向量，所以有：</p>
<p><span class="math display">\[n&#39;^\top=n^\top P^{-1}\Rightarrow
n&#39;=((P^{-1})^\top)n=((VM)^{-1})^\top n\]</span></p>
<p>所以对法向量来说，要把它变换到view space，需要乘的矩阵是<span
class="math inline">\(((VM)^{-1})^\top\)</span>。</p>
<h3 id="apply-viewport-projection-and-store-infomation">Apply viewport
projection and store infomation</h3>
<p>最后只需要应用视口变换及存储上面计算的信息即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Viewport transformation</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; vert : v)</span><br><span class="line">&#123;</span><br><span class="line">    vert.<span class="built_in">x</span>() = <span class="number">0.5</span>*width*(vert.<span class="built_in">x</span>()+<span class="number">1.0</span>);</span><br><span class="line">    vert.<span class="built_in">y</span>() = <span class="number">0.5</span>*height*(vert.<span class="built_in">y</span>()+<span class="number">1.0</span>);</span><br><span class="line">    vert.<span class="built_in">z</span>() = vert.<span class="built_in">z</span>() * f1 + f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//screen space coordinates</span></span><br><span class="line">    newtri.<span class="built_in">setVertex</span>(i, v[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//view space normal</span></span><br><span class="line">    newtri.<span class="built_in">setNormal</span>(i, n[i].<span class="built_in">head</span>&lt;<span class="number">3</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newtri.<span class="built_in">setColor</span>(<span class="number">0</span>, <span class="number">148</span>,<span class="number">121.0</span>,<span class="number">92.0</span>);</span><br><span class="line">newtri.<span class="built_in">setColor</span>(<span class="number">1</span>, <span class="number">148</span>,<span class="number">121.0</span>,<span class="number">92.0</span>);</span><br><span class="line">newtri.<span class="built_in">setColor</span>(<span class="number">2</span>, <span class="number">148</span>,<span class="number">121.0</span>,<span class="number">92.0</span>);</span><br></pre></td></tr></table></figure>
<p>再回顾一下，<code>newtri.seetVertex(i, v[i])</code>存储的是screen
space的坐标，每个顶点的<span
class="math inline">\(w\)</span>分量则是view
space的深度值，也就是点在真实空间中的深度值。<code>newtri.setNormal(i, n[i].head&lt;3&gt;())</code>存储的是点在view
space中的法向量。</p>
<p>之后调用<code>rasterize_triangle(newtri, viewspace_pos)</code>给每个三角形光栅化和着色。注意这里既传入了<code>newtri</code>，也传入了<code>viewspace_pos</code>，这是因为我们需要顶点在真实空间中的坐标位置。</p>
<h2 id="the-rasterize_triangle-function-in-rasterizer.cpp">The
<code>rasterize_triangle</code> function in
<code>rasterizer.cpp</code></h2>
<p>函数<code>rasterize_triangle</code>是真正执行光栅化和着色的地方，主要需要实现每个像素的属性插值，并调用之前定义的shader去着色。</p>
<p>下面我仍然使用作业二的MSAA去实现，但是由于给的模型面数较少，所以使用MSAA与不使用MSAA区别不大，特此说明。</p>
<p>之后的所有代码都按照顺序实现在<code>rasterize_triangle</code>函数中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t, <span class="type">const</span> std::array&lt;Eigen::Vector3f, <span class="number">3</span>&gt;&amp; view_pos) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="define-variables-and-get-the-bounding-box">Define variables and
get the bounding box</h3>
<p>第一步是先定义一些需要的变量，找到当前三角形在screen
space中的bounding box：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// USed for MSAA</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> dx[<span class="number">4</span>] = &#123;<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.75</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.25</span>, <span class="number">0.75</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the bounding box</span></span><br><span class="line"><span class="type">int</span> x_min = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, x_max = -(<span class="number">1</span> &lt;&lt; <span class="number">5</span>), y_min = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, y_max = -(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.v[i].<span class="built_in">x</span>() &lt; x_min) x_min = t.v[i].<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">if</span> (t.v[i].<span class="built_in">x</span>() &gt; x_max) x_max = t.v[i].<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">if</span> (t.v[i].<span class="built_in">y</span>() &lt; y_min) y_min = t.v[i].<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (t.v[i].<span class="built_in">y</span>() &gt; y_max) y_max = t.v[i].<span class="built_in">y</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterate-each-pixel-and-sub-pixel">Iterate each pixel and
sub-pixel</h3>
<p>第二步是对每个像素，对里面的每个子像素进行操作。首先需要定义整体的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterate each pixel</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> x = x_min; x &lt;= x_max; ++x)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> y = y_min; y &lt;= y_max; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If set to `true`, the current pixel needs reshading</span></span><br><span class="line">        <span class="type">bool</span> need_reshading = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">float</span> pixel_depth = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">get_index</span>(x, y) * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(x + dx[i], y + dy[i], t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Do something for each sub-pixel if it&#x27;s inside the triangle</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (need_reshading)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">set_pixel</span>(<span class="built_in">Vector2i</span>(x, y), (frame_sample[index] + frame_sample[index + <span class="number">1</span>] + frame_sample[index + <span class="number">2</span>] + frame_sample[index + <span class="number">3</span>]) / <span class="number">4</span>);</span><br><span class="line">            depth_buf[<span class="built_in">get_index</span>(x, y)] = std::<span class="built_in">min</span> (depth_buf[<span class="built_in">get_index</span>(x, y)], pixel_depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们首先考虑每个像素。每个像素定义了一个布尔值<code>need_reshading</code>，它表示如果像素内部有小像素的颜色发生变化，那么大像素就需要重新着色，那就是把内部几个小像素（这里用了四个）的颜色值进行平均，这就是代码<code>set_pixel(Vector2i(x, y), ...);</code>做的事情。而<code>pixel_depth</code>则更新大像素的深度值。</p>
<p>为了使用MSAA，我们仍然需要像作业二一样另开两个数组去分别记录每个子像素的颜色和深度，记为<code>frame_sample</code>和<code>depth_sample</code>。</p>
<p>接下来就是要对每个在三角形内的子像素进行操作了。</p>
<h3 id="calculate-the-interpolated-depth">Calculate the interpolated
depth</h3>
<p>对每个在三角形内的子像素，首先需要计算它在screen
space中的重心坐标，然后利用重心坐标去算深度插值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Calculate the interpolated depth value `z_interpolated`</span></span><br><span class="line"><span class="keyword">auto</span> coefficients = <span class="built_in">computeBarycentric2D</span>(x + dx[i], y + dy[i], t.v);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> alpha, beta, gamma;</span><br><span class="line">std::<span class="built_in">tie</span>(alpha, beta, gamma) = coefficients;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Doing interpolation in the camera&#x27;s local space, i.e., before projection transformation</span></span><br><span class="line"><span class="comment">// The resulting `z_interpolated` is the interpolated depth after projection transformation</span></span><br><span class="line"><span class="type">float</span> Z = <span class="number">1.0</span> / (alpha / t.v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / t.v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / t.v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line"><span class="type">float</span> zp = alpha * t.v[<span class="number">0</span>].<span class="built_in">z</span>() / t.v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * t.v[<span class="number">1</span>].<span class="built_in">z</span>() / t.v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * t.v[<span class="number">2</span>].<span class="built_in">z</span>() / t.v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line"><span class="type">float</span> z_interpolated = zp * Z;</span><br></pre></td></tr></table></figure>
<p><code>computeBarycentric2D</code>是给定的代码不用处理，得到的<code>alpha</code>，<code>beta</code>和<code>gamma</code>就是三个顶点对应的重心坐标值。</p>
<p>后面三行代码需要注意！之前我们提到，三角形三个顶点向量的<code>w</code>分量实际上是三角形在view
space，也就是在真实空间中的深度值，那么在进行插值的时候，就需要用这个真实的深度值去计算得到当前像素点在view
space中的深度值，也就是这里的变量<code>Z</code>。</p>
<p>但是我们人眼看到的，实际上是在projection
space中的深度，也就是经过MVP变换后的深度，所以此时就可以把projection
space中的深度视为一种“属性”，应用<a
href="https://sulley.cc/2021/08/14/23/31/">这篇博客</a>中介绍的原理，插值得到当前像素点在projection
space中的深度，也就是<code>z_interpolated</code>。</p>
<p>实际上这个插值算法可以用于任何属性的插值而不仅仅是projection
space中的深度值，而原本的代码中的两个<code>interpolate</code>函数只是在屏幕空间中插值，是错误的，所以下面我首先对这两个<code>interpolate</code>函数进行修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Eigen::Vector3f <span class="title">interpolate</span><span class="params">(<span class="type">const</span> Triangle&amp; t, <span class="type">float</span> alpha, <span class="type">float</span> beta, <span class="type">float</span> gamma, <span class="type">const</span> Eigen::Vector3f&amp; vert1, <span class="type">const</span> Eigen::Vector3f&amp; vert2, <span class="type">const</span> Eigen::Vector3f&amp; vert3, <span class="type">float</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    return (alpha * vert1 + beta * vert2 + gamma * vert3) / weight;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">float</span> Z = <span class="number">1.0</span> / (alpha / t.v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / t.v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / t.v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">    Vector3f interpolated = alpha * vert1 / t.v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * vert2 / t.v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * vert3 / t.v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">    Vector3f interpolated_attribute = interpolated * Z / weight;</span><br><span class="line">    <span class="keyword">return</span> interpolated_attribute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Eigen::Vector2f <span class="title">interpolate</span><span class="params">(<span class="type">const</span> Triangle&amp; t, <span class="type">float</span> alpha, <span class="type">float</span> beta, <span class="type">float</span> gamma, <span class="type">const</span> Eigen::Vector2f&amp; vert1, <span class="type">const</span> Eigen::Vector2f&amp; vert2, <span class="type">const</span> Eigen::Vector2f&amp; vert3, <span class="type">float</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    auto u = (alpha * vert1[0] + beta * vert2[0] + gamma * vert3[0]);</span></span><br><span class="line"><span class="comment">    auto v = (alpha * vert1[1] + beta * vert2[1] + gamma * vert3[1]);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    u /= weight;</span></span><br><span class="line"><span class="comment">    v /= weight;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return Eigen::Vector2f(u, v);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">float</span> Z = <span class="number">1.0</span> / (alpha / t.v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / t.v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / t.v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">    Vector2f interpolated = alpha * vert1 / t.v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * vert2 / t.v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * vert3 / t.v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">    Vector2f interpolated_attribute = interpolated * Z / weight;</span><br><span class="line">    <span class="keyword">return</span> interpolated_attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为对比，原来的代码被注释掉了。现在插值得到的值，才是在真实空间中的值。</p>
<h3 id="get-other-interpolated-attributes">Get other interpolated
attributes</h3>
<p>最后只需要调用<code>interpolate</code>函数得到其他属性的插值即可。但首先要注意先判断一下深度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (z_interpolated &lt; depth_sample[index + i])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update depth of the current sub-pixel</span></span><br><span class="line">    depth_sample[index + i] = z_interpolated;</span><br><span class="line">    <span class="comment">// Set `need_reshading` to true</span></span><br><span class="line">    need_reshading = <span class="literal">true</span>;</span><br><span class="line">    pixel_depth = std::<span class="built_in">min</span>(pixel_depth, z_interpolated);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> interpolated_color = <span class="built_in">interpolate</span>(t, alpha, beta, gamma, t.color[<span class="number">0</span>], t.color[<span class="number">1</span>], t.color[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// `normal` is in the view space</span></span><br><span class="line">    <span class="keyword">auto</span> interpolated_normal = <span class="built_in">interpolate</span>(t, alpha, beta, gamma, t.normal[<span class="number">0</span>], t.normal[<span class="number">1</span>], t.normal[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">auto</span> interpolated_texcoords = <span class="built_in">interpolate</span>(t, alpha, beta, gamma, t.tex_coords[<span class="number">0</span>], t.tex_coords[<span class="number">1</span>], t.tex_coords[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// `interpolated_shadingcoords` is in the view space</span></span><br><span class="line">    <span class="keyword">auto</span> interpolated_shadingcoords = <span class="built_in">interpolate</span>(t, alpha, beta, gamma, view_pos[<span class="number">0</span>], view_pos[<span class="number">1</span>], view_pos[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the color/normal/texcoords/texture information into `fragment_shader_payload`</span></span><br><span class="line">    <span class="function">fragment_shader_payload <span class="title">payload</span> <span class="params">(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    payload.view_pos = interpolated_shadingcoords;</span><br><span class="line">    <span class="comment">// Instead of passing the triangle&#x27;s color directly to the frame buffer, pass the color to the shaders first to get the final color;</span></span><br><span class="line">    <span class="keyword">auto</span> pixel_color = <span class="built_in">fragment_shader</span>(payload);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the sub-pixel&#x27;s color</span></span><br><span class="line">    frame_sample[index + i] = pixel_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先更新了当前子像素的深度，并把<code>need_reshading</code>设为<code>true</code>。之后调用<code>interpolate</code>计算得到颜色值、法线值、纹理坐标和view
space中的深度值，然后把这所有的信息都存到<code>fragment_shader_payload</code>中，最后再调用选择的着色器<code>fragment_shader</code>计算当前子像素的颜色并存到<code>frame_sample</code>中。</p>
<p>到此为止，<code>rasterize_triangle</code>函数中的内容已经介绍完毕。</p>
<h2 id="try-calling-the-normal_fragment_shader">Try calling the
<code>normal_fragment_shader</code></h2>
<p>最后的问题就是我们调用的着色器<code>fragment_shader</code>究竟是怎样的。所有的shader都定义在<code>main.cpp</code>中，且原始代码已经给我们提供了现成的<code>normal_fragment_shader</code>了:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">normal_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Vector3f return_color = (payload.normal.<span class="built_in">head</span>&lt;<span class="number">3</span>&gt;().<span class="built_in">normalized</span>() + Eigen::<span class="built_in">Vector3f</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)) / <span class="number">2.f</span>;</span><br><span class="line">    Eigen::Vector3f result;</span><br><span class="line">    result &lt;&lt; return_color.<span class="built_in">x</span>() * <span class="number">255</span>, return_color.<span class="built_in">y</span>() * <span class="number">255</span>, return_color.<span class="built_in">z</span>() * <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>normal_fragment_shader</code>做的实际上就是把像素对应的法向量归一化到区间<span
class="math inline">\([0,1]\)</span>，然后再乘以<span
class="math inline">\(255\)</span>作为颜色值输出。</p>
<p>我们可以通过在终端输入<code>./Rasterizer output.png normal</code>查看结果，如下图所示：</p>
<p><img data-src="/images/games101/3-1.png" /></p>
<p>我们可以把指令中的<code>normal</code>参数替换为其他参数：</p>
<ul>
<li><code>texture</code>:
调用<code>texture_fragment_shader</code>，使用纹理坐标着色；</li>
<li><code>phong</code>:
调用<code>phong_fragment_shader</code>，使用blinn-Phong模型着色；</li>
<li><code>bump</code>：调用<code>bump_fragment_shader</code>，使用Bump
Mapping着色；</li>
<li><code>displacement</code>：调用<code>displacement_fragment_shader</code>，使用Displacement
Mapping着色。</li>
</ul>
<p>下面，我们就依次实现这几个着色器。</p>
<h2 id="implement-shaders">Implement shaders</h2>
<p>为了方便参考起见，先把blinn-Phong Reflection
Model的计算公式放在此处： <span
class="math display">\[L=k_aI_a+k_d(I/r^2)\max(0, n\cdot
l)+k_s(I/r^2)\max(0,n\cdot h)^p\]</span></p>
<h3 id="blinn-phong-shader">blinn-Phong shader</h3>
<p><code>phong_fragment_shader</code>的整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">phong_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Ambient coefficient, diffuse coefficient and specular coefficient,</span></span><br><span class="line">    <span class="comment">// each is represented as an RBG color</span></span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Light position and intensity in the view space</span></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cosine power</span></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the square distance r^2</span></span><br><span class="line">        <span class="type">float</span> square_distance = (light.position - point).<span class="built_in">squaredNorm</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the light direction, view direction, normal, and half vector</span></span><br><span class="line">        Vector3f l = (light.position - point).<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f v = (eye_pos - point).<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f h = (l + v).<span class="built_in">normalized</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// The light intensity</span></span><br><span class="line">        Vector3f I = light.intensity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the ambient light, diffuse light and specular light</span></span><br><span class="line">        Vector3f ambient_light = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line">        Vector3f diffuse_light = kd.<span class="built_in">cwiseProduct</span>(I / square_distance) * std::<span class="built_in">max</span>(<span class="number">0.0f</span>, n.<span class="built_in">dot</span>(l));</span><br><span class="line">        Vector3f specular_light = ks.<span class="built_in">cwiseProduct</span>(I / square_distance) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, n.<span class="built_in">dot</span>(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient_light + diffuse_light + specular_light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了环境光、漫反射和镜面反射的三个颜色系数<code>ka</code>，<code>kd</code>和<code>ks</code>，每个系数都是一个RBG值。</p>
<p>然后，定义了两个光线，包括它们的位置和强度。注意强度也是一个三维向量，对颜色的三个分量各有一个强度值。</p>
<p><code>amb_light_intensity</code>是环境光的强度，是一个与光线无关的定值；<code>eye_pos</code>是观测点；<code>p</code>用于镜面反射的余弦指数；<code>color</code>无用；<code>point</code>是当前像素在真实空间中的位置（着色点），<code>normal</code>是对应的法向量。</p>
<p>之后对每束光，依次计算光线到着色点的距离平方、光线方向、观测方向和半程向量，然后再用上述的公式计算得到环境光、漫反射光和镜面反射光即可。这里再说明下，光照强度<code>Intensity</code>可以理解为对颜色值的一种加权，强度越大，说明越突出当前颜色，或者说，该颜色被反射得越多；反之，则说明该颜色被吸收得越多。</p>
<p>此外，最后得到的<code>result_color</code>有可能某个分量的值大于1，理论上讲需要将其裁到<span
class="math inline">\([0,1]\)</span>的范围，但是后面用到的OpenCV可能会进行这个操作，所以这里就不进行裁剪了。</p>
<p>下图是blinn-Phong着色器得到的结果：</p>
<p><img data-src="/images/games101/3-2.png" /></p>
<h3 id="texture-shader">Texture shader</h3>
<p><code>texture_fragment_shader</code>的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (payload.texture)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The (u, v) texture coordinate of the current pixel</span></span><br><span class="line">    Vector2f tex_coord = payload.tex_coords;</span><br><span class="line">    <span class="comment">// Get the color from texture</span></span><br><span class="line">    return_color = payload.texture-&gt;<span class="built_in">getColor</span> (tex_coord[<span class="number">0</span>], tex_coord[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Eigen::Vector3f texture_color;</span><br><span class="line">texture_color &lt;&lt; return_color.<span class="built_in">x</span>(), return_color.<span class="built_in">y</span>(), return_color.<span class="built_in">z</span>();</span><br><span class="line">...</span><br><span class="line">Eigen::Vector3f kd = texture_color / <span class="number">255.f</span>;</span><br></pre></td></tr></table></figure>
<p>和<code>phong_fragment_shader</code>唯一的不同在于这里的漫反射系数<code>kd</code>是通过纹理上的颜色设置的，其他计算过程都完全一致。</p>
<p>下图是<code>texture_fragment_shader</code>得到的结果：</p>
<p><img data-src="/images/games101/3-3.png" /></p>
<h3 id="bump-shader">Bump shader</h3>
<p>Bump mapping之后会写一篇文章介绍，在这里直接搬运<a
href="https://www.yuque.com/gaoshanliushui-mbfny/sst4c5/hr2dgd">别人的代码</a>如下（注:
已更新对<a
href="https://sulley.cc/2022/10/12/18/39/">凹凸贴图的详解</a>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">bump_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">e</span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">sqrt</span>(n.<span class="built_in">x</span>() * n.<span class="built_in">x</span>() + n.<span class="built_in">z</span>() * n.<span class="built_in">z</span>());</span><br><span class="line">    <span class="function">Vector3f <span class="title">t</span> <span class="params">(n.x() * n.y() / d, d, n.z() * n.y() / d)</span></span>;</span><br><span class="line">    Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"></span><br><span class="line">    Matrix3f TBN;</span><br><span class="line">    TBN.<span class="built_in">col</span>(<span class="number">0</span>) = t, TBN.<span class="built_in">col</span>(<span class="number">1</span>) = b, TBN.<span class="built_in">col</span>(<span class="number">2</span>) = n;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>(), v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u + <span class="number">1.0f</span> / w, v).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line">    <span class="type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u, v + <span class="number">1.0f</span> / h).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">ln</span> <span class="params">(-dU, -dV, <span class="number">1</span>)</span></span>;</span><br><span class="line">    normal = TBN * ln;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = normal.<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是<code>bump_fragment_shader</code>得到的结果：</p>
<p><img data-src="/images/games101/3-4.png" /></p>
<h3 id="displacement-shader">Displacement shader</h3>
<p>同bump mapping，在这里直接搬运<a
href="https://www.yuque.com/gaoshanliushui-mbfny/sst4c5/hr2dgd">别人的代码</a>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">displacement_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kh = <span class="number">0.2</span>, kn = <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">sqrt</span>(n.<span class="built_in">x</span>() * n.<span class="built_in">x</span>() + n.<span class="built_in">z</span>() * n.<span class="built_in">z</span>());</span><br><span class="line">    <span class="function">Vector3f <span class="title">t</span> <span class="params">(n.x() * n.y() / d, d, n.z() * n.y() / d)</span></span>;</span><br><span class="line">    Vector3f b = n.<span class="built_in">cross</span>(t);</span><br><span class="line"></span><br><span class="line">    Matrix3f TBN;</span><br><span class="line">    TBN.<span class="built_in">col</span>(<span class="number">0</span>) = t, TBN.<span class="built_in">col</span>(<span class="number">1</span>) = b, TBN.<span class="built_in">col</span>(<span class="number">2</span>) = n;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = payload.tex_coords.<span class="built_in">x</span>(), v = payload.tex_coords.<span class="built_in">y</span>();</span><br><span class="line">    <span class="type">float</span> w = payload.texture-&gt;width, h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> dU = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u + <span class="number">1.0f</span> / w, v).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line">    <span class="type">float</span> dV = kh * kn * (payload.texture-&gt;<span class="built_in">getColor</span>(u, v + <span class="number">1.0f</span> / h).<span class="built_in">norm</span>() - payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">ln</span> <span class="params">(-dU, -dV, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    point += (kn * normal * payload.texture-&gt;<span class="built_in">getColor</span>(u, v).<span class="built_in">norm</span>());</span><br><span class="line">    normal = (TBN * ln).<span class="built_in">normalized</span>();</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the square distance r^2</span></span><br><span class="line">        <span class="type">float</span> square_distance = (light.position - point).<span class="built_in">squaredNorm</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the light direction, view direction, normal, and half vector</span></span><br><span class="line">        Vector3f l = (light.position - point).<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f v = (eye_pos - point).<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">        Vector3f h = (l + v).<span class="built_in">normalized</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// The light intensity</span></span><br><span class="line">        Vector3f I = light.intensity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the ambient light, diffuse light and specular light</span></span><br><span class="line">        Vector3f ambient_light = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line">        Vector3f diffuse_light = kd.<span class="built_in">cwiseProduct</span>(I / square_distance) * std::<span class="built_in">max</span>(<span class="number">0.0f</span>, n.<span class="built_in">dot</span>(l));</span><br><span class="line">        Vector3f specular_light = ks.<span class="built_in">cwiseProduct</span>(I / square_distance) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.0f</span>, n.<span class="built_in">dot</span>(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient_light + diffuse_light + specular_light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，displacement mapping基本上就是bump mapping +
blinn-phong，核心在于通过凹凸贴图改变真实空间中的位置<code>point</code>及其法向量<code>normal</code>，然后再应用常规的blinn-phong着色。</p>
<p>下图是<code>displacement_fragment_shader</code>得到的结果：</p>
<p><img data-src="/images/games101/3-5.png" /></p>
<p>通过上面的一系列代码，我们其实能知道，我们的着色频率是Phong
Shading，也就是<strong>逐像素着色</strong>，因为<code>fragment_shader_payload</code>里面存的是每个像素的信息。</p>
<h2 id="bonus-bilinear-interpolation">Bonus: bilinear interpolation</h2>
<p>本次作业的提高题是实现双线性纹理插值，需要首先实现一个新方法<code>Vector3f getColorBilinear(float u, float v)</code>，然后再在shader中调用。</p>
<p>直接在<code>Texture</code>类中增加方法<code>getColorBilinear</code>:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">getColorBilinear</span> <span class="params">(<span class="type">float</span> u, <span class="type">float</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = std::<span class="built_in">fmin</span>(<span class="number">1</span>, std::<span class="built_in">fmax</span>(u, <span class="number">0</span>));</span><br><span class="line">    v = std::<span class="built_in">fmin</span>(<span class="number">1</span>, std::<span class="built_in">fmax</span>(v, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The real (u, v) position on texture</span></span><br><span class="line">    <span class="keyword">auto</span> u_img = u * width;</span><br><span class="line">    <span class="keyword">auto</span> v_img = (<span class="number">1</span> - v) * height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the nearest four integer coordinates</span></span><br><span class="line">    <span class="type">float</span> u0 = std::<span class="built_in">round</span>(u_img - <span class="number">0.5f</span>);</span><br><span class="line">    <span class="type">float</span> u1 = std::<span class="built_in">round</span>(u_img + <span class="number">0.5f</span>); </span><br><span class="line">    <span class="type">float</span> v0 = std::<span class="built_in">round</span>(v_img - <span class="number">0.5f</span>);</span><br><span class="line">    <span class="type">float</span> v1 = std::<span class="built_in">round</span>(v_img + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The interpolation coefficient</span></span><br><span class="line">    <span class="type">float</span> s = (u_img - u0) / (u1 - u0);</span><br><span class="line">    <span class="type">float</span> t = (v_img - v0) / (v1 - v0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> c00 = image_data.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(v0, u0);</span><br><span class="line">    <span class="keyword">auto</span> c01 = image_data.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(v0, u1);</span><br><span class="line">    <span class="keyword">auto</span> c10 = image_data.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(v1, u0);</span><br><span class="line">    <span class="keyword">auto</span> c11 = image_data.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(v1, u1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> c0 = c00 + s * (c01 - c00);</span><br><span class="line">    <span class="keyword">auto</span> c1 = c10 + s * (c11 - c10);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> color = c0 + t * (c1 - c0);</span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector3f</span>(color[<span class="number">0</span>], color[<span class="number">1</span>], color[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到的图片和原来差不太多，有可能是因为纹理图的分辨率还是比较高的。我替换了一张低分辨率的纹理图，得到了下面的两张对比图。注意牛的后腿，显然能发现使用bilinear的更加平滑，这说明bilinear插值能对低分辨率纹理图有比较好的效果。</p>
<p><img data-src="/images/games101/3-6.png" width = "300" height = "400" alt="无Bilinear"/>
<img data-src="/images/games101/3-7.png" width = "300" height = "400" alt="有Bilinear"/></p>
<h2 id="summary-the-shading-pipeline">Summary: the shading pipeline</h2>
<p>最后来总结一下我们是怎样实现整个着色过程的：</p>
<ol type="1">
<li>读取信息：从模型文件中读取Mesh，再从Mesh中加载三角形，及其三个顶点的位置、法线和纹理坐标等其他信息；</li>
<li>顶点处理：分别将顶点变换到view space、projection space和screen
space中，保存其中需要的信息；</li>
<li>光栅化：对每个三角形中的每个像素，首先计算出它的重心坐标，然后通过矫正插值计算它在真实空间中的深度、法线、纹理坐标和颜色等信息，最后存入缓存区等待着色；</li>
<li>着色：最后根据不同的着色器按需取出缓存区的信息加以处理，得到一个最终的RGB值，这就是在屏幕上呈现的颜色。</li>
</ol>
<h1 id="作业四">作业四</h1>
<p>本次作业非常简单，只需要实现Bézier曲线。</p>
<h2 id="recursive-bézier-curve">Recursive bézier curve</h2>
<p>主要完成的就是两个函数，<code>bezier</code>——循环每个<code>t</code>画出整个曲线，<code>recursive_bezier</code>——对每个<code>t</code>求出对应的点，都不困难。</p>
<p><code>bezier</code>函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> epsilon = <span class="number">0.001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0.0f</span>; t &lt;= <span class="number">1.0f</span>; t += epsilon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> point = <span class="built_in">recursive_bezier</span> (control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>recursive_bezier</code>函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Only one point remaining</span></span><br><span class="line">    <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> control_points[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Evaluate new points</span></span><br><span class="line">        std::vector&lt;cv::Point2f&gt; new_points;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; control_points.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            new_points.<span class="built_in">push_back</span> (control_points[i] + t * (control_points[i + <span class="number">1</span>] - control_points[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursive_bezier</span> (new_points, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="using-the-bernstein-polynomial">Using the bernstein
polynomial</h2>
<p>代码框架提供的Bernstein多项式只能针对四个点，我们把它稍作修改使它支持任意多个点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">naive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make this function more generalized</span></span><br><span class="line">    <span class="type">int</span> n = points.<span class="built_in">size</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> point = cv::<span class="built_in">Point2f</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            point += <span class="built_in">bernstein_polynomial</span> (n - <span class="number">1</span>, i, t) * points[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>bernstein_polynomial</code>计算对应项的系数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">bernstein_polynomial</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">float</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursive_combination</span> (n, i) * std::<span class="built_in">pow</span> (t, i) * std::<span class="built_in">pow</span> (<span class="number">1</span> - t, n - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>recursive_combination</code>用于计算组合数<span
class="math inline">\(\tbinom{n}{i}\)</span>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recursive_combination</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursive_combination</span> (n, m - <span class="number">1</span>) * (n - m + <span class="number">1</span>) / m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了简单的组合数递推公式：</p>
<p><span
class="math display">\[\binom{n}{m}=\binom{n}{m-1}\cdot\frac{n-m+1}{m}\]</span></p>
<p>随便画一画，结果是正确的：</p>
<p><img data-src="/images/games101/4-1.png" /></p>
<h2 id="bonus-antialiasing">Bonus: antialiasing</h2>
<p>根据作业提示，在着色一个像素的时候，还要根据周围八个像素到当前点的距离去着色这八个点。我们把<code>bezier</code>稍作修改即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> epsilon = <span class="number">0.001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0.0f</span>; t &lt;= <span class="number">1.0f</span>; t += epsilon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> point = <span class="built_in">recursive_bezier</span> (control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The actual shading point (x,y)</span></span><br><span class="line">        <span class="type">int</span> x = point.x;</span><br><span class="line">        <span class="type">int</span> y = point.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is used to normalize the color</span></span><br><span class="line">        <span class="type">float</span> normalization = <span class="number">3.0f</span> / std::<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For each adjacent pixel</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dx = <span class="number">-1</span>; dx &lt;= <span class="number">1</span>; ++dx)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; ++dy)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// Should be within the bound</span></span><br><span class="line">                <span class="keyword">if</span> (x + dx &gt;= <span class="number">700</span> || x + dx &lt; <span class="number">0</span> || y + dy &gt;= <span class="number">700</span> || y + dy &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Calculate the distance to the actual shading point</span></span><br><span class="line">                <span class="type">float</span> distance = cv::<span class="built_in">norm</span>((point - cv::<span class="built_in">Point2f</span>(x + dx + <span class="number">0.5</span>, y + dy + <span class="number">0.5</span>)));</span><br><span class="line">                <span class="comment">// Normalize according to the distance</span></span><br><span class="line">                <span class="type">float</span> ratio = <span class="number">1</span> - distance / normalization;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Shading</span></span><br><span class="line">                window.<span class="built_in">at</span>&lt;cv::Vec3b&gt; (point.y + dy, point.x + dx)[<span class="number">1</span>] = std::<span class="built_in">fmax</span> (window.<span class="built_in">at</span>&lt;cv::Vec3b&gt; (point.y + dy, point.x + dx)[<span class="number">1</span>], <span class="number">255</span> * ratio);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是我们对求出来的距离<code>distance</code>进行了归一化，归一化系数<code>normalization</code>是当前着色点到它相邻点的最大距离，也就是<span
class="math inline">\(3/\sqrt{2}\)</span>。</p>
<p>反走样前后对比如下：</p>
<p><img data-src="/images/games101/4-2.png" width = "800" height = "400" alt="无反走样"/>
<img data-src="/images/games101/4-3.png" width = "800" height = "400" alt="有反走样"/></p>
<h1 id="作业五">作业五</h1>
<p>本次作业也非常简单，主要是实现光线投射和光线与三角形相交。</p>
<h2 id="framework">Framework</h2>
<p>还是先来大致梳理一下代码框架。</p>
<p>程序从<code>main.cpp</code>开始，首先创建了两个球体<code>sph1</code>和<code>sph2</code>，然后创建了两个三角形，最后创建了两个光源。渲染流程从<code>r.Render(scene)</code>开始。</p>
<p>在开始介绍<code>Render</code>函数之前，先介绍几个接下来要用到的函数。</p>
<p>首先是代码中的<code>reflect</code>函数，它接受一个单位向量<code>I</code>和一个法向量<code>N</code>，返回<code>I</code>关于法向量所定义的平面的镜面反射向量。</p>
<p>第二，是函数<code>refract</code>，它根据<a
href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell's
law</a>计算入射光进入某物体后的折射光。它接受三个参数：<code>I</code>是入射光，<code>N</code>是入射点的法向量，<code>ior</code>是折射系数。具体数学就不多展开了。</p>
<p>第三，函数<code>fresnel</code>根据<a
href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel
equation</a>计算反射率。它接受三个参数：<code>I</code>是入射光，<code>N</code>是入射点的法向量，<code>ior</code>是折射系数。</p>
<p>第四，<code>trace</code>函数求与给定光线发生碰撞的第一个物体。它接受三个参数：<code>orig</code>是光源位置，<code>dir</code>是光线方向，<code>objects</code>是所有待检测的物体。它返回一个存储碰撞信息的结构体<code>hit_payload</code>，主要是光线长度<code>t</code>和碰撞物体<code>hit_obj</code>。</p>
<p>第五，是最关键的<code>castRay</code>函数。它主要做的事情就是它从光源位置<code>orig</code>以方向<code>dir</code>射出一条光线，打到一个碰撞点<code>hitPoint</code>上，又从该点形成一条折射光线和一条反射光线，把这两条光线收到的颜色通过<code>fresnel</code>加起来，就是<code>hitPoint</code>这个点上的颜色<code>hitColor</code>。上述操作递归进行，直到最大深度<code>maxDepth</code>。</p>
<p>所有材质分为三种：</p>
<ul>
<li>REFLECTION_AND_REFRACTION:
透明的，既会反射也会折射，它本身没有颜色，表面的颜色来自反射和折射光携带的颜色；</li>
<li>REFLECTION：纯反射材质，它的颜色来自反射光的颜色；</li>
<li>DIFFUSE_AND_GLOSSY：它本身有颜色，使用Phong Shading
Model计算颜色。在这里，遍历场景中的所有光源，判断对当前光源而言着色点是否在阴影里，如果不在，则计算漫反射光照和镜面反射光照。</li>
</ul>
<p>现在回到<code>Render</code>函数。它一开始创建了<code>framebuffer</code>，用于记录每个像素的颜色值，然后对每个像素，从屏幕空间投射出一条射线，通过上面的<code>castRay</code>计算得到当前像素的颜色。最后再把这张图存下来。</p>
<h2 id="render">Render</h2>
<p>我们唯一需要实现的就是如何从屏幕空间投射一条射线。回顾我们之前相机的MVP变换：</p>
<ul>
<li>Model：变换空间中的物体，这里不涉及；</li>
<li>View：视图变换，即把相机放到原点，相机看向<span
class="math inline">\(-z\)</span>方向，这里只需要改变<code>eye_pos</code>，那么View矩阵就是
<span class="math display">\[V=\begin{bmatrix}
      1 &amp; 0 &amp; 0 &amp; -\mathbf{e}_x\\
      0 &amp; 1 &amp; 0 &amp; -\mathbf{e}_y\\
      0 &amp; 0 &amp; 1 &amp; -\mathbf{e}_z\\
      0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}\]</span></li>
<li>Perspective：透视投影变换是 <span class="math display">\[
  P=\begin{bmatrix}
      1/r &amp; 0 &amp; 0 &amp; 0\\
      0 &amp; 1/t &amp; 0 &amp; 0\\
      0 &amp; 0 &amp; 2/(n-f) &amp; 0\\
      0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}\begin{bmatrix}
      n &amp; 0 &amp; 0 &amp; 0\\
      0 &amp; n &amp; 0 &amp; 0\\
      0 &amp; 0 &amp; n+f &amp; -nf\\
      0 &amp; 0 &amp; 1 &amp; 0
  \end{bmatrix}
  \]</span></li>
</ul>
<p>最后还有个视口变换：</p>
<p><span class="math display">\[T=\begin{bmatrix}
    w/2 &amp; 0 &amp; 0 &amp; w/2\\
    0 &amp; h/2 &amp; 0 &amp; h/2\\
    0 &amp; 0 &amp; 1 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\]</span></p>
<p>所以，对于空间中的一个<span
class="math inline">\((x,y,z,1)\)</span>，在经过上述变换后最终的点是：</p>
<p><span class="math display">\[
\begin{aligned}
    x&amp;\mapsto\frac{w}{2}\left(\frac{n}{r}(x-\mathbf{e}_x)+1\right)\\
    y&amp;\mapsto\frac{h}{2}\left(\frac{n}{t}(y-\mathbf{e}_y)+1\right)
\end{aligned}
\]</span></p>
<p>由于我们不关注<span
class="math inline">\(z\)</span>，所以不考虑它的值。如此一来，对于屏幕空间中的一个点<span
class="math inline">\((x&#39;,y&#39;)\in[0,w]\times[0,h]\)</span>，我们可以把它映射回三维空间中的点（同样不考虑<span
class="math inline">\(z\)</span>）：</p>
<p><span class="math display">\[
\begin{aligned}
    x&#39;&amp;\mapsto\left(\frac{2x&#39;}{w}-1\right)\frac{r}{n}+\mathbf{e}_x=x&#39;&#39;+\mathbf{e}_x\\
    y&#39;&amp;\mapsto\left(\frac{2y&#39;}{h}-1\right)\frac{t}{n}+\mathbf{e}_y=y&#39;&#39;+\mathbf{e}_y
\end{aligned}
\]</span></p>
<p>其中<span
class="math inline">\(\dfrac{r}{n}=\tan(\text{fov}/2)\cdot\text{aspectRatio},
\dfrac{t}{n}=\tan(\text{fov}/2)\)</span>。</p>
<p>所以，此时的点坐标为在<span
class="math inline">\((x&#39;&#39;+\mathbf{e}_x,y&#39;&#39;+\mathbf{e}_y,n+\mathbf{e}_z)\)</span>，光线方向就是从相机位置到这个点，正好就是<span
class="math inline">\((x&#39;&#39;,y&#39;&#39;,n)\)</span>。所以<code>eye_pos</code>对于求光线而言并没有作用。</p>
<p>所以，我们立刻能写出下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generate primary ray direction</span></span><br><span class="line"><span class="type">float</span> x = (<span class="number">2</span> * (i + <span class="number">0.5</span>) / scene.width - <span class="number">1</span>) * scale * imageAspectRatio;</span><br><span class="line"><span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5</span>) / scene.height) * scale;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t forget to normalize this direction!</span></span><br><span class="line">Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">-1</span>)); </span><br></pre></td></tr></table></figure>
<p>上面的代码中假定了近平面为<span
class="math inline">\(-1\)</span>。注意<span
class="math inline">\(y\)</span>取了负，这是因为屏幕空间是以左上角为原点，向下方向为<span
class="math inline">\(y\)</span>轴正方向的，所以最后得到的<span
class="math inline">\(y\)</span>值要取负。</p>
<h2 id="ray-intersect-with-triangle">Ray intersect with triangle</h2>
<h3 id="proof-of-the-moller-trumbore-algorithm">Proof of the
Moller-Trumbore algorithm</h3>
<p>这里使用的算法是Moller-Trumbore算法判断光线与三角形相交。即假设光源为<span
class="math inline">\(\mathbf{O}\)</span>，光照射方向为<span
class="math inline">\(\mathbf{D}\)</span>，三角形三个点为<span
class="math inline">\(\mathbf{A}\)</span>,<span
class="math inline">\(\mathbf{B}\)</span>,<span
class="math inline">\(\mathbf{C}\)</span>。如果光线与三角形有交点，那么就可以用重心坐标表示：</p>
<p><span
class="math display">\[\mathbf{O}+t\mathbf{D}=(1-u-v)\mathbf{A}+u\mathbf{B}+v\mathbf{C}\]</span></p>
<p>这个方程的解如下：</p>
<p><span class="math display">\[
\begin{bmatrix}
    t\\
    u\\
    v
\end{bmatrix}=\frac{1}{\mathbf{S}_1\cdot\mathbf{E}_1}\begin{bmatrix}
    \mathbf{S}_2\cdot\mathbf{E}_2\\
    \mathbf{S}_1\cdot\mathbf{S}\\
    \mathbf{S}_2\cdot\mathbf{D}
\end{bmatrix}
\]</span></p>
<p>其中，<span
class="math inline">\(\mathbf{S}=\mathbf{O}-\mathbf{A},\mathbf{E}_1=\mathbf{B}-\mathbf{A},\mathbf{E}_2=\mathbf{C}-\mathbf{A},\mathbf{S}_1=\mathbf{D}\times
\mathbf{E}_2,\mathbf{S}_2=\mathbf{S}\times \mathbf{E}_1\)</span>。</p>
<p>我们首先来证明一下这个结论。</p>
<p>对第一个方程稍加整理，就能得到：</p>
<p><span
class="math display">\[\mathbf{O}-\mathbf{A}=-t\mathbf{D}+u(\mathbf{B}-\mathbf{A})+v(\mathbf{C}-\mathbf{A})\]</span></p>
<p>写成矩阵形式，有：</p>
<p><span class="math display">\[\mathbf{O}-\mathbf{A}=\begin{bmatrix}
    -\mathbf{D} &amp; \mathbf{B}-\mathbf{A} &amp; \mathbf{C}-\mathbf{A}
\end{bmatrix}\begin{bmatrix}
    t\\
    u\\
    v
\end{bmatrix}\]</span></p>
<p>记<span
class="math inline">\(\mathbf{S}=\mathbf{O}-\mathbf{A},\mathbf{E}_1=\mathbf{B}-\mathbf{A},\mathbf{E}_2=\mathbf{C}-\mathbf{A}\)</span>。则有：</p>
<p><span class="math display">\[\mathbf{S}=\begin{bmatrix}
    -\mathbf{D} &amp; \mathbf{E}_1 &amp; \mathbf{E}_2
\end{bmatrix}\begin{bmatrix}
    t\\
    u\\
    v
\end{bmatrix}\]</span></p>
<p>显然，这是一个线性方程组，而求解线性方程组最常用的方法是<a
href="https://en.wikipedia.org/wiki/Cramer%27s_rule">Cramer's
Rule</a>。所以，上述线性方程组的解我们可以写出来是：</p>
<p><span class="math display">\[
\begin{bmatrix}
    t\\
    u\\
    v
\end{bmatrix}=\frac{1}{\begin{vmatrix}
    -\mathbf{D} &amp; \mathbf{E}_1 &amp; \mathbf{E}_2
\end{vmatrix}}\begin{bmatrix}
    \begin{vmatrix} \mathbf{S} &amp; \mathbf{E}_1 &amp; \mathbf{E}_2
\end{vmatrix}\\
    \begin{vmatrix} -\mathbf{D} &amp; \mathbf{S} &amp; \mathbf{E}_2
\end{vmatrix}\\
    \begin{vmatrix} -\mathbf{D} &amp; \mathbf{E}_1 &amp; \mathbf{S}
\end{vmatrix}
\end{bmatrix}
\]</span></p>
<p>对于三阶行列式<span class="math inline">\(\begin{vmatrix}\mathbf{A}
&amp; \mathbf{B} &amp;
\mathbf{C}\end{vmatrix}\)</span>我们不难得到它与叉乘/点乘的关系如下:</p>
<p><span class="math display">\[\begin{vmatrix}\mathbf{A} &amp;
\mathbf{B} &amp; \mathbf{C}\end{vmatrix}=-(\mathbf{A}\times
\mathbf{C})\cdot \mathbf{B}=(\mathbf{A}\times \mathbf{B})\cdot
\mathbf{C}\]</span></p>
<p>所以，我们能够对上式做最后的化简：</p>
<p><span class="math display">\[
\begin{bmatrix}
    t\\
    u\\
    v
\end{bmatrix}=\frac{1}{(\mathbf{D}\times
\mathbf{E}_2)\cdot\mathbf{E}_1}\begin{bmatrix}
    (\mathbf{S}\times \mathbf{E}_1)\cdot\mathbf{E}_2\\
    (\mathbf{D}\times \mathbf{E}_2)\cdot\mathbf{S}\\
    (\mathbf{S}\times \mathbf{E}_1)\cdot\mathbf{D}
\end{bmatrix}
\]</span></p>
<p>最后再令<span class="math inline">\(\mathbf{S}_1=\mathbf{D}\times
\mathbf{E}_2,\mathbf{S}_2=\mathbf{S}\times
\mathbf{E}_1\)</span>，就得到了最开始的结果。</p>
<h3 id="the-raytriangleintersect-function-in-triangle.hpp">The
<code>rayTriangleIntersect</code> function in
<code>Triangle.hpp</code></h3>
<p>根据上面的公式，我们很容易能写出下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rayTriangleIntersect</span><span class="params">(<span class="type">const</span> Vector3f&amp; v0, <span class="type">const</span> Vector3f&amp; v1, <span class="type">const</span> Vector3f&amp; v2, <span class="type">const</span> Vector3f&amp; orig, <span class="type">const</span> Vector3f&amp; dir, <span class="type">float</span>&amp; tnear, <span class="type">float</span>&amp; u, <span class="type">float</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3f S = orig - v0;</span><br><span class="line">    Vector3f E1 = v1 - v0;</span><br><span class="line">    Vector3f E2 = v2 - v0;</span><br><span class="line">    Vector3f S1 = <span class="built_in">crossProduct</span> (dir, E2);</span><br><span class="line">    Vector3f S2 = <span class="built_in">crossProduct</span> (S, E1);</span><br><span class="line">    <span class="type">float</span> S1_dot_E1 = <span class="built_in">dotProduct</span> (S1, E1);</span><br><span class="line"></span><br><span class="line">    tnear = <span class="built_in">dotProduct</span> (S2, E2) / S1_dot_E1;</span><br><span class="line">    u = <span class="built_in">dotProduct</span> (S1, S) / S1_dot_E1;</span><br><span class="line">    v = <span class="built_in">dotProduct</span> (S2, dir) / S1_dot_E1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tnear &gt; <span class="number">0</span> &amp;&amp; u &gt;= <span class="number">0</span> &amp;&amp; u &lt;= <span class="number">1</span> &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt;= <span class="number">1</span> &amp;&amp; u + v &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后生成的图是：</p>
<p><img data-src="/images/games101/5-1.png" /></p>
<h1 id="作业六">作业六</h1>
<p>本节课主要实现Bounding Volume Hierarchy (BVH) 和 Surface Area
Heuristic (SAH)
加速结构。代码框架整体上和前一次作业一样，但有些部件进一步进行了拆分。因为上一次作业我完整没有分析代码框架，这次作业按照调用顺序进行分析，在这个过程中完成作业。</p>
<h2 id="overview-of-main.cpp">Overview of <code>main.cpp</code></h2>
<p>还是从<code>main.cpp</code>开始介绍，作为整个程序的入口。</p>
<h3 id="initialize-the-scene-add-model-and-light">Initialize the scene,
add model and light</h3>
<p>在开头的几行，代码初始化了一个场景，并加载了模型和光照:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Scene <span class="title">scene</span><span class="params">(<span class="number">1280</span>, <span class="number">960</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MeshTriangle <span class="title">bunny</span><span class="params">(<span class="string">&quot;../models/bunny/bunny.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">scene.<span class="built_in">Add</span>(&amp;bunny);</span><br><span class="line">scene.<span class="built_in">Add</span>(std::<span class="built_in">make_unique</span>&lt;Light&gt;(<span class="built_in">Vector3f</span>(<span class="number">-20</span>, <span class="number">70</span>, <span class="number">20</span>), <span class="number">1</span>));</span><br><span class="line">scene.<span class="built_in">Add</span>(std::<span class="built_in">make_unique</span>&lt;Light&gt;(<span class="built_in">Vector3f</span>(<span class="number">20</span>, <span class="number">70</span>, <span class="number">20</span>), <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="initialize-bvh-and-renderer">Initialize BVH and renderer</h3>
<p>下面，对场景构造了BVH，并执行整个场景的渲染。BVH和renderer是本次作业的核心。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">scene.<span class="built_in">buildBVH</span>();</span><br><span class="line"></span><br><span class="line">Renderer r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">r.<span class="built_in">Render</span>(scene);</span><br><span class="line"><span class="keyword">auto</span> stop = std::chrono::system_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>
<p>下面来看下场景包含什么内容。</p>
<h2 id="scene.hpp-and-scene.cpp"><code>Scene.hpp</code> and
<code>Scene.cpp</code></h2>
<h3 id="variables-and-methods">Variables and methods</h3>
<p><code>Scene.hpp</code>和<code>Scene.cpp</code>定义了关于场景的high-level参数，包括长宽、fov、背景色、光线弹射的最大深度、场景的BVH、场景中的物体和光源，以及一些必要的函数。</p>
<p>一些关键的函数如下：</p>
<ul>
<li><code>buildBVH</code>: 构建场景的BVH，下面详解。</li>
<li><code>intersect</code>:
使用BVH计算与给定光线相交的物体，返回相交点的信息（一个类型为<code>Intersection</code>的结构体），下面详解。</li>
<li><code>castRay</code>:
通过光线追踪递归计算某一点的颜色值，与上次作业一样。</li>
<li><code>trace</code>:
找到与光线碰撞的最近物体及碰撞点信息，与上次作业一样。</li>
<li><code>reflect</code>: 计算反射光线。</li>
<li><code>refract</code>: 计算折射光线。</li>
<li><code>fresnel</code>: 根据Fresnel equation计算反射率。</li>
</ul>
<h3 id="scenebuildbvh-and-bvhaccel"><code>Scene::buildBVH</code> and
<code>BVHAccel</code></h3>
<p><code>Scene::buildBVH</code>函数为整个场景构建BVH：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::buildBVH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; - Generating BVH...\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;bvh = <span class="keyword">new</span> <span class="built_in">BVHAccel</span>(objects, <span class="number">1</span>, BVHAccel::SplitMethod::NAIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是通过创建一个<code>BVHAccel</code>类对象实现的，它接受三个参数：场景中的所有物体<code>primitives</code>，叶子结点最多物体数量<code>maxPrimsInNode</code>，和使用的构造方法<code>splitMethod</code>。构造方法如果是<code>NAIVE</code>则使用中间物体构造BVH，如果是<code>SAH</code>就使用提高题里的SAH构建BVH。这个对象内最终赋值的是一个<code>BVHBuildNode*</code>类型的<code>root</code>变量，表示这个构造的BVH树的根节点。</p>
<p>进入到构造函数内，我们发现它实际上是通过调用<code>BVHAccel::recursiveBuild</code>递归地构建BVH的。这个函数接受一个<code>std::vector&lt;Object*&gt;</code>作为参数，并返回一个<code>BVHBuildNode*</code>类型对象，表示当前的BVH结点。每个<code>BVHBuildNode</code>对象包含一个三维包围盒<code>Bound3</code>，一个同类型的左结点和右结点，还有一个<code>Object*</code>对象，只不过这个<code>Object*</code>只有在当前结点最只包含一个<code>Object</code>时才会被赋值，否则就不会被赋值。</p>
<p>下面开始介绍<code>recursiveBuild</code>函数。一开始首先初始化了一个默认的<code>BVHBuildNode</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BVHBuildNode* node = <span class="keyword">new</span> <span class="built_in">BVHBuildNode</span>();</span><br></pre></td></tr></table></figure>
<p>然后，遍历所有物体，将所有物体的包围盒合并起来，得到一个包含所有物体的大的包围盒（但实际上这里计算得到的包围盒没有用到，因为每个结点的包围盒可以递归通过求左右子结点包围盒的并集得到）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bounds3 bounds;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    bounds = <span class="built_in">Union</span>(bounds, objects[i]-&gt;<span class="built_in">getBounds</span>());</span><br></pre></td></tr></table></figure>
<p>如果给定的物体只有一个，那么当前结点就是个叶子结点，给<code>BVHBuildNode</code>的所有变量赋值，并返回该结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Create leaf _BVHBuildNode_</span></span><br><span class="line">    node-&gt;bounds = objects[<span class="number">0</span>]-&gt;<span class="built_in">getBounds</span>();</span><br><span class="line">    node-&gt;object = objects[<span class="number">0</span>];</span><br><span class="line">    node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果给定的物体有两个，那么就把这两个物体分开分别作为左右子结点即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">    node-&gt;left = <span class="built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="number">0</span>]&#125;);</span><br><span class="line">    node-&gt;right = <span class="built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="number">1</span>]&#125;);</span><br><span class="line"></span><br><span class="line">    node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里本结点的<code>object</code>并没有被赋值，因为它里面实际上包含了不止一个物体。</p>
<p>如果当前结点包含多于两个物体，那么就按照一定策略划分左右子结点。具体策略是，根据所有物体的包围盒的中心构造一个大的包围盒，然后检查这个大的包围盒在哪一个维度最长，选取最长的那个维度对所有物体进行划分，如下面的代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bounds3 centroidBounds;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    centroidBounds =</span><br><span class="line">        <span class="built_in">Union</span>(centroidBounds, objects[i]-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>());</span><br><span class="line"><span class="type">int</span> dim = centroidBounds.<span class="built_in">maxExtent</span>();</span><br><span class="line"><span class="keyword">switch</span> (dim) &#123;</span><br><span class="line"><span class="comment">// Split according to the x-axis</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x &lt;</span><br><span class="line">                f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// Split according to the y-axis</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y &lt;</span><br><span class="line">                f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// Split according to the z-axis</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z &lt;</span><br><span class="line">                f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对所有的物体排序之后，数组左侧的物体递归地构建BVH树，并将返回的结点作为当前结点的左子结点；右侧同理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + (objects.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> leftshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line"><span class="keyword">auto</span> rightshapes = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftshapes.<span class="built_in">size</span>() + rightshapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">node-&gt;left = <span class="built_in">recursiveBuild</span>(leftshapes);</span><br><span class="line">node-&gt;right = <span class="built_in">recursiveBuild</span>(rightshapes);</span><br><span class="line"></span><br><span class="line">node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br></pre></td></tr></table></figure>
<p>通过上面这种递归的方式，我们能很轻松地构建一个BVH树，树的根节点就是<code>root</code>。</p>
<h3 id="sceneintersect"><code>Scene::intersect</code></h3>
<p><code>Scene::intersect</code>也是通过调用BVH树的<code>Intersect</code>方法实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Intersection <span class="title">Scene::intersect</span><span class="params">(<span class="type">const</span> Ray &amp;ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bvh-&gt;<span class="built_in">Intersect</span>(ray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>BVHAccel::Intersect</code>则是调用<code>BVHAccel::getIntersection</code>方法实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Intersection <span class="title">BVHAccel::Intersect</span><span class="params">(<span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Intersection isect;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> isect;</span><br><span class="line">    isect = BVHAccel::<span class="built_in">getIntersection</span>(root, ray);</span><br><span class="line">    <span class="keyword">return</span> isect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="implementing-bvhaccelgetintersection">Implementing
<code>BVHAccel::getIntersection</code></h3>
<p>这里的<code>BVHAccel::getIntersection</code>就是我们要实现的方法，它的核心思路是从BVH根节点开始遍历整棵树，直到某个叶子结点找到与光线相交的物体，或者找不到与光线相交的物体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ray is outside the bounding box</span></span><br><span class="line">    Vector3f invDir = ray.direction_inv;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; disIsNeg = &#123;<span class="built_in">int</span>(ray.direction.x &gt; <span class="number">0</span>), <span class="built_in">int</span>(ray.direction.y &gt; <span class="number">0</span>), <span class="built_in">int</span>(ray.direction.z &gt; <span class="number">0</span>)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span> (ray, invDir, disIsNeg))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Intersection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node is a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node is an inner node</span></span><br><span class="line">    Intersection leftIntersect = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    Intersection rightIntersect = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    <span class="keyword">return</span> leftIntersect.distance &lt; rightIntersect.distance ? leftIntersect : rightIntersect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要稍加说明的是，类型为<code>MeshTriangle</code>的物体包含了很多个<code>Triangle</code>，但是它本身被视为一个<code>Object</code>对象，所以在<code>main.cpp</code>中我们加载的实际上是一个<strong>单个</strong><code>MeshTriangle</code>物体，这个物体内部包含了很多三角形。那么此处调用<code>node-&gt;object-&gt;getIntersection(ray)</code>实际上调用的是<code>MeshTriangle::getIntersection</code>，而这行代码又调用了MeshTriangle内部的另一个<code>bvh-&gt;Intersect</code>函数。所以实际上整个程序执行期间有两个BVH，一个是整个场景的BVH，而另一个是这个MeshTriangle内部的BVH。当我们想要在场景的BVH中检测MeshTriangle与光线的碰撞时，实际上又进入到了MeshTriangle内部的BVH，去检查与里面哪个三角形相交。这一点需要说明下。</p>
<p>上面我们调用了包围盒的函数<code>node-&gt;bounds.IntersectP</code>，用来判断某个光线是否和包围盒相交，我们需要实现这个函数。</p>
<h3 id="implementing-bounds3intersectp">Implementing
<code>Bounds3::IntersectP</code></h3>
<p><code>Bounds3::IntersectP</code>函数判断一条光线是否与一个包围盒相交，这可以用下面的代码描述：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Bounds3::IntersectP</span><span class="params">(<span class="type">const</span> Ray&amp; ray, <span class="type">const</span> Vector3f&amp; invDir,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&amp; dirIsNeg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3f t_min = (pMin - ray.origin) * invDir;</span><br><span class="line">    Vector3f t_max = (pMax - ray.origin) * invDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t_min.x &gt; t_max.x) std::<span class="built_in">swap</span> (t_min.x, t_max.x);</span><br><span class="line">    <span class="keyword">if</span> (t_min.y &gt; t_max.y) std::<span class="built_in">swap</span> (t_min.y, t_max.y);</span><br><span class="line">    <span class="keyword">if</span> (t_min.z &gt; t_max.z) std::<span class="built_in">swap</span> (t_min.z, t_max.z);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> f_enter = <span class="built_in">fmax</span>(t_min.x, <span class="built_in">fmax</span>(t_min.y, t_min.z));</span><br><span class="line">    <span class="type">float</span> f_exit = <span class="built_in">fmin</span>(t_max.x, <span class="built_in">fmin</span>(t_max.y, t_max.z));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f_enter &lt; f_exit &amp;&amp; f_exit &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间的三个<code>if</code>语句是为了保证最小值要小于最大值。</p>
<h3 id="implementing-trianglegetintersection">Implementing
<code>Triangle::getIntersection</code></h3>
<p>这里还需要实现<code>Triangle::getIntersection</code>，前半部分的代码已经提供了，后面的代码比较简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Intersection <span class="title">Triangle::getIntersection</span><span class="params">(Ray ray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Intersection inter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(ray.direction, normal) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    <span class="type">double</span> u, v, t_tmp = <span class="number">0</span>;</span><br><span class="line">    Vector3f pvec = <span class="built_in">crossProduct</span>(ray.direction, e2); <span class="comment">// S1</span></span><br><span class="line">    <span class="type">double</span> det = <span class="built_in">dotProduct</span>(e1, pvec);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(det) &lt; EPSILON)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> det_inv = <span class="number">1.</span> / det;</span><br><span class="line">    Vector3f tvec = ray.origin - v0;  <span class="comment">// S</span></span><br><span class="line">    u = <span class="built_in">dotProduct</span>(tvec, pvec) * det_inv;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span> || u &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    Vector3f qvec = <span class="built_in">crossProduct</span>(tvec, e1);  <span class="comment">// S2</span></span><br><span class="line">    v = <span class="built_in">dotProduct</span>(ray.direction, qvec) * det_inv;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || u + v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    t_tmp = <span class="built_in">dotProduct</span>(e2, qvec) * det_inv;</span><br><span class="line"></span><br><span class="line">    inter.happened = <span class="literal">true</span>;</span><br><span class="line">    inter.distance = t_tmp;</span><br><span class="line">    inter.obj = <span class="keyword">this</span>;</span><br><span class="line">    inter.m = m;</span><br><span class="line">    inter.normal = normal;</span><br><span class="line">    inter.coords = <span class="built_in">ray</span>(t_tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码已经提供的部分就是上个作业的Moller-Trumbore算法，得到合法的<code>t_tmp</code>之后把所有相交的信息存储在一个<code>Intersection</code>对象中。注意，<code>Ray</code>实现了<code>()</code>运算符重载，给定一个<code>t</code>值，返回光线传播<code>t</code>后的位置，也就是光线和三角形相交的位置。</p>
<h2 id="renderer.cpp"><code>Renderer.cpp</code></h2>
<p><code>Renderer.cpp</code>中唯一的函数是<code>Renderer::Render</code>，其作用就是从每个像素射出光线，也就是调用<code>scene.castRay</code>的函数。这里和上次作业的代码略有差别，但也很容易写出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">-1</span>)); </span><br><span class="line"><span class="function">Ray <span class="title">ray</span> <span class="params">(eye_pos, dir, <span class="number">0</span>)</span></span>;</span><br><span class="line">framebuffer[m++] = scene.<span class="built_in">castRay</span>(ray, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>下图是使用BVH执行的结果：</p>
<p><img data-src="/images/games101/6-1.png" /></p>
<h2 id="bonus-surface-area-heuristic-sah">Bonus: Surface Area Heuristic
(SAH)</h2>
<p>本次作业的提高题是要使用另一种场景加速方法，称为Surface Area
Heuristic (SAH)。</p>
<h3 id="fundamentals-of-sah">Fundamentals of SAH</h3>
<p>在上面我们构造BVH时，对每个非叶子结点，我们是采取了<strong>中间</strong>的物体对所有物体划分为左右两个部分。但是这种策略在物体分布及其不均匀的时候是不合理的。</p>
<p>如下图所示，大量的三角形分布在右上角，只有一个三角形分布在左下角。按照我们上面的划分策略，我们会采取第二张图的方法，但是显然，更好的方法是图三，也就是希望<strong>越小的包围盒里有越多的物体</strong>。这是我们使用SAH的基本想法。</p>
<p><img data-src="/images/games101/6-2.png" /></p>
<p>也就是说，SAH是一种划分子结点的方法，对应的是我们上面取中间物体的划分方法。记住，我们的最终目标是<strong>找到与光线相交的物体</strong>，也就是要尽可能少地遍历树，找到对应物体的叶子结点，那么显然，只有当<strong>包围盒里包含更多的物体</strong>，或者说<strong>相同多的物体被更小的包围盒包围</strong>时，才有可能更少地遍历树，因为此时有更大的概率不通过包围盒相交检测。</p>
<p>那么怎么才能划分当前结点的物体，让左右两边各自的包围盒更小，同时也能包含更多物体呢？我们可以引入一个经验公式，对每个可能的划分，根据经验公式计算它的划分代价，然后选择代价最小的一个划分作为我们选定的划分。</p>
<p>根据<a
href="https://medium.com/@bromanz/how-to-create-awesome-accelerators-the-surface-area-heuristic-e14b5dec6160">这篇介绍</a>，我们能给出SAH的经验公式如下:</p>
<p><span class="math display">\[\text{Cost}(P\to
A,B)=t_\text{traversal}+p_A\sum_{i=1}^{N_A}t_\text{intersect}(a_i)+p_B\sum_{i=1}^{N_B}t_\text{intersect}(b_i)\]</span></p>
<p>这个公式计算了将当前结点<span
class="math inline">\(P\)</span>划分为<span
class="math inline">\(A,B\)</span>子结点后的代价<span
class="math inline">\(\text{Cost}(P\to A,B)\)</span>。其中：</p>
<ul>
<li><span
class="math inline">\(t_\text{traversal}\)</span>是检测光线与两个子包围盒相交所用的时间，以决定选择哪个子结点往下走；</li>
<li><span class="math inline">\(p_A,p_B\)</span>是光线进入<span
class="math inline">\(A,B\)</span>的概率，也即光线与包围盒相交的概率；</li>
<li><span
class="math inline">\(N_A,N_B\)</span>是两个子包围盒内包含的物体的数量；</li>
<li><span
class="math inline">\(t_\text{intersect}(a_i),t_\text{intersect}(b_i)\)</span>是检测光线与物体相交所用的时间。</li>
</ul>
<p>显然，要让上面式子的值更小，要么让概率<span
class="math inline">\(p_A,p_B\)</span>更小，要么让包围盒里包含的物体数量<span
class="math inline">\(N_A,N_B\)</span>更小，当然这两个包围盒的增长趋势是相反的，比如<span
class="math inline">\(p_A\)</span>越大，一般<span
class="math inline">\(p_B\)</span>就越小，<span
class="math inline">\(N_A\)</span>越大，<span
class="math inline">\(N_B\)</span>就一定越小。但总的来说，上面的式子是鼓励<strong>让更小的包围盒包围尽可能多的物体</strong>。</p>
<p>这里我们可以假设<span
class="math inline">\(t_\text{traversal},t_\text{intersect}(a_i),t_\text{intersect}(b_i)\)</span>为常量，这可以简化计算并且不会带来很大的误差。</p>
<p>最后的问题就是如何计算概率<span
class="math inline">\(p_A,p_B\)</span>。可以证明，一个凸多面体<span
class="math inline">\(A\)</span>包含在另一个凸面体<span
class="math inline">\(C\)</span>中，一个均匀分布的光线在与<span
class="math inline">\(C\)</span>相交的条件下与<span
class="math inline">\(A\)</span>相交的概率是它们的表面积之比，即：</p>
<p><span class="math display">\[p(A|C)=\frac{s_A}{s_C}\]</span></p>
<p>这也是SAH名字的由来。</p>
<p>下图是我们假设<span
class="math inline">\(t_\text{traversal}=1,t_\text{intersect}=2\)</span>时，使用SAH进行划分计算得到的值，可以看到，与我们的猜想相符，第三种划分结果最好：</p>
<p><img data-src="/images/games101/6-3.png" /></p>
<p>下面我们用代码实现SAH。</p>
<h3 id="implementing-sah">Implementing SAH</h3>
<p>我们需要重新定义几个函数。</p>
<ul>
<li>函数<code>recursiveBuildSAH</code>类似<code>recursiveBuild</code>，递归地使用SAH构建BVH。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BVHBuildNode* <span class="title">BVHAccel::recursiveBuildSAH</span><span class="params">(std::vector&lt;Object*&gt; objects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数<code>GetPartition</code>找出所有物体的划分点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">BVHAccel::GetPartition</span> <span class="params">(std::vector&lt;Object*&gt; objects, <span class="type">float</span> bucketBorder, <span class="type">int</span> dim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数<code>ComputeCost</code>计算给定划分的Cost。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">BVHAccel::ComputeCost</span> <span class="params">(std::vector&lt;Object*&gt; leftObjects, std::vector&lt;Object*&gt; rightObjects, <span class="type">float</span> t_intersect, <span class="type">float</span> t_traversal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘了把它们的函数声明放到<code>BVH.hpp</code>中。</p>
<p>首先来看函数<code>recursiveBuildSAH</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BVHBuildNode* <span class="title">BVHAccel::recursiveBuildSAH</span><span class="params">(std::vector&lt;Object*&gt; objects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Number of buckets</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> nBuckets = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Min and max axis value</span></span><br><span class="line">    <span class="type">float</span> min_axis, max_axis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Min cost</span></span><br><span class="line">    <span class="type">float</span> min_cost = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    BVHBuildNode* node = <span class="keyword">new</span> <span class="built_in">BVHBuildNode</span>();</span><br><span class="line">    <span class="comment">// Compute bounds of all primitives in BVH node</span></span><br><span class="line">    Bounds3 bounds;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        bounds = <span class="built_in">Union</span>(bounds, objects[i]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Create leaf _BVHBuildNode_</span></span><br><span class="line">        node-&gt;bounds = objects[<span class="number">0</span>]-&gt;<span class="built_in">getBounds</span>();</span><br><span class="line">        node-&gt;object = objects[<span class="number">0</span>];</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objects.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">        node-&gt;left = <span class="built_in">recursiveBuildSAH</span>(std::vector&lt;Object*&gt;&#123;objects[<span class="number">0</span>]&#125;);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursiveBuildSAH</span>(std::vector&lt;Object*&gt;&#123;objects[<span class="number">1</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Bounds3 centroidBounds;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            centroidBounds =</span><br><span class="line">                <span class="built_in">Union</span>(centroidBounds, objects[i]-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>());</span><br><span class="line">        <span class="type">int</span> dim = centroidBounds.<span class="built_in">maxExtent</span>();</span><br><span class="line">        <span class="keyword">switch</span> (dim) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// assign to min_axis and max_axix</span></span><br><span class="line">            min_axis = (*objects.<span class="built_in">begin</span>())-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x;</span><br><span class="line">            max_axis = (*--objects.<span class="built_in">end</span>())-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// assign to min_axis and max_axix</span></span><br><span class="line">            min_axis = (*objects.<span class="built_in">begin</span>())-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y;</span><br><span class="line">            max_axis = (*--objects.<span class="built_in">end</span>())-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123;</span><br><span class="line">                <span class="keyword">return</span> f1-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z &lt;</span><br><span class="line">                       f2-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// assign to min_axis and max_axix</span></span><br><span class="line">            min_axis = (*objects.<span class="built_in">begin</span>())-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z;</span><br><span class="line">            max_axis = (*--objects.<span class="built_in">end</span>())-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>().z;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        auto beginning = objects.begin();</span></span><br><span class="line"><span class="comment">        auto middling = objects.begin() + (objects.size() / 2);</span></span><br><span class="line"><span class="comment">        auto ending = objects.end();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        auto leftshapes = std::vector&lt;Object*&gt;(beginning, middling);</span></span><br><span class="line"><span class="comment">        auto rightshapes = std::vector&lt;Object*&gt;(middling, ending);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        assert(objects.size() == (leftshapes.size() + rightshapes.size()));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        node-&gt;left = recursiveBuild(leftshapes);</span></span><br><span class="line"><span class="comment">        node-&gt;right = recursiveBuild(rightshapes);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        node-&gt;bounds = Union(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        std::vector&lt;Object*&gt; leftShapes;</span><br><span class="line">        std::vector&lt;Object*&gt; rightShapes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nBuckets; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// iterate through each bucket</span></span><br><span class="line">            <span class="type">float</span> bucketBorder = min_axis + <span class="number">1.0f</span> * i / nBuckets * (max_axis - min_axis);</span><br><span class="line">            <span class="comment">// the `partition` point of objects</span></span><br><span class="line">            <span class="keyword">auto</span> partition = <span class="built_in">GetPartition</span> (objects, bucketBorder, dim);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// same as recursiveBuild</span></span><br><span class="line">            <span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + partition;</span><br><span class="line">            <span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> leftObjects = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line">            <span class="keyword">auto</span> rightObjects = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// compute cost</span></span><br><span class="line">            <span class="type">float</span> cost = <span class="built_in">ComputeCost</span> (leftObjects, rightObjects, <span class="number">1.0f</span>, <span class="number">1.0f</span> / <span class="number">8</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// if lower cost</span></span><br><span class="line">            <span class="keyword">if</span> (cost &lt; min_cost)</span><br><span class="line">            &#123;</span><br><span class="line">                min_cost = cost;</span><br><span class="line">                leftShapes = leftObjects;</span><br><span class="line">                rightShapes = rightObjects;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftShapes.<span class="built_in">size</span>() + rightShapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">recursiveBuildSAH</span>(leftShapes);</span><br><span class="line">        node-&gt;right = <span class="built_in">recursiveBuildSAH</span>(rightShapes);</span><br><span class="line"></span><br><span class="line">        node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的大部分内容和<code>recursiveBuild</code>都是一样的，主要的不同是函数开头的变量定义，和最后递归的部分，我把<code>recursiveBuild</code>原来的内容注释掉方便对比。</p>
<p>在函数开头，我们新定义了几个变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number of buckets</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> nBuckets = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Min and max axis value</span></span><br><span class="line"><span class="type">float</span> min_axis, max_axis;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Min cost</span></span><br><span class="line"><span class="type">float</span> min_cost = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br></pre></td></tr></table></figure>
<p>分别是bucket的数量（这里为一个常数10），当前在某个轴上划分的最小值和最大值，和划分的最小Cost。在上面我们分析SAH的时候，我们可以对当前包围盒中的每个物体遍历，每次都取一个物体作为划分点对左右进行划分，计算Cost然后比较，最后找到最小Cost的那次划分作为真正的划分。但显然，当物体很多的时候，这样遍历的效率是很低的。我们采用<a
href="https://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies#TheSurfaceAreaHeuristic">基于Bucket的划分方法</a>，把当前包围盒均匀地分为若干个Bucket，去遍历每个Bucket的边界而不是每个物体，这样最多只需要枚举Bucket的数量就可以得到最优划分（当然这里的最优不是枚举每个物体意义上的最优），在不显著降低效果的前提下能够大幅提升构建效率。</p>
<p>在当前包围盒只有一个或者两个物体时，采取和函数<code>recursiveBuild</code>一样的做法，而在包含多于两个物体时，就要去找按照哪个轴划分，<strong>同时对所有物体排序并得到当前轴上所有物体包围盒中心在所选取轴上的最小最大值</strong>，也就是代码中给变量<code>min_axis, max_axis</code>赋值。</p>
<p>最后，就是去枚举每个Bucket。首先得到Bucket的边界：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> bucketBorder = min_axis + <span class="number">1.0f</span> * i / nBuckets * (max_axis - min_axis);</span><br></pre></td></tr></table></figure>
<p>然后基于边界和所选取的轴对所有物体进行划分，即找到一个分界物体，使得左边的物体的包围盒中心在所选取轴上的值都小于Bucket边界值，右侧物体的包围盒中心在所选取轴上的值都大于Bucket边界值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> partition = <span class="built_in">GetPartition</span> (objects, bucketBorder, dim);</span><br></pre></td></tr></table></figure>
<p>找到边界之后，将所有物体分成两组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> beginning = objects.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> middling = objects.<span class="built_in">begin</span>() + partition;</span><br><span class="line"><span class="keyword">auto</span> ending = objects.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> leftObjects = std::<span class="built_in">vector</span>&lt;Object*&gt;(beginning, middling);</span><br><span class="line"><span class="keyword">auto</span> rightObjects = std::<span class="built_in">vector</span>&lt;Object*&gt;(middling, ending);</span><br></pre></td></tr></table></figure>
<p>计算Cost：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> cost = <span class="built_in">ComputeCost</span> (leftObjects, rightObjects, <span class="number">1.0f</span>, <span class="number">1.0f</span> / <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>如果得到的Cost比当前记录的Cost还要小，则更新最小Cost和当前划分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cost &lt; min_cost)</span><br><span class="line">&#123;</span><br><span class="line">    min_cost = cost;</span><br><span class="line">    leftShapes = leftObjects;</span><br><span class="line">    rightShapes = rightObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在枚举完所有的Bucket之后，就得到了最后的划分，递归构建左右子树即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(objects.<span class="built_in">size</span>() == (leftShapes.<span class="built_in">size</span>() + rightShapes.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">node-&gt;left = <span class="built_in">recursiveBuildSAH</span>(leftShapes);</span><br><span class="line">node-&gt;right = <span class="built_in">recursiveBuildSAH</span>(rightShapes);</span><br><span class="line"></span><br><span class="line">node-&gt;bounds = <span class="built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);</span><br></pre></td></tr></table></figure>
<p>函数<code>GetPartition</code>接受已排序的所有物体、Bucket边界值和所选取的轴，返回物体中的一个划分位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">BVHAccel::GetPartition</span> <span class="params">(std::vector&lt;Object*&gt; objects, <span class="type">float</span> bucketBorder, <span class="type">int</span> dim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; objects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3f centroid = objects[i]-&gt;<span class="built_in">getBounds</span>().<span class="built_in">Centroid</span>();</span><br><span class="line">        <span class="keyword">switch</span> (dim)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (centroid.x &gt; bucketBorder) </span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (centroid.y &gt; bucketBorder) </span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (centroid.z &gt; bucketBorder) </span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objects.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到比较大小时是以每个物体包围盒的中心位置为基础的。</p>
<p>函数<code>ComputeCost</code>接受已经划分的左右物体列表，还有两个计算需要的变量<code>t_intersect</code>和<code>t_traversal</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">BVHAccel::ComputeCost</span> <span class="params">(std::vector&lt;Object*&gt; leftObjects, std::vector&lt;Object*&gt; rightObjects, <span class="type">float</span> t_intersect, <span class="type">float</span> t_traversal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bounds3 leftBound, rightBound;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; leftObjects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        leftBound = <span class="built_in">Union</span>(leftBound, leftObjects[i]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rightObjects.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        rightBound = <span class="built_in">Union</span>(rightBound, rightObjects[i]-&gt;<span class="built_in">getBounds</span>());</span><br><span class="line">    </span><br><span class="line">    Bounds3 currentBound = <span class="built_in">Union</span>(leftBound, rightBound);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pA = leftBound.<span class="built_in">SurfaceArea</span>() / currentBound.<span class="built_in">SurfaceArea</span>();</span><br><span class="line">    <span class="type">float</span> pB = rightBound.<span class="built_in">SurfaceArea</span>() / currentBound.<span class="built_in">SurfaceArea</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> cost = t_traversal + pA * leftObjects.<span class="built_in">size</span>() * t_intersect + pB * rightObjects.<span class="built_in">size</span>() * t_intersect;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="modify-other-functions">Modify other functions</h3>
<p>要在本次作业中使用SAH，还要修改几个其他地方。一是在<code>Scene::buildBVH</code>中把构造方法改为SAH：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::buildBVH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; - Generating BVH...\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;bvh = <span class="keyword">new</span> <span class="built_in">BVHAccel</span>(objects, <span class="number">1</span>, BVHAccel::SplitMethod::SAH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>BVHAccel</code>的构造函数中加入判断条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (splitMethod == SplitMethod::NAIVE)</span><br><span class="line">    root = <span class="built_in">recursiveBuild</span>(primitives);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    root = <span class="built_in">recursiveBuildSAH</span>(primitives);</span><br></pre></td></tr></table></figure>
<p>最后还要在<code>MeshTriangle</code>的构造函数里把内部的BVH构造方法改为SAH：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bvh = new BVHAccel(ptrs);</span></span><br><span class="line">bvh = <span class="keyword">new</span> <span class="built_in">BVHAccel</span>(ptrs, <span class="number">1</span>, BVHAccel::SplitMethod::SAH);</span><br></pre></td></tr></table></figure>
<p>下图是使用SAH的效果图：</p>
<p><img data-src="/images/games101/6-4.png" /></p>
<p>然后是BVH和SAH的效率对比。为了使NAIVE BVH和SAH
BVH效率对比更加突出，我在<code>main.cpp</code>中连续调用了100次<code>r.Render(scene)</code>，然后再看二者所花费的时间。结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NAIVE:</span><br><span class="line">Time taken: <span class="number">0</span> hours</span><br><span class="line">          : <span class="number">5</span> minutes</span><br><span class="line">          : <span class="number">328</span> seconds</span><br><span class="line"></span><br><span class="line">SAH:</span><br><span class="line">Time taken: <span class="number">0</span> hours</span><br><span class="line">          : <span class="number">5</span> minutes</span><br><span class="line">          : <span class="number">300</span> seconds</span><br></pre></td></tr></table></figure>
<p>可以看到，对本次作业而言，SAH还是比NAIVE方法更高效，实际上，对更复杂的模型和场景，SAH的优势会更明显。</p>
<h2 id="summary">Summary</h2>
<p>最后来总结一下光线追踪的流程：</p>
<ol type="1">
<li>加载场景中的所有物体，包括顶点位置、材质、材质坐标、法线等等；</li>
<li>构建BVH，可以使用NAIVE方法或者SAH方法，NAIVE方法是选取当前包围盒所包含物体的中间物体作为划分点，而SAH方法是选择使得Cost最小的物体作为划分点，基本思想是让更小的包围盒包围更多的物体；</li>
<li>执行光追，从相机向每个像素发出光线，使用BVH找到最近的交点，递归地得到该点的颜色；</li>
<li>将颜色绘制在每个像素上。</li>
</ol>
<h1 id="作业七">作业七</h1>
<p>本次作业将实现完整的Path Tracing算法。</p>
<h2 id="transfer-code">Transfer code</h2>
<h3
id="trianglegetintersection"><code>Triangle::getIntersection</code></h3>
<p>与上次作业一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inter.happened = <span class="literal">true</span>;</span><br><span class="line">inter.distance = t_tmp;</span><br><span class="line">inter.obj = <span class="keyword">this</span>;</span><br><span class="line">inter.m = m;</span><br><span class="line">inter.normal = normal;</span><br><span class="line">inter.coords = <span class="built_in">ray</span>(t_tmp);</span><br></pre></td></tr></table></figure>
<h3 id="bounds3intersectp"><code>Bounds3::IntersectP</code></h3>
<p>与上次作业基本一样:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector3f t_min = (pMin - ray.origin) * invDir;</span><br><span class="line">Vector3f t_max = (pMax - ray.origin) * invDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t_min.x &gt; t_max.x) std::<span class="built_in">swap</span> (t_min.x, t_max.x);</span><br><span class="line"><span class="keyword">if</span> (t_min.y &gt; t_max.y) std::<span class="built_in">swap</span> (t_min.y, t_max.y);</span><br><span class="line"><span class="keyword">if</span> (t_min.z &gt; t_max.z) std::<span class="built_in">swap</span> (t_min.z, t_max.z);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f_enter = <span class="built_in">fmax</span>(t_min.x, <span class="built_in">fmax</span>(t_min.y, t_min.z));</span><br><span class="line"><span class="type">float</span> f_exit = <span class="built_in">fmin</span>(t_max.x, <span class="built_in">fmin</span>(t_max.y, t_max.z));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f_enter &lt;= f_exit &amp;&amp; f_exit &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>但这里一定要加上等号<code>=</code>，因为存在浮点误差。如果不加等号，画面的大部分内容将为黑色。</p>
<h3
id="bvhaccelgetintersection"><code>BVHAccel::getIntersection</code></h3>
<p>与上次作业一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ray is outside the bounding box</span></span><br><span class="line">Vector3f invDir = ray.direction_inv;</span><br><span class="line">std::array&lt;<span class="type">int</span>, 3&gt; disIsNeg = &#123;<span class="built_in">int</span>(ray.direction.x &gt; <span class="number">0</span>), <span class="built_in">int</span>(ray.direction.y &gt; <span class="number">0</span>), <span class="built_in">int</span>(ray.direction.z &gt; <span class="number">0</span>)&#125;;</span><br><span class="line"><span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span> (ray, invDir, disIsNeg))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Intersection</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// node is a leaf node</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node is an inner node</span></span><br><span class="line">Intersection leftIntersect = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">Intersection rightIntersect = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line"><span class="keyword">return</span> leftIntersect.distance &lt; rightIntersect.distance ? leftIntersect : rightIntersect;</span><br></pre></td></tr></table></figure>
<h2 id="main.cpp-1"><code>main.cpp</code></h2>
<p>现在还是根据程序的调用顺序分析一下代码的框架。代码的大部分内容和上次作业一样，不同的地方详解，其他的地方简要说明。</p>
<p>首先仍然是构造场景，然后初始化了三个颜色<code>red</code>,
<code>green</code>,
<code>white</code>和一个光源<code>light</code>，并定义了它们的漫反射系数<code>Kd</code>。其次加载了若干模型，并加载到场景中。最后构建BVH开始渲染。</p>
<h2 id="material.hpp"><code>Material.hpp</code></h2>
<p><code>Material.hpp</code>和上次作业有较大差别，这里稍微说明下。</p>
<p>Material中的成员变量包括：</p>
<ul>
<li><code>m_type</code>:
材质类型，当前只有<code>DIFFUSE</code>类型；</li>
<li><code>m_emission</code>: 自己向外发出的光；</li>
<li><code>ior</code>: 折射率；</li>
<li><code>Kd</code>, <code>Ks</code>: 漫反射系数和反射系数；</li>
<li><code>specularExponent</code>: 反射指数</li>
</ul>
<p>新增了三个成员函数：</p>
<ul>
<li><code>sample(const Vector3f &amp;wi, const Vector3f &amp;N)</code>:
给定法线<code>N</code>和入射光<code>wi</code>，均匀地在半球上采样一条出射光，因为是均匀采样，所以入射光没有用；</li>
<li><code>pdf(const Vector3f &amp;wi, const Vector3f &amp;wo, const Vector3f &amp;N)</code>:
给定入射光、出射光和法线，计算其概率密度函数，但由于这里是均匀采样，所以结果恒定为<span
class="math inline">\(1/2\pi\)</span>；</li>
<li><code>eval(const Vector3f &amp;wi, const Vector3f &amp;wo, const Vector3f &amp;N)</code>:
给定入射光、出射光和法线，计算其对应的BRDF，在采样均匀的假设下，这个值恒定为<span
class="math inline">\(\rho/\pi\)</span>，这里的<span
class="math inline">\(\rho\)</span>就是漫反射系数<code>Kd</code>，或者称为<strong>albedo</strong>。</li>
</ul>
<p>所以，material实际上定义了一个物体应该被如何着色，它和物体本身的形状、大小没有直接关系。</p>
<h2 id="scene.cpp"><code>Scene.cpp</code></h2>
<p><code>Scene.cpp</code>包含了本次作业需要实现的核心函数，需要稍加分析。</p>
<h3 id="the-samplelight-function">The <code>sampleLight</code>
function</h3>
<p><code>sampleLight</code>函数从面光源处采样一个光源。</p>
<p>首先需要说明，本次作业的Object, Sphere, Triangle, MeshTriangle,
BVH都增加了一个成员变量<code>area</code>表示面光源的面积，和一个<code>Sample</code>的成员方法表示从面光源从采样一条光线。现在先知道这件事，下面会详细说明。</p>
<p><code>sampleLight</code>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::sampleLight</span><span class="params">(Intersection &amp;pos, <span class="type">float</span> &amp;pdf)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> emit_area_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> k = <span class="number">0</span>; k &lt; objects.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects[k]-&gt;<span class="built_in">hasEmit</span>())&#123;</span><br><span class="line">            emit_area_sum += objects[k]-&gt;<span class="built_in">getArea</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> p = <span class="built_in">get_random_float</span>() * emit_area_sum;</span><br><span class="line">    emit_area_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> k = <span class="number">0</span>; k &lt; objects.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects[k]-&gt;<span class="built_in">hasEmit</span>())&#123;</span><br><span class="line">            emit_area_sum += objects[k]-&gt;<span class="built_in">getArea</span>();</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= emit_area_sum)&#123;</span><br><span class="line">                objects[k]-&gt;<span class="built_in">Sample</span>(pos, pdf);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，遍历场景中的所有物体，如果该物体自己是发光的（也就是自己是光源），则把它的光源面积加起来。然后，采样一个数值，找到对应的那个光源，并从这个光源中采样光线，更新发光点的信息<code>pos</code>和概率密度函数<code>pdf</code>。</p>
<h3 id="the-castray-function">The <code>castRay</code> function</h3>
<p>本次作业主要需要实现的函数是<code>castRay</code>函数，核心思路是从光源和相交点两个层面去采样，前者表示直接光照，后者表示间接关照。这二者的渲染方程分别为：</p>
<p><span class="math display">\[
\begin{aligned}
    L^{\text{dir}}_o(p,
\omega_o)&amp;=\int_{A}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\frac{\cos(\theta)\cos(\theta&#39;)}{\|p&#39;-p\|^2}\mathrm{d}A\\
    L^{\text{indir}}_o(p,
\omega_o)&amp;=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos(\theta)\mathrm{d}\omega_i
\end{aligned}
\]</span></p>
<p>按照课上讲的内容和作业中的提示，我们不难写出下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector3f <span class="title">Scene::castRay</span><span class="params">(<span class="type">const</span> Ray &amp;ray, <span class="type">int</span> depth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Part 1: check if the ray collides with something</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Intersection inter = <span class="built_in">intersect</span>(ray);</span><br><span class="line">    <span class="comment">// If not, there is no light coming in</span></span><br><span class="line">    <span class="keyword">if</span> (!inter.happened) <span class="keyword">return</span> <span class="built_in">Vector3f</span>();</span><br><span class="line">    <span class="comment">// If hitting a light, return the light emission</span></span><br><span class="line">    <span class="keyword">if</span> (inter.m-&gt;<span class="built_in">hasEmission</span>()) <span class="keyword">return</span> inter.m-&gt;<span class="built_in">getEmission</span>();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Part 2: sample light (direct light)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Define variables</span></span><br><span class="line">    Vector3f l_dir;</span><br><span class="line">    Intersection lightPos;</span><br><span class="line">    <span class="type">float</span> lightPdf = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sample light, now `lightPos` stores the light pos information</span></span><br><span class="line">    <span class="built_in">sampleLight</span> (lightPos, lightPdf);</span><br><span class="line">    <span class="comment">// Calculate the inter-to-light direction</span></span><br><span class="line">    Vector3f toLightDir = (lightPos.coords - inter.coords).<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="comment">// Calculate the distance</span></span><br><span class="line">    <span class="type">float</span> toLightDisSquare = (lightPos.coords - inter.coords).<span class="built_in">squareNorm</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the ray collides with something else except the light</span></span><br><span class="line">    <span class="function">Ray <span class="title">toLightRay</span> <span class="params">(inter.coords, toLightDir)</span></span>;</span><br><span class="line">    Intersection interBeforeLight = <span class="built_in">intersect</span>(toLightRay);</span><br><span class="line">    <span class="comment">// Does not collision!</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">sqrt</span>(toLightDisSquare) - interBeforeLight.distance &lt; EPSILON)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Calculate the directional light</span></span><br><span class="line">        l_dir = lightPos.emit * inter.m-&gt;<span class="built_in">eval</span>(toLightDir, -ray.direction, inter.normal) * <span class="built_in">dotProduct</span>(toLightDir, inter.normal) * <span class="built_in">dotProduct</span>(-toLightDir, lightPos.normal) / toLightDisSquare / lightPdf;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Part 3: sample ray from intersection (indirect light)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Define variables</span></span><br><span class="line">    Vector3f l_indir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Russian Roulette test</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_random_float</span>() &gt; RussianRoulette) <span class="keyword">return</span> l_dir;</span><br><span class="line">    <span class="comment">// Get a sample ray</span></span><br><span class="line">    Vector3f sampledDir = inter.m-&gt;<span class="built_in">sample</span>(ray.direction, inter.normal).<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="function">Ray <span class="title">sampledRay</span> <span class="params">(inter.coords, sampledDir)</span></span>;</span><br><span class="line">    <span class="comment">// Intersection test</span></span><br><span class="line">    Intersection sampleInter = <span class="built_in">intersect</span>(sampledRay);</span><br><span class="line">    <span class="comment">// If ray hits a non-emitting object</span></span><br><span class="line">    <span class="keyword">if</span> (sampleInter.happened &amp;&amp; !sampleInter.m-&gt;<span class="built_in">hasEmission</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> pdf = inter.m-&gt;<span class="built_in">pdf</span>(ray.direction, sampledDir, inter.normal);</span><br><span class="line">        l_indir = <span class="built_in">castRay</span>(sampledRay, depth + <span class="number">1</span>) * inter.m-&gt;<span class="built_in">eval</span>(sampledDir, -ray.direction, inter.normal) * <span class="built_in">dotProduct</span>(sampledDir, inter.normal) / pdf / RussianRoulette;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l_dir + l_indir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里添加了注释帮助理解。整体流程是比较清楚的：首先当前光线检查是否和场景中的物体相交，如果相交，是否是光源，则说明该位置可以直接被光源照射，此时返回光源的颜色即可；然后计算直接光照，从光源采样光线，计算光线打到相交点接受的能量有多少，注意要检查采样的光线到相交点之间是否有阻挡；第三步计算间接光照，从相交点随机采样一条向外的光线，打到一个非光源物体上，递归地计算该光线接受到的能量；最后把直接光和间接光相加即可。</p>
<p>这里需要理解一点：为什么间接光照要检查是<strong>非发光物体</strong>。这是因为如果不考虑是否发光，那么当光线打到发光物体时，相当于是计算了两次直接光照，最后得到的画面会很奇怪。如下图所示：</p>
<p><img data-src="/images/games101/7-1.png" /></p>
<p>你还会注意到，背后的墙上有很多黑色的横向条纹，这是因为背面墙的颜色基本都来自顶上光源的直接光照，而在计算直接光照的时候我们判定了它们之间是否有阻挡，即<code>std::sqrt(toLightDisSquare) - interBeforeLight.distance &lt; EPSILON</code>，这里的<code>EPSILON</code>在原始代码中很小，这就会因精度问题将其误判为中间存在阻挡。所以，只要把<code>EPSILON</code>稍微调大点即可。</p>
<p>下图是设置<code>EPSILON=0.001</code>并在计算间接光照时判断是否为发光体时生成的结果：</p>
<p><img data-src="/images/games101/7-2.png" /></p>
<p>上面都设置<code>SPP=10</code>，所以你会看到噪点比较多。下面是设置<code>SPP=128</code>时的结果：</p>
<p><img data-src="/images/games101/7-3.png" /></p>
<p>所用的时间是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Time taken: <span class="number">1</span> hours</span><br><span class="line">          : <span class="number">100</span> minutes</span><br><span class="line">          : <span class="number">6004</span> seconds</span><br></pre></td></tr></table></figure>
<h2 id="the-sample-function">The <code>Sample</code> function</h2>
<p>上面的代码需要进一步解释的是如何采样面光源，也就是<code>sampleLight</code>里使用到的函数。</p>
<h3 id="what-is-area">What is <code>area</code></h3>
<p>首先要明确，<code>area</code>代表的是什么？在给定的代码中，所有的物体都表示为<code>MeshTriangle</code>，而一个MeshTriangle是由若干个<code>Triangle</code>组成的，在MeshTriangle的构造函数中，我们发现它的<code>area</code>是内部每个Triangle的area之和：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; tri : triangles)&#123;</span><br><span class="line">    ptrs.<span class="built_in">push_back</span>(&amp;tri);</span><br><span class="line">    area += tri.area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而每个Triangle的area在构造时已经给出了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">area = <span class="built_in">crossProduct</span>(e1, e2).<span class="built_in">norm</span>()*<span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure>
<p>这就是三角形的面积。所以，<code>area</code>代表的就是整个物体的表面积。</p>
<h3 id="the-sample-function-in-sphere.hpp">The <code>Sample</code>
function in <code>Sphere.hpp</code></h3>
<p>有了整个面光源的表面积，我们就可以采样一条光线了。对不同的物体，采样的方式略有差别，我们先来看球型的面光源如何采样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sample</span><span class="params">(Intersection &amp;pos, <span class="type">float</span> &amp;pdf)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> theta = <span class="number">2.0</span> * M_PI * <span class="built_in">get_random_float</span>(), phi = M_PI * <span class="built_in">get_random_float</span>();</span><br><span class="line">    <span class="function">Vector3f <span class="title">dir</span><span class="params">(std::cos(phi), std::sin(phi)*std::cos(theta), std::sin(phi)*std::sin(theta))</span></span>;</span><br><span class="line">    pos.coords = center + radius * dir;</span><br><span class="line">    pos.normal = dir;</span><br><span class="line">    pos.emit = m-&gt;<span class="built_in">getEmission</span>();</span><br><span class="line">    pdf = <span class="number">1.0f</span> / area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先随机得到一个<span class="math inline">\(\theta\)</span>和<span
class="math inline">\(\phi\)</span>，然后就能得到一个随机方向<code>dir</code>，从而就能得到球面上一个随机的坐标<code>coords</code>，这就是采样的光线的位置。然后设置法线方向<code>normal</code>、光强度<code>emit</code>和概率密度<code>pdf</code>。</p>
<h3 id="the-sample-function-in-triangle.hpp">The <code>Sample</code>
function in <code>Triangle.hpp</code></h3>
<p>再来看三角形如何采样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sample</span><span class="params">(Intersection &amp;pos, <span class="type">float</span> &amp;pdf)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> x = std::<span class="built_in">sqrt</span>(<span class="built_in">get_random_float</span>()), y = <span class="built_in">get_random_float</span>();</span><br><span class="line">    pos.coords = v0 * (<span class="number">1.0f</span> - x) + v1 * (x * (<span class="number">1.0f</span> - y)) + v2 * (x * y);</span><br><span class="line">    pos.normal = <span class="keyword">this</span>-&gt;normal;</span><br><span class="line">    pdf = <span class="number">1.0f</span> / area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先得到<span
class="math inline">\((0,1)\)</span>之间随机的两个坐标，然后计算三个值<span
class="math inline">\(1-x, x(1-y), xy\)</span>，这三个值加起来为<span
class="math inline">\(1\)</span>，所以就能在三角形三个顶点中插值，得到的结果就是三角形内的一个随机的点。然后设置<code>normal</code>和<code>pdf</code>即可。</p>
<h3 id="the-sample-function-in-bvh.cpp">The <code>Sample</code> function
in <code>BVH.cpp</code></h3>
<p>对于<code>MeshTriangle</code>类型的物体，需要首先随机采样一个三角形，然后再按照上面三角形采样的方法进行即可。对于随机采样三角形，首先随机得到一个面积<code>p</code>，然后使用BVH去找到对应的三角形即可。注意，这一行代码<code>pdf *= node-&gt;area</code>是为了把在<code>node-&gt;object-&gt;Sample(pos, pdf)</code>里改变的<code>pdf</code>还原到<code>1.0f</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BVHAccel::getSample</span><span class="params">(BVHBuildNode* node, <span class="type">float</span> p, Intersection &amp;pos, <span class="type">float</span> &amp;pdf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> || node-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node-&gt;object-&gt;<span class="built_in">Sample</span>(pos, pdf);</span><br><span class="line">        pdf *= node-&gt;area;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; node-&gt;left-&gt;area) <span class="built_in">getSample</span>(node-&gt;left, p, pos, pdf);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">getSample</span>(node-&gt;right, p - node-&gt;left-&gt;area, pos, pdf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BVHAccel::Sample</span><span class="params">(Intersection &amp;pos, <span class="type">float</span> &amp;pdf)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> p = std::<span class="built_in">sqrt</span>(<span class="built_in">get_random_float</span>()) * root-&gt;area;</span><br><span class="line">    <span class="built_in">getSample</span>(root, p, pos, pdf);</span><br><span class="line">    pdf /= root-&gt;area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bonus-multi-threading">Bonus: Multi-threading</h2>
<p>C++的多线程可以使用<code>std::thread</code>实现，用法可以参考<a
href="https://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/thread/thread/thread.html">这里</a>。基于此，我们不难写出下面的代码，只需要稍加修改<code>Renderer::Render</code>即可（注意加上头文件<code>#include &lt;thread&gt;</code>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoThread</span> <span class="params">(<span class="type">const</span> Scene&amp; scene, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">float</span> scale, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">float</span> imageAspectRatio, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> Vector3f eye_pos,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::vector&lt;Vector3f&gt;&amp; framebuffer, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> start, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> end, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">int</span> spp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = start; m &lt; end; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i_width = m % scene.width;</span><br><span class="line">        <span class="type">int</span> j_height = m / scene.width;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> x = (<span class="number">2</span> * (i_width + <span class="number">0.5</span>) / (<span class="type">float</span>)scene.width - <span class="number">1</span>) *</span><br><span class="line">                    imageAspectRatio * scale;</span><br><span class="line">        <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2</span> * (j_height + <span class="number">0.5</span>) / (<span class="type">float</span>)scene.height) * scale;</span><br><span class="line">        Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++)&#123;</span><br><span class="line">            framebuffer[m] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Render</span><span class="params">(<span class="type">const</span> Scene&amp; scene, <span class="type">bool</span> multiThreading)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;Vector3f&gt; <span class="title">framebuffer</span><span class="params">(scene.width * scene.height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> scale = <span class="built_in">tan</span>(<span class="built_in">deg2rad</span>(scene.fov * <span class="number">0.5</span>));</span><br><span class="line">    <span class="type">float</span> imageAspectRatio = scene.width / (<span class="type">float</span>)scene.height;</span><br><span class="line">    <span class="function">Vector3f <span class="title">eye_pos</span><span class="params">(<span class="number">278</span>, <span class="number">273</span>, <span class="number">-800</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> spp = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!multiThreading)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SPP: &quot;</span> &lt;&lt; spp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> j = <span class="number">0</span>; j &lt; scene.height; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; scene.width; ++i) &#123;</span><br><span class="line">                <span class="comment">// generate primary ray direction</span></span><br><span class="line">                <span class="type">float</span> x = (<span class="number">2</span> * (i + <span class="number">0.5</span>) / (<span class="type">float</span>)scene.width - <span class="number">1</span>) *</span><br><span class="line">                        imageAspectRatio * scale;</span><br><span class="line">                <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5</span>) / (<span class="type">float</span>)scene.height) * scale;</span><br><span class="line"></span><br><span class="line">                Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++)&#123;</span><br><span class="line">                    framebuffer[m] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">                &#125;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">UpdateProgress</span>(j / (<span class="type">float</span>)scene.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">UpdateProgress</span>(<span class="number">1.f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num_threads = <span class="number">64</span>;</span><br><span class="line">        <span class="type">int</span> step = scene.height * scene.width / num_threads;</span><br><span class="line">        std::vector&lt;std::thread&gt; threads;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i)</span><br><span class="line">            threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(DoThread, std::<span class="built_in">ref</span>(scene), scale, imageAspectRatio, eye_pos, std::<span class="built_in">ref</span>(framebuffer), i * step, (i + <span class="number">1</span>) * step, spp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i)</span><br><span class="line">            threads[i].<span class="built_in">join</span>();</span><br><span class="line">        <span class="built_in">UpdateProgress</span>(<span class="number">1.f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save framebuffer to file</span></span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;binary.ppm&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">fprintf</span>(fp, <span class="string">&quot;P6\n%d %d\n255\n&quot;</span>, scene.width, scene.height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; scene.height * scene.width; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> color[<span class="number">3</span>];</span><br><span class="line">        color[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255</span> * std::<span class="built_in">pow</span>(<span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].x), <span class="number">0.6f</span>));</span><br><span class="line">        color[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255</span> * std::<span class="built_in">pow</span>(<span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].y), <span class="number">0.6f</span>));</span><br><span class="line">        color[<span class="number">2</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255</span> * std::<span class="built_in">pow</span>(<span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].z), <span class="number">0.6f</span>));</span><br><span class="line">        <span class="built_in">fwrite</span>(color, <span class="number">1</span>, <span class="number">3</span>, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体思路还是比较明确的，首先定义线程数<code>num_threads</code>，然后计算每个线程要处理的像素数量<code>step</code>，其次创建线程列表<code>threads</code>，最后加入队列<code>threads[i].join()</code>。</p>
<p>对每个线程而言，做的事情和之前单线程一样，唯一不同的是每个线程只负责自己那一部分的像素计算，所以只需要计算对应的宽高即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_width = m % scene.width;</span><br><span class="line"><span class="type">int</span> j_height = m / scene.width;</span><br></pre></td></tr></table></figure>
<p>注意，这里需要修改<code>CMakeLists.txt</code>如下，才能编译成功：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(RayTracing)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(THREADS_PREFER_PTHREAD_FLAG <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(RayTracing main.cpp Object.hpp Vector.cpp Vector.hpp Sphere.hpp global.hpp Triangle.hpp Scene.cpp</span><br><span class="line">        Scene.hpp Light.hpp AreaLight.hpp BVH.cpp BVH.hpp Bounds3.hpp Ray.hpp Material.hpp Intersection.hpp</span><br><span class="line">        Renderer.cpp Renderer.hpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(RayTracing <span class="variable">$&#123;CMAKE_THREAD_LIBS_INIT&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>现在，在开64个线程时，<code>SPP=128</code>花的时间只有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Time taken: <span class="number">0</span> hours</span><br><span class="line">          : <span class="number">27</span> minutes</span><br><span class="line">          : <span class="number">1629</span> seconds</span><br></pre></td></tr></table></figure>
<p>得到的结果和没用多线程时是一样的：</p>
<p><img data-src="/images/games101/7-4.png" /></p>
<h2 id="bonus-microfacet">Bonus: Microfacet</h2>
<p>根据课上所讲的内容，我们可以得到下面的微表面模型BRDF公式：</p>
<p><span class="math display">\[
f_\text{micro}=\frac{F(\mathbf{i},\mathbf{n})G(\mathbf{n},\mathbf{i},\mathbf{o},r)D(\mathbf{n},\mathbf{h},\alpha)}{4(\mathbf{n}\cdot\mathbf{i})(\mathbf{n}\cdot\mathbf{o})}
\]</span></p>
<p>其中<span
class="math inline">\(F(\mathbf{i},\mathbf{n})\)</span>是Fresnel
term，<span
class="math inline">\(G(\mathbf{n},\mathbf{i},\mathbf{o},r)\)</span>是shadow-masking
term，<span
class="math inline">\(D(\mathbf{n},\mathbf{h},\alpha)\)</span>是normal
distribution。下面来实现这个公式，具体的公式推导之后会专门出一篇文章介绍。</p>
<h3 id="implementing-the-normal-distribution">Implementing the normal
distribution</h3>
<p>这里使用GGX分布（Trowbridge-Reitz分布），公式如下：</p>
<p><span class="math display">\[
D(\mathbf{n},\mathbf{h},\alpha)=\frac{\alpha^2}{\pi((\mathbf{n}\cdot\mathbf{h})^2(\alpha^2-1)+1)^2}
\]</span></p>
<p>其中<span
class="math inline">\(\alpha\in[0,1]\)</span>是表面的粗糙程度，<span
class="math inline">\(\mathbf{n}\)</span>是法向量，<span
class="math inline">\(\mathbf{h}\)</span>是半程向量。注意，这里的<span
class="math inline">\(\alpha\)</span>实际上是真正粗糙度<span
class="math inline">\(r\)</span>的平方，即<span
class="math inline">\(\alpha=r^2\)</span>，一般用户调节的也是<span
class="math inline">\(r\)</span>。</p>
<p>下面是代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Material::normalGGX</span><span class="params">(<span class="type">const</span> Vector3f &amp;N, <span class="type">const</span> Vector3f &amp;h, <span class="type">const</span> <span class="type">float</span> &amp;roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> alpha = roughness * roughness;</span><br><span class="line">    <span class="type">float</span> alpha_square = alpha * alpha;</span><br><span class="line">    <span class="type">float</span> d = (<span class="built_in">dotProduct</span>(N, h) * <span class="built_in">dotProduct</span>(N, h)) * (alpha_square - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> alpha_square / std::<span class="built_in">max</span>(M_PI * d * d, EPS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="implementing-the-shadow-masking-term">Implementing the
shadow-masking term</h3>
<p>这里使用SchlickGGX：</p>
<p><span class="math display">\[
\begin{aligned}
    G(\mathbf{n},\mathbf{i},\mathbf{o},r)&amp;=G&#39;(\mathbf{n},\mathbf{i},r)G&#39;(\mathbf{n},\mathbf{o},r)\\
    G&#39;(\mathbf{n},\mathbf{v},r)&amp;=\frac{\mathbf{n}\cdot\mathbf{v}}{(\mathbf{n}\cdot\mathbf{v})(1-k)+k}\\
    k&amp;=\frac{(r+1)^2}{8}
\end{aligned}
\]</span></p>
<p>可以写出下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Material::shadowSchlickGGX</span><span class="params">(<span class="type">const</span> Vector3f &amp;N, <span class="type">const</span> Vector3f &amp;v, <span class="type">const</span> <span class="type">float</span> &amp;roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> r = roughness + <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> k = r * r / <span class="number">8.0f</span>;</span><br><span class="line">    <span class="type">float</span> dot = <span class="built_in">dotProduct</span>(N, v);</span><br><span class="line">    <span class="keyword">return</span> dot / (dot * (<span class="number">1</span> - k) + k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Material::shadowSmith</span><span class="params">(<span class="type">const</span> Vector3f &amp;N, <span class="type">const</span> Vector3f &amp;wi, <span class="type">const</span> Vector3f &amp;wo, <span class="type">const</span> <span class="type">float</span> &amp;roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> G1 = <span class="built_in">shadowSchlickGGX</span>(N, wi, roughness);</span><br><span class="line">    <span class="type">float</span> G2 = <span class="built_in">shadowSchlickGGX</span>(N, wo, roughness);</span><br><span class="line">    <span class="keyword">return</span> G1 * G2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fresnel项<span
class="math inline">\(F(\mathbf{i},\mathbf{n})\)</span>代码框架已经给出，即<code>fresnel(const Vector3f &amp;I, const Vector3f &amp;N, const float &amp;ior, float &amp;kr)</code>。下面我们只需要实现整个BRDF流程即可。</p>
<h3 id="implementing-brdf">Implementing BRDF</h3>
<p>首先按照最开始的公式把几个项结合起来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector3f <span class="title">Material::f_micro</span><span class="params">(<span class="type">const</span> Vector3f &amp;N, <span class="type">const</span> Vector3f &amp;wi, <span class="type">const</span> Vector3f &amp;wo, <span class="type">const</span> <span class="type">float</span> &amp;ior, <span class="type">float</span> &amp;kr, <span class="type">const</span> <span class="type">float</span> &amp;roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fresnel</span>(wi, N, ior, kr);</span><br><span class="line">    <span class="type">float</span> G = <span class="built_in">shadowSmith</span>(N, wi, wo, roughness);</span><br><span class="line">    Vector3f h = ((wi + wo) / <span class="number">2</span>).<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="type">float</span> D = <span class="built_in">normalGGX</span> (N, h, roughness);</span><br><span class="line"></span><br><span class="line">    Vector3f f = kr * G * D / std::<span class="built_in">max</span>(<span class="number">4.0f</span> * <span class="built_in">dotProduct</span>(N, wi) * <span class="built_in">dotProduct</span>(N, wo), EPS);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们修改<code>eval</code>函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector3f <span class="title">Material::eval</span><span class="params">(<span class="type">const</span> Vector3f &amp;wi, <span class="type">const</span> Vector3f &amp;wo, <span class="type">const</span> Vector3f &amp;N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(m_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> DIFFUSE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// calculate the contribution of diffuse model</span></span><br><span class="line">            <span class="type">float</span> cosalpha = <span class="built_in">dotProduct</span>(N, wo);</span><br><span class="line">            <span class="keyword">if</span> (cosalpha &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                Vector3f diffuse = Kd / M_PI;</span><br><span class="line">                <span class="keyword">return</span> diffuse;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MICROFACET:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> cosalpha = <span class="built_in">dotProduct</span>(N, wo);</span><br><span class="line">            <span class="keyword">if</span> (cosalpha &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// define variables</span></span><br><span class="line">                <span class="type">float</span> roughness = <span class="number">0.8f</span>; <span class="comment">// you can change it to whatever you want</span></span><br><span class="line">                <span class="type">float</span> kr, kd;</span><br><span class="line">                <span class="comment">// microfacet BRDF: the ratio of intensity coming from one direction is reflected </span></span><br><span class="line">                Vector3f fr = <span class="built_in">f_micro</span>(N, wi, wo, ior, kr, roughness);</span><br><span class="line">                <span class="comment">// diffuse BRDF: constant  </span></span><br><span class="line">                kd = <span class="number">1.0f</span> - kr;</span><br><span class="line">                Vector3f fd = <span class="number">1.0f</span> / M_PI;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Ks * fr + Kd * kd * fd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最后返回的值是<code>Ks * fr + Kd * kd * fd</code>，这里的<code>fr</code>是微表面<strong>镜面反射</strong>的BRDF，这里面已经乘了Fresnel项，也就是入射光有多少能量被反射出去，外面的<code>Ks</code>是这个材质在镜面反射时<strong>本身</strong>会吸收多少能量，所以还要衰减。同理，<code>fd</code>是假设入射光所有能量都被<strong>漫反射</strong>出去的比例，但是实际上有一部分被镜面反射了，剩下来的部分就是<code>kd * fd</code>，而<code>Kd</code>是材质在漫反射时<strong>本身</strong>会吸收多少。</p>
<p>最后，在<code>main.cpp</code>里修改物体的材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a diffuse material, it does not induce reflection light</span></span><br><span class="line">Material* material_diffuse =  <span class="keyword">new</span> <span class="built_in">Material</span>(DIFFUSE, <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>));</span><br><span class="line">material_diffuse-&gt;Kd = <span class="built_in">Vector3f</span>(<span class="number">0.725f</span>, <span class="number">0.71f</span>, <span class="number">0.68f</span>);</span><br><span class="line"><span class="comment">// Create a microfacet material, it has both reflect and diffuse lights</span></span><br><span class="line">Material* material_microfacet = <span class="keyword">new</span> <span class="built_in">Material</span>(MICROFACET, <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>));</span><br><span class="line">material_microfacet-&gt;Kd = <span class="built_in">Vector3f</span>(<span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>); <span class="comment">// lean to red diffuse</span></span><br><span class="line">material_microfacet-&gt;Ks = <span class="built_in">Vector3f</span>(<span class="number">0.45f</span>, <span class="number">0.45f</span>, <span class="number">0.45f</span>); </span><br><span class="line">material_microfacet-&gt;ior = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MeshTriangle <span class="title">floor</span><span class="params">(<span class="string">&quot;../models/cornellbox/floor.obj&quot;</span>, white)</span></span>;</span><br><span class="line"><span class="function">MeshTriangle <span class="title">shortbox</span><span class="params">(<span class="string">&quot;../models/cornellbox/shortbox.obj&quot;</span>, material_microfacet)</span></span>;</span><br><span class="line"><span class="function">MeshTriangle <span class="title">tallbox</span><span class="params">(<span class="string">&quot;../models/cornellbox/tallbox.obj&quot;</span>, material_microfacet)</span></span>;</span><br><span class="line"><span class="function">MeshTriangle <span class="title">left</span><span class="params">(<span class="string">&quot;../models/cornellbox/left.obj&quot;</span>, red)</span></span>;</span><br><span class="line"><span class="function">MeshTriangle <span class="title">right</span><span class="params">(<span class="string">&quot;../models/cornellbox/right.obj&quot;</span>, green)</span></span>;</span><br><span class="line"><span class="function">MeshTriangle <span class="title">light_</span><span class="params">(<span class="string">&quot;../models/cornellbox/light.obj&quot;</span>, light)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<code>SPP=128</code>下能得到下面的图：</p>
<p><img data-src="/images/games101/7-5.png" /></p>
<p>这里两个立方体比较黑是因为反射率<span
class="math inline">\(K_s,K_d\)</span>设置得比较小，将其增大，即吸收的光越少，可以得到更明亮的结果。</p>
<h3 id="using-sphere-to-explore-the-effect-of-roughness">Using sphere to
explore the effect of <code>roughness</code></h3>
<p>直观来看，<code>roughness</code>控制了物体表面的粗糙程度，那么它会怎样影响光照呢？下面在场景中添加一个球体，并改变<code>roughness</code>探究其影响。所有实验均设置<code>SPP=32</code>。</p>
<p>在<code>main.cpp</code>中加入一个球并调整材质的<code>Kd</code>和<code>Ks</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Material* material_microfacet = <span class="keyword">new</span> <span class="built_in">Material</span>(MICROFACET, <span class="built_in">Vector3f</span>(<span class="number">0.0f</span>));</span><br><span class="line">material_microfacet-&gt;Kd = <span class="built_in">Vector3f</span>(<span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>); <span class="comment">// lean to green diffuse</span></span><br><span class="line">material_microfacet-&gt;Ks = <span class="built_in">Vector3f</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>); </span><br><span class="line">material_microfacet-&gt;ior = <span class="number">1.1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Sphere <span class="title">sphere</span> <span class="params">(Vector3f(<span class="number">150</span>, <span class="number">100</span>, <span class="number">300</span>), <span class="number">100</span>, material_microfacet)</span></span>;</span><br><span class="line">scene.<span class="built_in">Add</span>(&amp;sphere);</span><br></pre></td></tr></table></figure>
<p>先设置<code>roughness = 0.1f</code>，下图是结果：</p>
<p><img data-src="/images/games101/7-6.png" /></p>
<p>再设置<code>roughness = 0.5f</code>：</p>
<p><img data-src="/images/games101/7-7.png" /></p>
<p>最后看<code>roughness = 0.95f</code>：</p>
<p><img data-src="/images/games101/7-8.png" /></p>
<p>可以看到，<code>roughness</code>越小，高光越集中，否则越分散。粗糙度越接近1，效果越接近漫反射。</p>
<h2 id="summary-1">Summary</h2>
<p>最后，还是按照惯例总结一下加入BRDF的光线追踪算法：</p>
<ul>
<li>对每个像素，采样若干点向场景发出光线，把所有光线得到的值平均起来；</li>
<li>对每个光线，计算直接光照和间接光照两个部分：
<ul>
<li>对于直接光照，从光源中随机采样一个光线，如果没有阻挡，则计算该点收到直接光照的能量；</li>
<li>对于间接光照，从半球随机采样一个向外的光线，如果打到非发光体，则递归地得到从该光线收到的能量；</li>
<li>在计算能量时，使用Microfacet
BRDF从镜面反射和漫反射两个角度考虑，公式为： <span
class="math display">\[f=K_s\cdot k_s\cdot f_s+K_d\cdot k_d\cdot
f_d\]</span> 其中，<span
class="math inline">\(K_s,K_d\)</span>是材质本身对镜面反射、漫反射的反射率，如果这个值为零，则表示材质会吸收所有颜色的光，那么呈现出来的就是黑色；<span
class="math inline">\(k_s,k_d\)</span>是根据Fresnel
Equation计算得到的有多大比例的能量会被镜面反射、漫反射出去；<span
class="math inline">\(f_s,f_d\)</span>是理论上有多少能量能被镜面反射、漫反射出去，它们还需要乘以Fresnel系数和材质自身的反射率。注意，这里的<span
class="math inline">\(f_s\)</span>是上面<span
class="math inline">\(f_\text{micro}\)</span>不加Fresnel项的结果，这里提到了外面变成了<span
class="math inline">\(k_s\)</span>。</li>
</ul></li>
<li>最后，把直接光照和间接光照加起来，就是这一点在给定入射光线和出射光线时接受到的能量。</li>
</ul>
<h1 id="作业八">作业八</h1>
<p>本次作业将实现一个质点弹簧系统。下面按照作业要求依次说明。</p>
<h2 id="creating-rope-in-rope.cpp">Creating rope in
<code>rope.cpp</code></h2>
<p>首先需要在<code>rope.cpp</code>中创建绳子对象。每个绳子由<code>num_nodes</code>个质点组成，每两个质点之间有一根弹簧。质点本身有质量、位置以及是否被钉住这样一个属性；每个弹簧包含它连接的两个质点和弹簧系数<code>k</code>。对<code>num_nodes</code>个质点的弹簧，我们需要构造<code>num_nodes</code>个质点和<code>num_nodes - 1</code>个弹簧。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rope::<span class="built_in">Rope</span>(Vector2D start, Vector2D end, <span class="type">int</span> num_nodes, <span class="type">float</span> node_mass, <span class="type">float</span> k, vector&lt;<span class="type">int</span>&gt; pinned_nodes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes.</span></span><br><span class="line">    Vector2D step = (end - start) / (num_nodes - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;Mass *&gt; _masses;</span><br><span class="line">    vector&lt;Spring *&gt; _springs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_nodes; ++i) &#123;</span><br><span class="line">        Mass* mass = <span class="keyword">new</span> <span class="built_in">Mass</span>(start + i * step, node_mass, <span class="literal">false</span>);</span><br><span class="line">        _masses.<span class="built_in">push_back</span>(mass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_nodes - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        Spring* spring = <span class="keyword">new</span> <span class="built_in">Spring</span>(_masses[i], _masses[i + <span class="number">1</span>], k);</span><br><span class="line">        _springs.<span class="built_in">push_back</span>(spring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : pinned_nodes) &#123;</span><br><span class="line">        _masses[i]-&gt;pinned = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    masses = _masses;</span><br><span class="line">    springs = _springs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后可以得到下图的结果：</p>
<p><img data-src="/images/games101/8-1.png" /></p>
<h2 id="simulation-via-euler-method">Simulation via euler method</h2>
<p>接下来实现显式欧拉和半隐式欧拉方法模拟弹簧运动。胡克定律：</p>
<p><span class="math display">\[\mathbf{f}_{\mathbf{b}\to
\mathbf{a}}=-k_s\frac{\mathbf{b}-\mathbf{a}}{\|\mathbf{b}-\mathbf{a}\|}(\|\mathbf{b}-\mathbf{a}\|-\ell)\]</span></p>
<p>其中<span
class="math inline">\(\ell\)</span>是弹簧没有任何拉伸时的长度。</p>
<p>下面是代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rope::simulateEuler</span><span class="params">(<span class="type">float</span> <span class="type">delta_t</span>, Vector2D gravity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : springs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO (Part 2): Use Hooke&#x27;s law to calculate the force on a node</span></span><br><span class="line">        Vector2D vec = s-&gt;m2-&gt;position - s-&gt;m1-&gt;position;</span><br><span class="line">        Vector2D force = -s-&gt;k * vec.<span class="built_in">unit</span>() * (vec.<span class="built_in">norm</span>() - s-&gt;rest_length);</span><br><span class="line"></span><br><span class="line">        s-&gt;m2-&gt;forces += force;</span><br><span class="line">        s-&gt;m1-&gt;forces += -force;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;m : masses)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m-&gt;pinned)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// TODO (Part 2): Add the force due to gravity, then compute the new velocity and position</span></span><br><span class="line">            m-&gt;forces += gravity * m-&gt;mass;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TODO (Part 2): Add global damping</span></span><br><span class="line">            <span class="type">float</span> kd = <span class="number">0.1</span>;</span><br><span class="line">            m-&gt;forces += -kd * m-&gt;velocity;</span><br><span class="line"></span><br><span class="line">            Vector2D <span class="type">a_t</span> = m-&gt;forces / m-&gt;mass;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Explicit Euler method</span></span><br><span class="line">            <span class="comment">// m-&gt;position += m-&gt;velocity * delta_t;</span></span><br><span class="line">            <span class="comment">// m-&gt;velocity += a_t * delta_t;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Semi-implicit Euler method</span></span><br><span class="line">            m-&gt;velocity += <span class="type">a_t</span> * <span class="type">delta_t</span>;</span><br><span class="line">            m-&gt;position += m-&gt;velocity * <span class="type">delta_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset all forces on each mass</span></span><br><span class="line">        m-&gt;forces = <span class="built_in">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先对每个弹簧，基于胡克定律累加每个质点的力；然后对每个质点，加上重力，应用全局阻尼，最后更新位置和速度即可。显式欧拉和半隐式欧拉方法的本质区别在于：半隐式欧拉考虑了加速度，因此更加准确。</p>
<p>为了让质点下降的速度慢一些，可以在<code>application.h</code>中把<code>gravity</code>改小一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gravity = <span class="built_in">Vector2D</span>(<span class="number">0</span>, <span class="number">-0.1</span>);</span><br></pre></td></tr></table></figure>
<p>得到的结果如下（蓝色）：</p>
<p><img data-src="/images/games101/8-2.png" /></p>
<h2 id="simulation-via-verlet-and-adding-vetlet-damping">Simulation via
Verlet and adding Vetlet damping</h2>
<p>使用Verlet模拟，公式如下：</p>
<p><span
class="math display">\[\mathbf{x}_{t+1}=\mathbf{x}_t+(1-k_d)(\mathbf{x}_t-\mathbf{x}_{t-1})+\mathbf{a}_t(\Delta
t)^2\]</span></p>
<p>其中<span
class="math inline">\(k_d\)</span>是阻尼系数。我们不难写出下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rope::simulateVerlet</span><span class="params">(<span class="type">float</span> <span class="type">delta_t</span>, Vector2D gravity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : springs)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2D vec = s-&gt;m2-&gt;position - s-&gt;m1-&gt;position;</span><br><span class="line">        Vector2D force = -s-&gt;k * vec.<span class="built_in">unit</span>() * (vec.<span class="built_in">norm</span>() - s-&gt;rest_length);</span><br><span class="line"></span><br><span class="line">        s-&gt;m2-&gt;forces += force;</span><br><span class="line">        s-&gt;m1-&gt;forces += -force;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;m : masses)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m-&gt;pinned)</span><br><span class="line">        &#123;</span><br><span class="line">            m-&gt;forces += gravity * m-&gt;mass;</span><br><span class="line">            Vector2D <span class="type">a_t</span> = m-&gt;forces / m-&gt;mass;</span><br><span class="line"></span><br><span class="line">            Vector2D temp_position = m-&gt;position;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TODO (Part 3.1): Set the new position of the rope mass</span></span><br><span class="line">            <span class="comment">// TODO (Part 4): Add global Verlet damping</span></span><br><span class="line">            <span class="type">double</span> damping_factor = <span class="number">0.00005</span>;</span><br><span class="line"></span><br><span class="line">            m-&gt;position = m-&gt;position + (<span class="number">1</span> - damping_factor) * (m-&gt;position - m-&gt;last_position) + <span class="type">a_t</span> * <span class="type">delta_t</span> * <span class="type">delta_t</span>;</span><br><span class="line">            m-&gt;last_position = temp_position;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reset all forces on each mass</span></span><br><span class="line">        m-&gt;forces = <span class="built_in">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们置<span
class="math inline">\(k_d=0\)</span>，则弹簧永远不会停下来：</p>
<p><img data-src="/images/games101/8-3.png" /></p>
<p>如果令<span
class="math inline">\(k_d=0.00005\)</span>，则弹簧能够停止：</p>
<p><img data-src="/images/games101/8-4.png" /></p>
<p>至此，我们已完成了GAMES101 所有作业！完结撒花！</p>
]]></content>
      <categories>
        <category>数学 - 图形学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数学</tag>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>作业</tag>
      </tags>
  </entry>
</search>
